<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OpenCv30Sharp</name>
    </assembly>
    <members>
        <member name="T:OpenCv30Sharp.Cv2">
            <summary>
            OpenCV Functions of C++ I/F (cv::xxx) 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Cv2.PI">
            <summary>
            The ratio of a circle's circumference to its diameter
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Cv2.LOG2">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ToPtr(OpenCv30Sharp.ICvPtrHolder)">
            <summary>
            引数がnullの時はIntPtr.Zeroに変換する
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FAST(OpenCv30Sharp.InputArray,System.Int32,System.Boolean)">
            <summary>
            Detects corners using the FAST algorithm
            </summary>
            <param name="image">grayscale image where keypoints (corners) are detected.</param>
            <param name="threshold">threshold on difference between intensity of the central pixel 
            and pixels of a circle around this pixel.</param>
            <param name="nonmaxSupression">if true, non-maximum suppression is applied to 
            detected corners (keypoints).</param>
            <returns>keypoints detected on the image.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FAST(OpenCv30Sharp.InputArray,System.Int32,System.Boolean,OpenCv30Sharp.FASTType)">
            <summary>
            Detects corners using the FAST algorithm
            </summary>
            <param name="image">grayscale image where keypoints (corners) are detected.</param>
            <param name="threshold">threshold on difference between intensity of the central pixel 
            and pixels of a circle around this pixel.</param>
            <param name="nonmaxSupression">if true, non-maximum suppression is applied to 
            detected corners (keypoints).</param>
            <param name="type">one of the three neighborhoods as defined in the paper</param>
            <returns>keypoints detected on the image.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.AGAST(OpenCv30Sharp.InputArray,System.Int32,System.Boolean,OpenCv30Sharp.AGASTType)">
            <summary>
            Detects corners using the AGAST algorithm
            </summary>
            <param name="image">grayscale image where keypoints (corners) are detected.</param>
            <param name="threshold">threshold on difference between intensity of the central pixel 
            and pixels of a circle around this pixel.</param>
            <param name="nonmaxSuppression">if true, non-maximum suppression is applied to 
            detected corners (keypoints).</param>
            <param name="type">one of the four neighborhoods as defined in the paper</param>
            <returns>keypoints detected on the image.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DrawKeypoints(OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint},OpenCv30Sharp.Mat,System.Nullable{OpenCv30Sharp.Scalar},OpenCv30Sharp.DrawMatchesFlags)">
            <summary>
            Draw keypoints.
            </summary>
            <param name="image"></param>
            <param name="keypoints"></param>
            <param name="outImage"></param>
            <param name="color"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DrawMatches(OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint},OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint},System.Collections.Generic.IEnumerable{OpenCv30Sharp.DMatch},OpenCv30Sharp.Mat,System.Nullable{OpenCv30Sharp.Scalar},System.Nullable{OpenCv30Sharp.Scalar},System.Collections.Generic.IEnumerable{System.Byte},OpenCv30Sharp.DrawMatchesFlags)">
            <summary>
            Draws matches of keypints from two images on output image.
            </summary>
            <param name="img1"></param>
            <param name="keypoints1"></param>
            <param name="img2"></param>
            <param name="keypoints2"></param>
            <param name="matches1To2"></param>
            <param name="outImg"></param>
            <param name="matchColor"></param>
            <param name="singlePointColor"></param>
            <param name="matchesMask"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DrawMatches(OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint},OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.DMatch}},OpenCv30Sharp.Mat,System.Nullable{OpenCv30Sharp.Scalar},System.Nullable{OpenCv30Sharp.Scalar},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Byte}},OpenCv30Sharp.DrawMatchesFlags)">
            <summary>
            Draws matches of keypints from two images on output image.
            </summary>
            <param name="img1"></param>
            <param name="keypoints1"></param>
            <param name="img2"></param>
            <param name="keypoints2"></param>
            <param name="matches1To2"></param>
            <param name="outImg"></param>
            <param name="matchColor"></param>
            <param name="singlePointColor"></param>
            <param name="matchesMask"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.EvaluateFeatureDetector(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.KeyPoint[]@,OpenCv30Sharp.KeyPoint[]@,System.Single@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="img1"></param>
            <param name="img2"></param>
            <param name="H1to2"></param>
            <param name="keypoints1"></param>
            <param name="keypoints2"></param>
            <param name="repeatability"></param>
            <param name="correspCount"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ComputeRecallPrecisionCurve(OpenCv30Sharp.DMatch[][],System.Byte[][])">
            <summary>
            
            </summary>
            <param name="matches1to2"></param>
            <param name="correctMatches1to2Mask"></param>
            <returns>recallPrecisionCurve</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetRecall(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Single)">
            <summary>
            
            </summary>
            <param name="recallPrecisionCurve"></param>
            <param name="lPrecision"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetNearestPoint(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Single)">
            <summary>
            
            </summary>
            <param name="recallPrecisionCurve"></param>
            <param name="lPrecision"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GroupRectangles(System.Collections.Generic.IList{OpenCv30Sharp.Rect},System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList"> Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GroupRectangles(System.Collections.Generic.IList{OpenCv30Sharp.Rect},System.Int32[]@,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList"> Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="weights"></param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GroupRectangles(System.Collections.Generic.IList{OpenCv30Sharp.Rect},System.Int32,System.Double,System.Int32[]@,System.Double[]@)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList"></param>
            <param name="groupThreshold"></param>
            <param name="eps"></param>
            <param name="weights"></param>
            <param name="levelWeights"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GroupRectangles(System.Collections.Generic.IList{OpenCv30Sharp.Rect},System.Int32[]@,System.Double[]@,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList"></param>
            <param name="rejectLevels"></param>
            <param name="levelWeights"></param>
            <param name="groupThreshold"></param>
            <param name="eps"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GroupRectanglesMeanshift(System.Collections.Generic.IList{OpenCv30Sharp.Rect},System.Double[]@,System.Double[]@,System.Double,System.Nullable{OpenCv30Sharp.Size})">
            <summary>
            
            </summary>
            <param name="rectList"></param>
            <param name="foundWeights"></param>
            <param name="foundScales"></param>
            <param name="detectThreshold"></param>
            <param name="winDetSize"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ClearAndAddRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            IListの要素にvaluesを設定する
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="values"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImRead(System.String,OpenCv30Sharp.ImreadModes)">
            <summary>
            Loads an image from a file.
            </summary>
            <param name="fileName">Name of file to be loaded.</param>
            <param name="flags">Specifies color type of the loaded image</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImReadMulti(System.String,OpenCv30Sharp.Mat[]@,OpenCv30Sharp.ImreadModes)">
            <summary>
            Loads a multi-page image from a file. 
            </summary>
            <param name="filename">Name of file to be loaded.</param>
            <param name="mats">A vector of Mat objects holding each page, if more than one.</param>
            <param name="flags">Flag that can take values of @ref cv::ImreadModes, default with IMREAD_ANYCOLOR.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImWrite(System.String,OpenCv30Sharp.Mat,System.Int32[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="img">Image to be saved.</param>
            <param name="prms">Format-specific save parameters encoded as pairs</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImWrite(System.String,OpenCv30Sharp.Mat,OpenCv30Sharp.ImageEncodingParam[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="img">Image to be saved.</param>
            <param name="prms">Format-specific save parameters encoded as pairs</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImDecode(OpenCv30Sharp.Mat,OpenCv30Sharp.ImreadModes)">
            <summary>
            Reads image from the specified buffer in memory.
            </summary>
            <param name="buf">The input array of vector of bytes.</param>
            <param name="flags">The same flags as in imread</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImDecode(OpenCv30Sharp.InputArray,OpenCv30Sharp.ImreadModes)">
            <summary>
            Reads image from the specified buffer in memory.
            </summary>
            <param name="buf">The input array of vector of bytes.</param>
            <param name="flags">The same flags as in imread</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImDecode(System.Byte[],OpenCv30Sharp.ImreadModes)">
            <summary>
            Reads image from the specified buffer in memory.
            </summary>
            <param name="buf">The input array of vector of bytes.</param>
            <param name="flags">The same flags as in imread</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImEncode(System.String,OpenCv30Sharp.InputArray,System.Byte[]@,System.Int32[])">
            <summary>
            Compresses the image and stores it in the memory buffer
            </summary>
            <param name="ext">The file extension that defines the output format</param>
            <param name="img">The image to be written</param>
            <param name="buf">Output buffer resized to fit the compressed image.</param>
            <param name="prms">Format-specific parameters.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImEncode(System.String,OpenCv30Sharp.InputArray,System.Byte[]@,OpenCv30Sharp.ImageEncodingParam[])">
            <summary>
            Compresses the image and stores it in the memory buffer
            </summary>
            <param name="ext">The file extension that defines the output format</param>
            <param name="img">The image to be written</param>
            <param name="buf">Output buffer resized to fit the compressed image.</param>
            <param name="prms">Format-specific parameters.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertImage(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.ConvertImageModes)">
            <summary>
            utility function: convert one image to another with optional vertical flip
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.HaveImageReader(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.HaveImageWriter(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Inpaint(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double,OpenCv30Sharp.InpaintMethod)">
            <summary>
            restores the damaged image areas using one of the available intpainting algorithms
            </summary>
            <param name="src"></param>
            <param name="inpaintMask"></param>
            <param name="dst"></param>
            <param name="inpaintRadius"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FastNlMeansDenoising(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Single,System.Int32,System.Int32)">
            <summary>
            Perform image denoising using Non-local Means Denoising algorithm 
            with several computational optimizations. Noise expected to be a gaussian white noise
            </summary>
            <param name="src">Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src .</param>
            <param name="h">
            Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, 
            smaller h value preserves details but also preserves some noise</param>
            <param name="templateWindowSize">
            Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">
            Size in pixels of the window that is used to compute weighted average for given pixel. 
            Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FastNlMeansDenoisingColored(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Modification of fastNlMeansDenoising function for colored images
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength for luminance component. 
            Bigger h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise</param>
            <param name="hColor">The same as h but for color components. For most images value equals 10 will be enought 
            to remove colored noise and do not distort colors</param>
            <param name="templateWindowSize">
            Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">
            Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. 
            Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FastNlMeansDenoisingMulti(System.Collections.Generic.IEnumerable{OpenCv30Sharp.InputArray},OpenCv30Sharp.OutputArray,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
            <summary>
            Modification of fastNlMeansDenoising function for images sequence where consequtive images have been captured 
            in small period of time. For example video. This version of the function is for grayscale images or for manual manipulation with colorspaces.
            </summary>
            <param name="srcImgs">Input 8-bit 1-channel, 2-channel or 3-channel images sequence. All images should have the same type and size.</param>
            <param name="dst"> Output image with the same size and type as srcImgs images.</param>
            <param name="imgToDenoiseIndex">Target image to denoise index in srcImgs sequence</param>
            <param name="temporalWindowSize">Number of surrounding images to use for target image denoising. 
            Should be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 
            from srcImgs will be used to denoise srcImgs[imgToDenoiseIndex] image.</param>
            <param name="h">Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise but also removes image details, 
            smaller h value preserves details but also preserves some noise</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. 
            Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FastNlMeansDenoisingMulti(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},OpenCv30Sharp.OutputArray,System.Int32,System.Int32,System.Single,System.Int32,System.Int32)">
            <summary>
            Modification of fastNlMeansDenoising function for images sequence where consequtive images have been captured 
            in small period of time. For example video. This version of the function is for grayscale images or for manual manipulation with colorspaces.
            </summary>
            <param name="srcImgs">Input 8-bit 1-channel, 2-channel or 3-channel images sequence. All images should have the same type and size.</param>
            <param name="dst"> Output image with the same size and type as srcImgs images.</param>
            <param name="imgToDenoiseIndex">Target image to denoise index in srcImgs sequence</param>
            <param name="temporalWindowSize">Number of surrounding images to use for target image denoising. 
            Should be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 
            from srcImgs will be used to denoise srcImgs[imgToDenoiseIndex] image.</param>
            <param name="h">Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise but also removes image details, 
            smaller h value preserves details but also preserves some noise</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. 
            Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FastNlMeansDenoisingColoredMulti(System.Collections.Generic.IEnumerable{OpenCv30Sharp.InputArray},OpenCv30Sharp.OutputArray,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Modification of fastNlMeansDenoisingMulti function for colored images sequences
            </summary>
            <param name="srcImgs">Input 8-bit 3-channel images sequence. All images should have the same type and size.</param>
            <param name="dst">Output image with the same size and type as srcImgs images.</param>
            <param name="imgToDenoiseIndex">Target image to denoise index in srcImgs sequence</param>
            <param name="temporalWindowSize">Number of surrounding images to use for target image denoising. Should be odd. 
            Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs 
            will be used to denoise srcImgs[imgToDenoiseIndex] image.</param>
            <param name="h">Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise 
            but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="hColor"> The same as h but for color components.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. 
            Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FastNlMeansDenoisingColoredMulti(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},OpenCv30Sharp.OutputArray,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Modification of fastNlMeansDenoisingMulti function for colored images sequences
            </summary>
            <param name="srcImgs">Input 8-bit 3-channel images sequence. All images should have the same type and size.</param>
            <param name="dst">Output image with the same size and type as srcImgs images.</param>
            <param name="imgToDenoiseIndex">Target image to denoise index in srcImgs sequence</param>
            <param name="temporalWindowSize">Number of surrounding images to use for target image denoising. Should be odd. 
            Images from imgToDenoiseIndex - temporalWindowSize / 2 to imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs 
            will be used to denoise srcImgs[imgToDenoiseIndex] image.</param>
            <param name="h">Parameter regulating filter strength for luminance component. Bigger h value perfectly removes noise 
            but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="hColor"> The same as h but for color components.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd. Recommended value 7 pixels</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. 
            Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time. Recommended value 21 pixels</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DenoiseTVL1(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},OpenCv30Sharp.Mat,System.Double,System.Int32)">
            <summary>
            Primal-dual algorithm is an algorithm for solving special types of variational problems 
            (that is, finding a function to minimize some functional). As the image denoising, 
            in particular, may be seen as the variational problem, primal-dual algorithm then 
            can be used to perform denoising and this is exactly what is implemented.
            </summary>
            <param name="observations">This array should contain one or more noised versions 
            of the image that is to be restored.</param>
            <param name="result">Here the denoised image will be stored. There is no need to 
            do pre-allocation of storage space, as it will be automatically allocated, if necessary.</param>
            <param name="lambda">Corresponds to \f$\lambda\f$ in the formulas above. 
            As it is enlarged, the smooth (blurred) images are treated more favorably than 
            detailed (but maybe more noised) ones. Roughly speaking, as it becomes smaller, 
            the result will be more blur but more sever outliers will be removed.</param>
            <param name="niters"> Number of iterations that the algorithm will run. 
            Of course, as more iterations as better, but it is hard to quantitatively 
            refine this statement, so just use the default and increase it if the results are poor.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Decolor(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Transforms a color image to a grayscale image. It is a basic tool in digital 
            printing, stylized black-and-white photograph rendering, and in many single 
            channel image processing applications @cite CL12 .
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="grayscale">Output 8-bit 1-channel image.</param>
            <param name="colorBoost">Output 8-bit 3-channel image.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SeamlessClone(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Point,OpenCv30Sharp.OutputArray,OpenCv30Sharp.SeamlessCloneMethods)">
            <summary>
            Image editing tasks concern either global changes (color/intensity corrections, 
            filters, deformations) or local changes concerned to a selection. Here we are 
            interested in achieving local changes, ones that are restricted to a region 
            manually selected (ROI), in a seamless and effortless manner. The extent of 
            the changes ranges from slight distortions to complete replacement by novel 
            content @cite PM03 .
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="p">Point in dst image where object is placed.</param>
            <param name="blend">Output image with the same size and type as dst.</param>
            <param name="flags">Cloning method</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ColorChange(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Given an original color image, two differently colored versions of this 
            image can be mixed seamlessly. Multiplication factor is between 0.5 to 2.5.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="redMul">R-channel multiply factor.</param>
            <param name="greenMul">G-channel multiply factor.</param>
            <param name="blueMul">B-channel multiply factor.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.IlluminationChange(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Single,System.Single)">
            <summary>
            Applying an appropriate non-linear transformation to the gradient field inside 
            the selection and then integrating back with a Poisson solver, modifies locally 
            the apparent illumination of an image.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="alpha">Value ranges between 0-2.</param>
            <param name="beta">Value ranges between 0-2.</param>
            <remarks>
            This is useful to highlight under-exposed foreground objects or to reduce specular reflections.
            </remarks>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.TextureFlattening(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Single,System.Single,System.Int32)">
            <summary>
            By retaining only the gradients at edge locations, before integrating with the 
            Poisson solver, one washes out the texture of the selected region, giving its 
            contents a flat aspect. Here Canny Edge Detector is used.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="lowThreshold">Range from 0 to 100.</param>
            <param name="highThreshold">Value &gt; 100.</param>
            <param name="kernelSize">The size of the Sobel kernel to be used.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.EdgePreservingFilter(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.EdgePreservingMethods,System.Single,System.Single)">
            <summary>
            Filtering is the fundamental operation in image and video processing. 
            Edge-preserving smoothing filters are used in many different applications @cite EM11 .
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output 8-bit 3-channel image.</param>
            <param name="flags">Edge preserving filters</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR">Range between 0 to 1.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DetailEnhance(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Single,System.Single)">
            <summary>
            This filter enhances the details of a particular image.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR">Range between 0 to 1.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PencilSketch(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Pencil-like non-photorealistic line drawing
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst1">Output 8-bit 1-channel image.</param>
            <param name="dst2">Output image with the same size and type as src.</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR">Range between 0 to 1.</param>
            <param name="shadeFactor">Range between 0 to 0.1.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Stylization(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Single,System.Single)">
            <summary>
            Stylization aims to produce digital imagery with a wide variety of effects 
            not focused on photorealism. Edge-aware filters are ideal for stylization, 
            as they can abstract regions of low contrast while preserving, or enhancing, 
            high-contrast features.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR">Range between 0 to 1.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.UpdateMotionHistory(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,System.Double,System.Double)">
            <summary>
            Updates motion history image using the current silhouette
            </summary>
            <param name="silhouette">Silhouette mask that has non-zero pixels where the motion occurs.</param>
            <param name="mhi">Motion history image that is updated by the function (single-channel, 32-bit floating-point).</param>
            <param name="timestamp">Current time in milliseconds or other units.</param>
            <param name="duration">Maximal duration of the motion track in the same units as timestamp .</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcMotionGradient(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Double,System.Double,System.Int32)">
            <summary>
            Computes the motion gradient orientation image from the motion history image
            </summary>
            <param name="mhi">Motion history single-channel floating-point image.</param>
            <param name="mask">Output mask image that has the type CV_8UC1 and the same size as mhi. 
            Its non-zero elements mark pixels where the motion gradient data is correct.</param>
            <param name="orientation">Output motion gradient orientation image that has the same type and the same size as mhi. 
            Each pixel of the image is a motion orientation, from 0 to 360 degrees.</param>
            <param name="delta1">Minimal (or maximal) allowed difference between mhi values within a pixel neighborhood.</param>
            <param name="delta2">Maximal (or minimal) allowed difference between mhi values within a pixel neighborhood. 
            That is, the function finds the minimum ( m(x,y) ) and maximum ( M(x,y) ) mhi values over 3x3 neighborhood of each pixel 
            and marks the motion orientation at (x, y) as valid only if: 
            min(delta1, delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1, delta2).</param>
            <param name="apertureSize"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcGlobalOrientation(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,System.Double,System.Double)">
            <summary>
            Computes the global orientation of the selected motion history image part
            </summary>
            <param name="orientation">Motion gradient orientation image calculated by the function CalcMotionGradient() .</param>
            <param name="mask">Mask image. It may be a conjunction of a valid gradient mask, also calculated by CalcMotionGradient() ,
            and the mask of a region whose direction needs to be calculated.</param>
            <param name="mhi">Motion history image calculated by UpdateMotionHistory() .</param>
            <param name="timestamp">Timestamp passed to UpdateMotionHistory() .</param>
            <param name="duration">Maximum duration of a motion track in milliseconds, passed to UpdateMotionHistory() .</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SegmentMotion(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.Rect[]@,System.Double,System.Double)">
            <summary>
            Splits a motion history image into a few parts corresponding to separate independent motions 
            (for example, left hand, right hand).
            </summary>
            <param name="mhi">Motion history image.</param>
            <param name="segmask">Image where the found mask should be stored, single-channel, 32-bit floating-point.</param>
            <param name="boundingRects">Vector containing ROIs of motion connected components.</param>
            <param name="timestamp">Current time in milliseconds or other units.</param>
            <param name="segThresh">Segmentation threshold that is recommended to be equal to the interval between motion history “steps” or greater.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcOpticalFlowSF(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Int32,System.Int32,System.Int32)">
            <summary>
            computes dense optical flow using Simple Flow algorithm
            </summary>
            <param name="from">First 8-bit 3-channel image.</param>
            <param name="to">Second 8-bit 3-channel image</param>
            <param name="flow">Estimated flow</param>
            <param name="layers">Number of layers</param>
            <param name="averagingBlockSize">Size of block through which we sum up when calculate cost function for pixel</param>
            <param name="maxFlow">maximal flow that we search at each level</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.calcOpticalFlowSF(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            computes dense optical flow using Simple Flow algorithm
            </summary>
            <param name="from">First 8-bit 3-channel image.</param>
            <param name="to">Second 8-bit 3-channel image</param>
            <param name="flow">Estimated flow</param>
            <param name="layers">Number of layers</param>
            <param name="averagingBlockSize">Size of block through which we sum up when calculate cost function for pixel</param>
            <param name="maxFlow">maximal flow that we search at each level</param>
            <param name="sigmaDist">vector smooth spatial sigma parameter</param>
            <param name="sigmaColor">vector smooth color sigma parameter</param>
            <param name="postprocessWindow">window size for postprocess cross bilateral filter</param>
            <param name="sigmaDistFix">spatial sigma for postprocess cross bilateralf filter</param>
            <param name="sigmaColorFix">color sigma for postprocess cross bilateral filter</param>
            <param name="occThr">threshold for detecting occlusions</param>
            <param name="upscaleAveragingRadius">window size for bilateral upscale operation</param>
            <param name="upscaleSigmaDist">spatial sigma for bilateral upscale operation</param>
            <param name="upscaleSigmaColor">color sigma for bilateral upscale operation</param>
            <param name="speedUpThr">threshold to detect point with irregular flow - where flow should be recalculated after upscale</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CamShift(OpenCv30Sharp.InputArray,OpenCv30Sharp.Rect@,OpenCv30Sharp.TermCriteria)">
            <summary>
            Finds an object center, size, and orientation.
            </summary>
            <param name="probImage">Back projection of the object histogram. </param>
            <param name="window">Initial search window.</param>
            <param name="criteria">Stop criteria for the underlying MeanShift() .</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MeanShift(OpenCv30Sharp.InputArray,OpenCv30Sharp.Rect@,OpenCv30Sharp.TermCriteria)">
            <summary>
            Finds an object on a back projection image.
            </summary>
            <param name="probImage">Back projection of the object histogram.</param>
            <param name="window">Initial search window.</param>
            <param name="criteria">Stop criteria for the iterative search algorithm.</param>
            <returns>Number of iterations CAMSHIFT took to converge.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BuildOpticalFlowPyramid(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.Size,System.Int32,System.Boolean,OpenCv30Sharp.BorderTypes,OpenCv30Sharp.BorderTypes,System.Boolean)">
            <summary>
            Constructs a pyramid which can be used as input for calcOpticalFlowPyrLK
            </summary>
            <param name="img">8-bit input image.</param>
            <param name="pyramid">output pyramid.</param>
            <param name="winSize">window size of optical flow algorithm. 
            Must be not less than winSize argument of calcOpticalFlowPyrLK(). 
            It is needed to calculate required padding for pyramid levels.</param>
            <param name="maxLevel">0-based maximal pyramid level number.</param>
            <param name="withDerivatives">set to precompute gradients for the every pyramid level. 
            If pyramid is constructed without the gradients then calcOpticalFlowPyrLK() will 
            calculate them internally.</param>
            <param name="pyrBorder">the border mode for pyramid layers.</param>
            <param name="derivBorder">the border mode for gradients.</param>
            <param name="tryReuseInputImage">put ROI of input image into the pyramid if possible. 
            You can pass false to force data copying.</param>
            <returns>number of levels in constructed pyramid. Can be less than maxLevel.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BuildOpticalFlowPyramid(OpenCv30Sharp.InputArray,OpenCv30Sharp.Mat[]@,OpenCv30Sharp.Size,System.Int32,System.Boolean,OpenCv30Sharp.BorderTypes,OpenCv30Sharp.BorderTypes,System.Boolean)">
            <summary>
            Constructs a pyramid which can be used as input for calcOpticalFlowPyrLK
            </summary>
            <param name="img">8-bit input image.</param>
            <param name="pyramid">output pyramid.</param>
            <param name="winSize">window size of optical flow algorithm. 
            Must be not less than winSize argument of calcOpticalFlowPyrLK(). 
            It is needed to calculate required padding for pyramid levels.</param>
            <param name="maxLevel">0-based maximal pyramid level number.</param>
            <param name="withDerivatives">set to precompute gradients for the every pyramid level. 
            If pyramid is constructed without the gradients then calcOpticalFlowPyrLK() will 
            calculate them internally.</param>
            <param name="pyrBorder">the border mode for pyramid layers.</param>
            <param name="derivBorder">the border mode for gradients.</param>
            <param name="tryReuseInputImage">put ROI of input image into the pyramid if possible. 
            You can pass false to force data copying.</param>
            <returns>number of levels in constructed pyramid. Can be less than maxLevel.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcOpticalFlowPyrLK(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Nullable{OpenCv30Sharp.Size},System.Int32,System.Nullable{OpenCv30Sharp.TermCriteria},OpenCv30Sharp.OpticalFlowFlags,System.Double)">
            <summary>
            computes sparse optical flow using multi-scale Lucas-Kanade algorithm
            </summary>
            <param name="prevImg"></param>
            <param name="nextImg"></param>
            <param name="prevPts"></param>
            <param name="nextPts"></param>
            <param name="status"></param>
            <param name="err"></param>
            <param name="winSize"></param>
            <param name="maxLevel"></param>
            <param name="criteria"></param>
            <param name="flags"></param>
            <param name="minEigThreshold"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcOpticalFlowPyrLK(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Point2f[],OpenCv30Sharp.Point2f[]@,System.Byte[]@,System.Single[]@,System.Nullable{OpenCv30Sharp.Size},System.Int32,System.Nullable{OpenCv30Sharp.TermCriteria},OpenCv30Sharp.OpticalFlowFlags,System.Double)">
            <summary>
            computes sparse optical flow using multi-scale Lucas-Kanade algorithm
            </summary>
            <param name="prevImg"></param>
            <param name="nextImg"></param>
            <param name="prevPts"></param>
            <param name="nextPts"></param>
            <param name="status"></param>
            <param name="err"></param>
            <param name="winSize"></param>
            <param name="maxLevel"></param>
            <param name="criteria"></param>
            <param name="flags"></param>
            <param name="minEigThreshold"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcOpticalFlowFarneback(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,OpenCv30Sharp.OpticalFlowFlags)">
            <summary>
            Computes a dense optical flow using the Gunnar Farneback's algorithm.
            </summary>
            <param name="prev">first 8-bit single-channel input image.</param>
            <param name="next">second input image of the same size and the same type as prev.</param>
            <param name="flow">computed flow image that has the same size as prev and type CV_32FC2.</param>
            <param name="pyrScale">parameter, specifying the image scale (&lt;1) to build pyramids for each image; 
            pyrScale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one.</param>
            <param name="levels">number of pyramid layers including the initial image; 
            levels=1 means that no extra layers are created and only the original images are used.</param>
            <param name="winsize">averaging window size; larger values increase the algorithm robustness to 
            image noise and give more chances for fast motion detection, but yield more blurred motion field.</param>
            <param name="iterations">number of iterations the algorithm does at each pyramid level.</param>
            <param name="polyN">size of the pixel neighborhood used to find polynomial expansion in each pixel; 
            larger values mean that the image will be approximated with smoother surfaces, 
            yielding more robust algorithm and more blurred motion field, typically poly_n =5 or 7.</param>
            <param name="polySigma">standard deviation of the Gaussian that is used to smooth derivatives used as 
            a basis for the polynomial expansion; for polyN=5, you can set polySigma=1.1, 
            for polyN=7, a good value would be polySigma=1.5.</param>
            <param name="flags">operation flags that can be a combination of OPTFLOW_USE_INITIAL_FLOW and/or OPTFLOW_FARNEBACK_GAUSSIAN</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.EstimateRigidTransform(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Estimates the best-fit Euqcidean, similarity, affine or perspective transformation
            that maps one 2D point set to another or one image to another.
            </summary>
            <param name="src">First input 2D point set stored in std::vector or Mat, or an image stored in Mat.</param>
            <param name="dst">Second input 2D point set of the same size and the same type as A, or another image.</param>
            <param name="fullAffine">If true, the function finds an optimal affine transformation with no additional restrictions (6 degrees of freedom). 
            Otherwise, the class of transformations to choose from is limited to combinations of translation, rotation, and uniform scaling (5 degrees of freedom).</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_DualTVL1">
            <summary>
            Implementation of the Zach, Pock and Bischof Dual TV-L1 Optical Flow method
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateFrameSource_Empty">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateFrameSource_Video(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateFrameSource_Video_CUDA(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateFrameSource_Camera(System.Int32)">
            <summary>
            
            </summary>
            <param name="deviceId"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateSuperResolution_BTVL1">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateSuperResolution_BTVL1_CUDA">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateSuperResolution_BTVL1_OCL">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_Farneback">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_Farneback_GPU">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_Farneback_OCL">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_Simple">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_DualTVL1Ex">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_DualTVL1_GPU">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_DualTVL1_OCL">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_Brox_GPU">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_PyrLK_GPU">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateOptFlow_PyrLK_OCL">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rodrigues(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            converts rotation vector to rotation matrix or vice versa using Rodrigues transformation
            </summary>
            <param name="src">Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).</param>
            <param name="dst">Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial derivatives of the output array components with respect to the input array components.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rodrigues(System.Double[],System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>
            converts rotation vector to rotation matrix using Rodrigues transformation
            </summary>
            <param name="vector">Input rotation vector (3x1).</param>
            <param name="matrix">Output rotation matrix (3x3).</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9, which is a matrix of partial derivatives of the output array components with respect to the input array components.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rodrigues(System.Double[],System.Double[0:,0:]@)">
            <summary>
            converts rotation vector to rotation matrix using Rodrigues transformation
            </summary>
            <param name="vector">Input rotation vector (3x1).</param>
            <param name="matrix">Output rotation matrix (3x3).</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rodrigues(System.Double[0:,0:],System.Double[]@,System.Double[0:,0:]@)">
            <summary>
            converts rotation matrix to rotation vector using Rodrigues transformation
            </summary>
            <param name="matrix">Input rotation matrix (3x3).</param>
            <param name="vector">Output rotation vector (3x1).</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9, which is a matrix of partial derivatives of the output array components with respect to the input array components.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rodrigues(System.Double[0:,0:],System.Double[]@)">
            <summary>
            converts rotation matrix to rotation vector using Rodrigues transformation
            </summary>
            <param name="matrix">Input rotation matrix (3x3).</param>
            <param name="vector">Output rotation vector (3x1).</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindHomography(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.HomographyMethods,System.Double,OpenCv30Sharp.OutputArray)">
            <summary>
            computes the best-fit perspective transformation mapping srcPoints to dstPoints.
            </summary>
            <param name="srcPoints">Coordinates of the points in the original plane, a matrix of the type CV_32FC2</param>
            <param name="dstPoints">Coordinates of the points in the target plane, a matrix of the type CV_32FC2</param>
            <param name="method">Method used to computed a homography matrix.</param>
            <param name="ransacReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier (used in the RANSAC method only)</param>
            <param name="mask"> Optional output mask set by a robust method ( CV_RANSAC or CV_LMEDS ). Note that the input mask values are ignored.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindHomography(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},OpenCv30Sharp.HomographyMethods,System.Double,OpenCv30Sharp.OutputArray)">
            <summary>
            computes the best-fit perspective transformation mapping srcPoints to dstPoints.
            </summary>
            <param name="srcPoints">Coordinates of the points in the original plane</param>
            <param name="dstPoints">Coordinates of the points in the target plane</param>
            <param name="method">Method used to computed a homography matrix.</param>
            <param name="ransacReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier (used in the RANSAC method only)</param>
            <param name="mask"> Optional output mask set by a robust method ( CV_RANSAC or CV_LMEDS ). Note that the input mask values are ignored.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.RQDecomp3x3(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Computes RQ decomposition of 3x3 matrix
            </summary>
            <param name="src">3x3 input matrix.</param>
            <param name="mtxR">Output 3x3 upper-triangular matrix.</param>
            <param name="mtxQ"> Output 3x3 orthogonal matrix.</param>
            <param name="qx">Optional output 3x3 rotation matrix around x-axis.</param>
            <param name="qy">Optional output 3x3 rotation matrix around y-axis.</param>
            <param name="qz">Optional output 3x3 rotation matrix around z-axis.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.RQDecomp3x3(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>
            Computes RQ decomposition of 3x3 matrix
            </summary>
            <param name="src">3x3 input matrix.</param>
            <param name="mtxR">Output 3x3 upper-triangular matrix.</param>
            <param name="mtxQ"> Output 3x3 orthogonal matrix.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.RQDecomp3x3(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>
            Computes RQ decomposition of 3x3 matrix
            </summary>
            <param name="src">3x3 input matrix.</param>
            <param name="mtxR">Output 3x3 upper-triangular matrix.</param>
            <param name="mtxQ"> Output 3x3 orthogonal matrix.</param>
            <param name="qx">Optional output 3x3 rotation matrix around x-axis.</param>
            <param name="qy">Optional output 3x3 rotation matrix around y-axis.</param>
            <param name="qz">Optional output 3x3 rotation matrix around z-axis.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DecomposeProjectionMatrix(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Decomposes the projection matrix into camera matrix and the rotation martix and the translation vector
            </summary>
            <param name="projMatrix">3x4 input projection matrix P.</param>
            <param name="cameraMatrix">Output 3x3 camera matrix K.</param>
            <param name="rotMatrix">Output 3x3 external rotation matrix R.</param>
            <param name="transVect">Output 4x1 translation vector T.</param>
            <param name="rotMatrixX">Optional 3x3 rotation matrix around x-axis.</param>
            <param name="rotMatrixY">Optional 3x3 rotation matrix around y-axis.</param>
            <param name="rotMatrixZ">Optional 3x3 rotation matrix around z-axis.</param>
            <param name="eulerAngles">ptional three-element vector containing three Euler angles of rotation in degrees.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DecomposeProjectionMatrix(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[]@)">
            <summary>
            Decomposes the projection matrix into camera matrix and the rotation martix and the translation vector
            </summary>
            <param name="projMatrix">3x4 input projection matrix P.</param>
            <param name="cameraMatrix">Output 3x3 camera matrix K.</param>
            <param name="rotMatrix">Output 3x3 external rotation matrix R.</param>
            <param name="transVect">Output 4x1 translation vector T.</param>
            <param name="rotMatrixX">Optional 3x3 rotation matrix around x-axis.</param>
            <param name="rotMatrixY">Optional 3x3 rotation matrix around y-axis.</param>
            <param name="rotMatrixZ">Optional 3x3 rotation matrix around z-axis.</param>
            <param name="eulerAngles">ptional three-element vector containing three Euler angles of rotation in degrees.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DecomposeProjectionMatrix(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[]@)">
            <summary>
            Decomposes the projection matrix into camera matrix and the rotation martix and the translation vector
            </summary>
            <param name="projMatrix">3x4 input projection matrix P.</param>
            <param name="cameraMatrix">Output 3x3 camera matrix K.</param>
            <param name="rotMatrix">Output 3x3 external rotation matrix R.</param>
            <param name="transVect">Output 4x1 translation vector T.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MatMulDeriv(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            computes derivatives of the matrix product w.r.t each of the multiplied matrix coefficients
            </summary>
            <param name="a">First multiplied matrix.</param>
            <param name="b">Second multiplied matrix.</param>
            <param name="dABdA">First output derivative matrix d(A*B)/dA of size A.rows*B.cols X A.rows*A.cols .</param>
            <param name="dABdB">Second output derivative matrix d(A*B)/dB of size A.rows*B.cols X B.rows*B.cols .</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ComposeRT(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            composes 2 [R|t] transformations together. Also computes the derivatives of the result w.r.t the arguments
            </summary>
            <param name="rvec1">First rotation vector.</param>
            <param name="tvec1">First translation vector.</param>
            <param name="rvec2">Second rotation vector.</param>
            <param name="tvec2">Second translation vector.</param>
            <param name="rvec3">Output rotation vector of the superposition.</param>
            <param name="tvec3">Output translation vector of the superposition.</param>
            <param name="dr3dr1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dt1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dr2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dt2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dr1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dt1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dr2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dt2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ComposeRT(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[]@,System.Double[]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>
            composes 2 [R|t] transformations together. Also computes the derivatives of the result w.r.t the arguments
            </summary>
            <param name="rvec1">First rotation vector.</param>
            <param name="tvec1">First translation vector.</param>
            <param name="rvec2">Second rotation vector.</param>
            <param name="tvec2">Second translation vector.</param>
            <param name="rvec3">Output rotation vector of the superposition.</param>
            <param name="tvec3">Output translation vector of the superposition.</param>
            <param name="dr3dr1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dt1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dr2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dr3dt2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dr1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dt1">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dr2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
            <param name="dt3dt2">Optional output derivatives of rvec3 or tvec3 with regard to rvec1, rvec2, tvec1 and tvec2, respectively.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ComposeRT(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[]@,System.Double[]@)">
            <summary>
            composes 2 [R|t] transformations together. Also computes the derivatives of the result w.r.t the arguments
            </summary>
            <param name="rvec1">First rotation vector.</param>
            <param name="tvec1">First translation vector.</param>
            <param name="rvec2">Second rotation vector.</param>
            <param name="tvec2">Second translation vector.</param>
            <param name="rvec3">Output rotation vector of the superposition.</param>
            <param name="tvec3">Output translation vector of the superposition.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ProjectPoints(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Double)">
            <summary>
            projects points from the model coordinate space to the image coordinates. 
            Also computes derivatives of the image coordinates w.r.t the intrinsic 
            and extrinsic camera parameters
            </summary>
            <param name="objectPoints">Array of object points, 3xN/Nx3 1-channel or 
            1xN/Nx1 3-channel, where N is the number of points in the view.</param>
            <param name="rvec">Rotation vector (3x1).</param>
            <param name="tvec">Translation vector (3x1).</param>
            <param name="cameraMatrix">Camera matrix (3x3)</param>
            <param name="distCoeffs">Input vector of distortion coefficients 
            (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="imagePoints">Output array of image points, 2xN/Nx2 1-channel 
            or 1xN/Nx1 2-channel</param>
            <param name="jacobian">Optional output 2Nx(10 + numDistCoeffs) jacobian matrix 
            of derivatives of image points with respect to components of the rotation vector, 
            translation vector, focal lengths, coordinates of the principal point and 
            the distortion coefficients. In the old interface different components of 
            the jacobian are returned via different output parameters.</param>
            <param name="aspectRatio">Optional “fixed aspect ratio” parameter. 
            If the parameter is not 0, the function assumes that the aspect ratio (fx/fy) 
            is fixed and correspondingly adjusts the jacobian matrix.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ProjectPoints(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f},System.Double[],System.Double[],System.Double[0:,0:],System.Double[],OpenCv30Sharp.Point2f[]@,System.Double[0:,0:]@,System.Double)">
            <summary>
            projects points from the model coordinate space to the image coordinates. 
            Also computes derivatives of the image coordinates w.r.t the intrinsic 
            and extrinsic camera parameters
            </summary>
            <param name="objectPoints">Array of object points, 3xN/Nx3 1-channel or 
            1xN/Nx1 3-channel, where N is the number of points in the view.</param>
            <param name="rvec">Rotation vector (3x1).</param>
            <param name="tvec">Translation vector (3x1).</param>
            <param name="cameraMatrix">Camera matrix (3x3)</param>
            <param name="distCoeffs">Input vector of distortion coefficients 
            (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="imagePoints">Output array of image points, 2xN/Nx2 1-channel 
            or 1xN/Nx1 2-channel</param>
            <param name="jacobian">Optional output 2Nx(10 + numDistCoeffs) jacobian matrix 
            of derivatives of image points with respect to components of the rotation vector, 
            translation vector, focal lengths, coordinates of the principal point and 
            the distortion coefficients. In the old interface different components of 
            the jacobian are returned via different output parameters.</param>
            <param name="aspectRatio">Optional “fixed aspect ratio” parameter. 
            If the parameter is not 0, the function assumes that the aspect ratio (fx/fy) 
            is fixed and correspondingly adjusts the jacobian matrix.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SolvePnP(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Boolean,OpenCv30Sharp.SolvePnPFlags)">
            <summary>
            Finds an object pose from 3D-2D point correspondences.
            </summary>
            <param name="objectPoints"> Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. vector&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, 
            where N is the number of points. vector&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system to the 
            camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations of 
            the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="flags">Method for solving a PnP problem:</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SolvePnP(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Double[0:,0:],System.Collections.Generic.IEnumerable{System.Double},System.Double[]@,System.Double[]@,System.Boolean,OpenCv30Sharp.SolvePnPFlags)">
            <summary>
            Finds an object pose from 3D-2D point correspondences.
            </summary>
            <param name="objectPoints"> Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. vector&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, 
            where N is the number of points. vector&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system to the 
            camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations of 
            the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="flags">Method for solving a PnP problem:</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SolvePnPRansac(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Boolean,System.Int32,System.Single,System.Double,OpenCv30Sharp.OutputArray,OpenCv30Sharp.SolvePnPFlags)">
            <summary>
            computes the camera pose from a few 3D points and the corresponding projections. The outliers are possible.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. List&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. 
            List&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input 3x3 camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system 
            to the camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations 
            of the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="iterationsCount">Number of iterations.</param>
            <param name="reprojectionError">Inlier threshold value used by the RANSAC procedure. 
            The parameter value is the maximum allowed distance between the observed and computed point projections to consider it an inlier.</param>
            <param name="confidence">The probability that the algorithm produces a useful result.</param>
            <param name="inliers">Output vector that contains indices of inliers in objectPoints and imagePoints .</param>
            <param name="flags">Method for solving a PnP problem</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SolvePnPRansac(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Double[0:,0:],System.Collections.Generic.IEnumerable{System.Double},System.Double[]@,System.Double[]@)">
            <summary>
            computes the camera pose from a few 3D points and the corresponding projections. The outliers are possible.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. List&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. 
            List&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input 3x3 camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system 
            to the camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SolvePnPRansac(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Double[0:,0:],System.Collections.Generic.IEnumerable{System.Double},System.Double[]@,System.Double[]@,System.Int32[]@,System.Boolean,System.Int32,System.Single,System.Double,OpenCv30Sharp.SolvePnPFlags)">
            <summary>
            computes the camera pose from a few 3D points and the corresponding projections. The outliers are possible.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, 
            where N is the number of points. List&lt;Point3f&gt; can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. 
            List&lt;Point2f&gt; can be also passed here.</param>
            <param name="cameraMatrix">Input 3x3 camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector that, together with tvec , brings points from the model coordinate system 
            to the camera coordinate system.</param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations 
            of the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="iterationsCount">Number of iterations.</param>
            <param name="reprojectionError">Inlier threshold value used by the RANSAC procedure. 
            The parameter value is the maximum allowed distance between the observed and computed point projections to consider it an inlier.</param>
            <param name="confidence">The probability that the algorithm produces a useful result.</param>
            <param name="inliers">Output vector that contains indices of inliers in objectPoints and imagePoints .</param>
            <param name="flags">Method for solving a PnP problem</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.InitCameraMatrix2D(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},OpenCv30Sharp.Size,System.Double)">
            <summary>
            initializes camera matrix from a few 3D points and the corresponding projections.
            </summary>
            <param name="objectPoints">Vector of vectors (vector&lt;vector&lt;Point3d&gt;&gt;) of the calibration pattern points in the calibration pattern coordinate space. In the old interface all the per-view vectors are concatenated.</param>
            <param name="imagePoints">Vector of vectors (vector&lt;vector&lt;Point2d&gt;&gt;) of the projections of the calibration pattern points. In the old interface all the per-view vectors are concatenated.</param>
            <param name="imageSize">Image size in pixels used to initialize the principal point.</param>
            <param name="aspectRatio">If it is zero or negative, both f_x and f_y are estimated independently. Otherwise, f_x = f_y * aspectRatio .</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.InitCameraMatrix2D(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3d}},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d}},OpenCv30Sharp.Size,System.Double)">
            <summary>
            initializes camera matrix from a few 3D points and the corresponding projections.
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points in the calibration pattern coordinate space. In the old interface all the per-view vectors are concatenated.</param>
            <param name="imagePoints">Vector of vectors of the projections of the calibration pattern points. In the old interface all the per-view vectors are concatenated.</param>
            <param name="imageSize">Image size in pixels used to initialize the principal point.</param>
            <param name="aspectRatio">If it is zero or negative, both f_x and f_y are estimated independently. Otherwise, f_x = f_y * aspectRatio .</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindChessboardCorners(OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.OutputArray,OpenCv30Sharp.ChessboardFlags)">
            <summary>
            Finds the positions of internal corners of the chessboard.
            </summary>
            <param name="image">Source chessboard view. It must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column 
            ( patternSize = Size(points_per_row,points_per_colum) = Size(columns, rows) ).</param>
            <param name="corners">Output array of detected corners.</param>
            <param name="flags">Various operation flags that can be zero or a combination of the ChessboardFlag values</param>
            <returns>The function returns true if all of the corners are found and they are placed in a certain order (row by row, left to right in every row). 
            Otherwise, if the function fails to find all the corners or reorder them, it returns false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindChessboardCorners(OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.Point2f[]@,OpenCv30Sharp.ChessboardFlags)">
            <summary>
            Finds the positions of internal corners of the chessboard.
            </summary>
            <param name="image">Source chessboard view. It must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column 
            ( patternSize = Size(points_per_row,points_per_colum) = Size(columns, rows) ).</param>
            <param name="corners">Output array of detected corners.</param>
            <param name="flags">Various operation flags that can be zero or a combination of the ChessboardFlag values</param>
            <returns>The function returns true if all of the corners are found and they are placed in a certain order (row by row, left to right in every row). 
            Otherwise, if the function fails to find all the corners or reorder them, it returns false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Find4QuadCornerSubpix(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Size)">
            <summary>
            finds subpixel-accurate positions of the chessboard corners
            </summary>
            <param name="img"></param>
            <param name="corners"></param>
            <param name="regionSize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Find4QuadCornerSubpix(OpenCv30Sharp.InputArray,OpenCv30Sharp.Point2f[],OpenCv30Sharp.Size)">
            <summary>
            finds subpixel-accurate positions of the chessboard corners
            </summary>
            <param name="img"></param>
            <param name="corners"></param>
            <param name="regionSize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DrawChessboardCorners(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Size,OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Renders the detected chessboard corners.
            </summary>
            <param name="image">Destination image. It must be an 8-bit color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column (patternSize = cv::Size(points_per_row,points_per_column)).</param>
            <param name="corners">Array of detected corners, the output of findChessboardCorners.</param>
            <param name="patternWasFound">Parameter indicating whether the complete board was found or not. The return value of findChessboardCorners() should be passed here.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DrawChessboardCorners(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Size,System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Boolean)">
            <summary>
            Renders the detected chessboard corners.
            </summary>
            <param name="image">Destination image. It must be an 8-bit color image.</param>
            <param name="patternSize">Number of inner corners per a chessboard row and column (patternSize = cv::Size(points_per_row,points_per_column)).</param>
            <param name="corners">Array of detected corners, the output of findChessboardCorners.</param>
            <param name="patternWasFound">Parameter indicating whether the complete board was found or not. The return value of findChessboardCorners() should be passed here.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindCirclesGrid(OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.OutputArray,OpenCv30Sharp.FindCirclesGridFlags,OpenCv30Sharp.Feature2D)">
            <summary>
            Finds centers in the grid of circles.
            </summary>
            <param name="image">grid view of input circles; it must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">number of circles per row and column ( patternSize = Size(points_per_row, points_per_colum) ).</param>
            <param name="centers">output array of detected centers.</param>
            <param name="flags">various operation flags that can be one of the FindCirclesGridFlag values</param>
            <param name="blobDetector">feature detector that finds blobs like dark circles on light background.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindCirclesGrid(OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.Point2f[]@,OpenCv30Sharp.FindCirclesGridFlags,OpenCv30Sharp.Feature2D)">
            <summary>
            Finds centers in the grid of circles.
            </summary>
            <param name="image">grid view of input circles; it must be an 8-bit grayscale or color image.</param>
            <param name="patternSize">number of circles per row and column ( patternSize = Size(points_per_row, points_per_colum) ).</param>
            <param name="centers">output array of detected centers.</param>
            <param name="flags">various operation flags that can be one of the FindCirclesGridFlag values</param>
            <param name="blobDetector">feature detector that finds blobs like dark circles on light background.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalibrateCamera(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},OpenCv30Sharp.Size,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Mat[]@,OpenCv30Sharp.Mat[]@,OpenCv30Sharp.CalibrationFlags,System.Nullable{OpenCv30Sharp.TermCriteria})">
            <summary>
            finds intrinsic and extrinsic camera parameters from several fews of a known calibration pattern.
            </summary>
            <param name="objectPoints">In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space. 
            The outer vector contains as many elements as the number of the pattern views. If the same calibration pattern is shown in each view and 
            it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns, or even different patterns 
            in different views. Then, the vectors will be different. The points are 3D, but since they are in a pattern coordinate system, then, 
            if the rig is planar, it may make sense to put the model to a XY coordinate plane so that Z-coordinate of each input object point is 0.
            In the old interface all the vectors of object points from different views are concatenated together.</param>
            <param name="imagePoints">In the new interface it is a vector of vectors of the projections of calibration pattern points. 
            imagePoints.Count() and objectPoints.Count() and imagePoints[i].Count() must be equal to objectPoints[i].Count() for each i.</param>
            <param name="imageSize">Size of the image used only to initialize the intrinsic camera matrix.</param>
            <param name="cameraMatrix">Output 3x3 floating-point camera matrix. 
            If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be 
            initialized before calling the function.</param>
            <param name="distCoeffs">Output vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements.</param>
            <param name="rvecs">Output vector of rotation vectors (see Rodrigues() ) estimated for each pattern view. That is, each k-th rotation vector 
            together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern 
            from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the 
            calibration pattern in the k-th pattern view (k=0.. M -1)</param>
            <param name="tvecs">Output vector of translation vectors estimated for each pattern view.</param>
            <param name="flags">Different flags that may be zero or a combination of the CalibrationFlag values</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalibrateCamera(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f}},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f}},OpenCv30Sharp.Size,System.Double[0:,0:],System.Double[],OpenCv30Sharp.Vec3d[]@,OpenCv30Sharp.Vec3d[]@,OpenCv30Sharp.CalibrationFlags,System.Nullable{OpenCv30Sharp.TermCriteria})">
            <summary>
            finds intrinsic and extrinsic camera parameters from several fews of a known calibration pattern.
            </summary>
            <param name="objectPoints">In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space. 
            The outer vector contains as many elements as the number of the pattern views. If the same calibration pattern is shown in each view and 
            it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns, or even different patterns 
            in different views. Then, the vectors will be different. The points are 3D, but since they are in a pattern coordinate system, then, 
            if the rig is planar, it may make sense to put the model to a XY coordinate plane so that Z-coordinate of each input object point is 0.
            In the old interface all the vectors of object points from different views are concatenated together.</param>
            <param name="imagePoints">In the new interface it is a vector of vectors of the projections of calibration pattern points. 
            imagePoints.Count() and objectPoints.Count() and imagePoints[i].Count() must be equal to objectPoints[i].Count() for each i.</param>
            <param name="imageSize">Size of the image used only to initialize the intrinsic camera matrix.</param>
            <param name="cameraMatrix">Output 3x3 floating-point camera matrix. 
            If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be 
            initialized before calling the function.</param>
            <param name="distCoeffs">Output vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements.</param>
            <param name="rvecs">Output vector of rotation vectors (see Rodrigues() ) estimated for each pattern view. That is, each k-th rotation vector 
            together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern 
            from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the 
            calibration pattern in the k-th pattern view (k=0.. M -1)</param>
            <param name="tvecs">Output vector of translation vectors estimated for each pattern view.</param>
            <param name="flags">Different flags that may be zero or a combination of the CalibrationFlag values</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalibrationMatrixValues(OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,System.Double,System.Double,System.Double@,System.Double@,System.Double@,OpenCv30Sharp.Point2d@,System.Double@)">
            <summary>
            computes several useful camera characteristics from the camera matrix, camera frame resolution and the physical sensor size.
            </summary>
            <param name="cameraMatrix">Input camera matrix that can be estimated by calibrateCamera() or stereoCalibrate() .</param>
            <param name="imageSize">Input image size in pixels.</param>
            <param name="apertureWidth">Physical width of the sensor.</param>
            <param name="apertureHeight">Physical height of the sensor.</param>
            <param name="fovx">Output field of view in degrees along the horizontal sensor axis.</param>
            <param name="fovy">Output field of view in degrees along the vertical sensor axis.</param>
            <param name="focalLength">Focal length of the lens in mm.</param>
            <param name="principalPoint">Principal point in pixels.</param>
            <param name="aspectRatio">fy / fx</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalibrationMatrixValues(System.Double[0:,0:],OpenCv30Sharp.Size,System.Double,System.Double,System.Double@,System.Double@,System.Double@,OpenCv30Sharp.Point2d@,System.Double@)">
            <summary>
            computes several useful camera characteristics from the camera matrix, camera frame resolution and the physical sensor size.
            </summary>
            <param name="cameraMatrix">Input camera matrix that can be estimated by calibrateCamera() or stereoCalibrate() .</param>
            <param name="imageSize">Input image size in pixels.</param>
            <param name="apertureWidth">Physical width of the sensor.</param>
            <param name="apertureHeight">Physical height of the sensor.</param>
            <param name="fovx">Output field of view in degrees along the horizontal sensor axis.</param>
            <param name="fovy">Output field of view in degrees along the vertical sensor axis.</param>
            <param name="focalLength">Focal length of the lens in mm.</param>
            <param name="principalPoint">Principal point in pixels.</param>
            <param name="aspectRatio">fy / fx</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.StereoCalibrate(System.Collections.Generic.IEnumerable{OpenCv30Sharp.InputArray},System.Collections.Generic.IEnumerable{OpenCv30Sharp.InputArray},System.Collections.Generic.IEnumerable{OpenCv30Sharp.InputArray},OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Size,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.CalibrationFlags,System.Nullable{OpenCv30Sharp.TermCriteria})">
            <summary>
            finds intrinsic and extrinsic parameters of a stereo camera
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points.</param>
            <param name="imagePoints1">Vector of vectors of the projections of the calibration pattern points, observed by the first camera.</param>
            <param name="imagePoints2">Vector of vectors of the projections of the calibration pattern points, observed by the second camera.</param>
            <param name="cameraMatrix1">Input/output first camera matrix</param>
            <param name="distCoeffs1">Input/output vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            The output vector length depends on the flags.</param>
            <param name="cameraMatrix2"> Input/output second camera matrix. The parameter is similar to cameraMatrix1 .</param>
            <param name="distCoeffs2">Input/output lens distortion coefficients for the second camera. The parameter is similar to distCoeffs1 .</param>
            <param name="imageSize">Size of the image used only to initialize intrinsic camera matrix.</param>
            <param name="R">Output rotation matrix between the 1st and the 2nd camera coordinate systems.</param>
            <param name="T">Output translation vector between the coordinate systems of the cameras.</param>
            <param name="E">Output essential matrix.</param>
            <param name="F">Output fundamental matrix.</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <param name="flags">Different flags that may be zero or a combination of the CalibrationFlag values</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.StereoCalibrate(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f}},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f}},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f}},System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Double[],OpenCv30Sharp.Size,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.CalibrationFlags,System.Nullable{OpenCv30Sharp.TermCriteria})">
            <summary>
            finds intrinsic and extrinsic parameters of a stereo camera
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points.</param>
            <param name="imagePoints1">Vector of vectors of the projections of the calibration pattern points, observed by the first camera.</param>
            <param name="imagePoints2">Vector of vectors of the projections of the calibration pattern points, observed by the second camera.</param>
            <param name="cameraMatrix1">Input/output first camera matrix</param>
            <param name="distCoeffs1">Input/output vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            The output vector length depends on the flags.</param>
            <param name="cameraMatrix2"> Input/output second camera matrix. The parameter is similar to cameraMatrix1 .</param>
            <param name="distCoeffs2">Input/output lens distortion coefficients for the second camera. The parameter is similar to distCoeffs1 .</param>
            <param name="imageSize">Size of the image used only to initialize intrinsic camera matrix.</param>
            <param name="R">Output rotation matrix between the 1st and the 2nd camera coordinate systems.</param>
            <param name="T">Output translation vector between the coordinate systems of the cameras.</param>
            <param name="E">Output essential matrix.</param>
            <param name="F">Output fundamental matrix.</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <param name="flags">Different flags that may be zero or a combination of the CalibrationFlag values</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.StereoRectify(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.StereoRectificationFlags,System.Double,System.Nullable{OpenCv30Sharp.Size})">
            <summary>
            computes the rectification transformation for a stereo camera from its intrinsic and extrinsic parameters
            </summary>
            <param name="cameraMatrix1">First camera matrix.</param>
            <param name="distCoeffs1">First camera distortion parameters.</param>
            <param name="cameraMatrix2">Second camera matrix.</param>
            <param name="distCoeffs2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="R">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="T">Translation vector between coordinate systems of the cameras.</param>
            <param name="R1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="R2"> Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="P1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="P2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="Q">Output 4x4 disparity-to-depth mapping matrix (see reprojectImageTo3D() ).</param>
            <param name="flags">Operation flags that may be zero or CV_CALIB_ZERO_DISPARITY. 
            If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</param>
            <param name="alpha">Free scaling parameter. 
            If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. 
            alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). 
            alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained 
            in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to initUndistortRectifyMap(). When (0,0) is passed (default), it is set to the original imageSize . 
            Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.StereoRectify(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.StereoRectificationFlags,System.Double,OpenCv30Sharp.Size,OpenCv30Sharp.Rect@,OpenCv30Sharp.Rect@)">
            <summary>
            computes the rectification transformation for a stereo camera from its intrinsic and extrinsic parameters
            </summary>
            <param name="cameraMatrix1">First camera matrix.</param>
            <param name="distCoeffs1">First camera distortion parameters.</param>
            <param name="cameraMatrix2">Second camera matrix.</param>
            <param name="distCoeffs2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="R">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="T">Translation vector between coordinate systems of the cameras.</param>
            <param name="R1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="R2"> Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="P1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="P2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="Q">Output 4x4 disparity-to-depth mapping matrix (see reprojectImageTo3D() ).</param>
            <param name="flags">Operation flags that may be zero or CV_CALIB_ZERO_DISPARITY. 
            If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</param>
            <param name="alpha">Free scaling parameter. 
            If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. 
            alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). 
            alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained 
            in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to initUndistortRectifyMap(). When (0,0) is passed (default), it is set to the original imageSize . 
            Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</param>
            <param name="validPixROI1">Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. 
            Otherwise, they are likely to be smaller.</param>
            <param name="validPixROI2">Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. 
            Otherwise, they are likely to be smaller.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.StereoRectify(System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Double[],OpenCv30Sharp.Size,System.Double[0:,0:],System.Double[],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,OpenCv30Sharp.StereoRectificationFlags,System.Double,System.Nullable{OpenCv30Sharp.Size})">
            <summary>
            computes the rectification transformation for a stereo camera from its intrinsic and extrinsic parameters
            </summary>
            <param name="cameraMatrix1">First camera matrix.</param>
            <param name="distCoeffs1">First camera distortion parameters.</param>
            <param name="cameraMatrix2">Second camera matrix.</param>
            <param name="distCoeffs2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="R">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="T">Translation vector between coordinate systems of the cameras.</param>
            <param name="R1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="R2"> Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="P1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="P2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="Q">Output 4x4 disparity-to-depth mapping matrix (see reprojectImageTo3D() ).</param>
            <param name="flags">Operation flags that may be zero or CV_CALIB_ZERO_DISPARITY. 
            If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</param>
            <param name="alpha">Free scaling parameter. 
            If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. 
            alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). 
            alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained 
            in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to initUndistortRectifyMap(). When (0,0) is passed (default), it is set to the original imageSize . 
            Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.StereoRectify(System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Double[],OpenCv30Sharp.Size,System.Double[0:,0:],System.Double[],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,OpenCv30Sharp.StereoRectificationFlags,System.Double,OpenCv30Sharp.Size,OpenCv30Sharp.Rect@,OpenCv30Sharp.Rect@)">
            <summary>
            computes the rectification transformation for a stereo camera from its intrinsic and extrinsic parameters
            </summary>
            <param name="cameraMatrix1">First camera matrix.</param>
            <param name="distCoeffs1">First camera distortion parameters.</param>
            <param name="cameraMatrix2">Second camera matrix.</param>
            <param name="distCoeffs2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="R">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="T">Translation vector between coordinate systems of the cameras.</param>
            <param name="R1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="R2"> Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="P1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="P2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="Q">Output 4x4 disparity-to-depth mapping matrix (see reprojectImageTo3D() ).</param>
            <param name="flags">Operation flags that may be zero or CV_CALIB_ZERO_DISPARITY. 
            If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</param>
            <param name="alpha">Free scaling parameter. 
            If it is -1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. 
            alpha=0 means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). 
            alpha=1 means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained 
            in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to initUndistortRectifyMap(). When (0,0) is passed (default), it is set to the original imageSize . 
            Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</param>
            <param name="validPixROI1">Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. 
            Otherwise, they are likely to be smaller.</param>
            <param name="validPixROI2">Optional output rectangles inside the rectified images where all the pixels are valid. If alpha=0 , the ROIs cover the whole images. 
            Otherwise, they are likely to be smaller.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.StereoRectifyUncalibrated(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Double)">
            <summary>
            computes the rectification transformation for an uncalibrated stereo camera (zero distortion is assumed)
            </summary>
            <param name="points1">Array of feature points in the first image.</param>
            <param name="points2">The corresponding points in the second image. 
            The same formats as in findFundamentalMat() are supported.</param>
            <param name="F">Input fundamental matrix. It can be computed from the same set 
            of point pairs using findFundamentalMat() .</param>
            <param name="imgSize">Size of the image.</param>
            <param name="H1">Output rectification homography matrix for the first image.</param>
            <param name="H2">Output rectification homography matrix for the second image.</param>
            <param name="threshold">Optional threshold used to filter out the outliers. 
            If the parameter is greater than zero, all the point pairs that do not comply 
            with the epipolar geometry (that is, the points for which |points2[i]^T * F * points1[i]| > threshold ) 
            are rejected prior to computing the homographies. Otherwise, all the points are considered inliers.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.StereoRectifyUncalibrated(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},System.Double[0:,0:],OpenCv30Sharp.Size,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double)">
            <summary>
            computes the rectification transformation for an uncalibrated stereo camera (zero distortion is assumed)
            </summary>
            <param name="points1">Array of feature points in the first image.</param>
            <param name="points2">The corresponding points in the second image. 
            The same formats as in findFundamentalMat() are supported.</param>
            <param name="F">Input fundamental matrix. It can be computed from the same set 
            of point pairs using findFundamentalMat() .</param>
            <param name="imgSize">Size of the image.</param>
            <param name="H1">Output rectification homography matrix for the first image.</param>
            <param name="H2">Output rectification homography matrix for the second image.</param>
            <param name="threshold">Optional threshold used to filter out the outliers. 
            If the parameter is greater than zero, all the point pairs that do not comply 
            with the epipolar geometry (that is, the points for which |points2[i]^T * F * points1[i]| > threshold ) 
            are rejected prior to computing the homographies. Otherwise, all the points are considered inliers.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rectify3Collinear(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,System.Collections.Generic.IEnumerable{OpenCv30Sharp.InputArray},System.Collections.Generic.IEnumerable{OpenCv30Sharp.InputArray},OpenCv30Sharp.Size,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Double,OpenCv30Sharp.Size,OpenCv30Sharp.Rect@,OpenCv30Sharp.Rect@,OpenCv30Sharp.StereoRectificationFlags)">
            <summary>
            computes the rectification transformations for 3-head camera, where all the heads are on the same line.
            </summary>
            <param name="cameraMatrix1"></param>
            <param name="distCoeffs1"></param>
            <param name="cameraMatrix2"></param>
            <param name="distCoeffs2"></param>
            <param name="cameraMatrix3"></param>
            <param name="distCoeffs3"></param>
            <param name="imgpt1"></param>
            <param name="imgpt3"></param>
            <param name="imageSize"></param>
            <param name="R12"></param>
            <param name="T12"></param>
            <param name="R13"></param>
            <param name="T13"></param>
            <param name="R1"></param>
            <param name="R2"></param>
            <param name="R3"></param>
            <param name="P1"></param>
            <param name="P2"></param>
            <param name="P3"></param>
            <param name="Q"></param>
            <param name="alpha"></param>
            <param name="newImgSize"></param>
            <param name="roi1"></param>
            <param name="roi2"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetOptimalNewCameraMatrix(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,System.Double,OpenCv30Sharp.Size,OpenCv30Sharp.Rect@,System.Boolean)">
            <summary>
            Returns the new camera matrix based on the free scaling parameter.
            </summary>
            <param name="cameraMatrix">Input camera matrix.</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the array is null, the zero distortion coefficients are assumed.</param>
            <param name="imageSize">Original image size.</param>
            <param name="alpha">Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) 
            and 1 (when all the source image pixels are retained in the undistorted image). </param>
            <param name="newImgSize">Image size after rectification. By default,it is set to imageSize .</param>
            <param name="validPixROI">Optional output rectangle that outlines all-good-pixels region in the undistorted image. See roi1, roi2 description in stereoRectify() .</param>
            <param name="centerPrincipalPoint">Optional flag that indicates whether in the new camera matrix the principal point 
            should be at the image center or not. By default, the principal point is chosen to best fit a 
            subset of the source image (determined by alpha) to the corrected image.</param>
            <returns>optimal new camera matrix</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetOptimalNewCameraMatrix(System.Double[0:,0:],System.Double[],OpenCv30Sharp.Size,System.Double,OpenCv30Sharp.Size,OpenCv30Sharp.Rect@,System.Boolean)">
            <summary>
            Returns the new camera matrix based on the free scaling parameter.
            </summary>
            <param name="cameraMatrix">Input camera matrix.</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the array is null, the zero distortion coefficients are assumed.</param>
            <param name="imageSize">Original image size.</param>
            <param name="alpha">Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) 
            and 1 (when all the source image pixels are retained in the undistorted image). </param>
            <param name="newImgSize">Image size after rectification. By default,it is set to imageSize .</param>
            <param name="validPixROI">Optional output rectangle that outlines all-good-pixels region in the undistorted image. See roi1, roi2 description in stereoRectify() .</param>
            <param name="centerPrincipalPoint">Optional flag that indicates whether in the new camera matrix the principal point 
            should be at the image center or not. By default, the principal point is chosen to best fit a 
            subset of the source image (determined by alpha) to the corrected image.</param>
            <returns>optimal new camera matrix</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertPointsToHomogeneous(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            converts point coordinates from normal pixel coordinates to homogeneous coordinates ((x,y)->(x,y,1))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N+1-dimensional points.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertPointsToHomogeneous(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec2f})">
            <summary>
            converts point coordinates from normal pixel coordinates to homogeneous coordinates ((x,y)->(x,y,1))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <returns>Output vector of N+1-dimensional points.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertPointsToHomogeneous(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec3f})">
            <summary>
            converts point coordinates from normal pixel coordinates to homogeneous coordinates ((x,y)->(x,y,1))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <returns>Output vector of N+1-dimensional points.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertPointsFromHomogeneous(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            converts point coordinates from homogeneous to normal pixel coordinates ((x,y,z)->(x/z, y/z))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N-1-dimensional points.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertPointsFromHomogeneous(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec3f})">
            <summary>
            converts point coordinates from homogeneous to normal pixel coordinates ((x,y,z)->(x/z, y/z))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <returns>Output vector of N-1-dimensional points.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertPointsFromHomogeneous(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec4f})">
            <summary>
            converts point coordinates from homogeneous to normal pixel coordinates ((x,y,z)->(x/z, y/z))
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <returns>Output vector of N-1-dimensional points.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertPointsHomogeneous(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Converts points to/from homogeneous coordinates.
            </summary>
            <param name="src">Input array or vector of 2D, 3D, or 4D points.</param>
            <param name="dst">Output vector of 2D, 3D, or 4D points.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindFundamentalMat(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.FundamentalMatMethod,System.Double,System.Double,OpenCv30Sharp.OutputArray)">
            <summary>
            Calculates a fundamental matrix from the corresponding points in two images.
            </summary>
            <param name="points1">Array of N points from the first image. 
            The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1 .</param>
            <param name="method">Method for computing a fundamental matrix.</param>
            <param name="param1">Parameter used for RANSAC. 
            It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is 
            considered an outlier and is not used for computing the final fundamental matrix. It can be set to 
            something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="param2">Parameter used for the RANSAC or LMedS methods only. 
            It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="mask">Output array of N elements, every element of which is set to 0 for outliers and 
            to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. For other methods, it is set to all 1’s.</param>
            <returns>fundamental matrix</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindFundamentalMat(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},OpenCv30Sharp.FundamentalMatMethod,System.Double,System.Double,OpenCv30Sharp.OutputArray)">
            <summary>
            Calculates a fundamental matrix from the corresponding points in two images.
            </summary>
            <param name="points1">Array of N points from the first image. 
            The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1 .</param>
            <param name="method">Method for computing a fundamental matrix.</param>
            <param name="param1">Parameter used for RANSAC. 
            It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is 
            considered an outlier and is not used for computing the final fundamental matrix. It can be set to 
            something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="param2">Parameter used for the RANSAC or LMedS methods only. 
            It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="mask">Output array of N elements, every element of which is set to 0 for outliers and 
            to 1 for the other points. The array is computed only in the RANSAC and LMedS methods. For other methods, it is set to all 1’s.</param>
            <returns>fundamental matrix</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ComputeCorrespondEpilines(OpenCv30Sharp.InputArray,System.Int32,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            For points in an image of a stereo pair, computes the corresponding epilines in the other image.
            </summary>
            <param name="points">Input points. N \times 1 or 1 x N matrix of type CV_32FC2 or CV_64FC2.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points .</param>
            <param name="F">Fundamental matrix that can be estimated using findFundamentalMat() or stereoRectify() .</param>
            <param name="lines">Output vector of the epipolar lines corresponding to the points in the other image.
             Each line ax + by + c=0 is encoded by 3 numbers (a, b, c) .</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ComputeCorrespondEpilines(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},System.Int32,System.Double[0:,0:])">
            <summary>
            For points in an image of a stereo pair, computes the corresponding epilines in the other image.
            </summary>
            <param name="points">Input points. N \times 1 or 1 x N matrix of type CV_32FC2 or CV_64FC2.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points .</param>
            <param name="F">Fundamental matrix that can be estimated using findFundamentalMat() or stereoRectify() .</param>
            <returns>Output vector of the epipolar lines corresponding to the points in the other image.
             Each line ax + by + c=0 is encoded by 3 numbers (a, b, c) .</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ComputeCorrespondEpilines(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3d},System.Int32,System.Double[0:,0:])">
            <summary>
            For points in an image of a stereo pair, computes the corresponding epilines in the other image.
            </summary>
            <param name="points">Input points. N \times 1 or 1 x N matrix of type CV_32FC2 or CV_64FC2.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points .</param>
            <param name="F">Fundamental matrix that can be estimated using findFundamentalMat() or stereoRectify() .</param>
            <returns>Output vector of the epipolar lines corresponding to the points in the other image.
             Each line ax + by + c=0 is encoded by 3 numbers (a, b, c) .</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.TriangulatePoints(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Reconstructs points by triangulation.
            </summary>
            <param name="projMatr1">3x4 projection matrix of the first camera.</param>
            <param name="projMatr2">3x4 projection matrix of the second camera.</param>
            <param name="projPoints1">2xN array of feature points in the first image. In case of c++ version 
            it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <param name="projPoints2">2xN array of corresponding points in the second image. In case of c++ version 
            it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <param name="points4D">4xN array of reconstructed points in homogeneous coordinates.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.TriangulatePoints(System.Double[0:,0:],System.Double[0:,0:],System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d})">
            <summary>
            Reconstructs points by triangulation.
            </summary>
            <param name="projMatr1">3x4 projection matrix of the first camera.</param>
            <param name="projMatr2">3x4 projection matrix of the second camera.</param>
            <param name="projPoints1">2xN array of feature points in the first image. In case of c++ version 
            it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <param name="projPoints2">2xN array of corresponding points in the second image. In case of c++ version 
            it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <returns>4xN array of reconstructed points in homogeneous coordinates.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CorrectMatches(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Refines coordinates of corresponding points.
            </summary>
            <param name="F">3x3 fundamental matrix.</param>
            <param name="points1">1xN array containing the first set of points.</param>
            <param name="points2">1xN array containing the second set of points.</param>
            <param name="newPoints1">The optimized points1.</param>
            <param name="newPoints2">The optimized points2.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CorrectMatches(System.Double[0:,0:],System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},OpenCv30Sharp.Point2d[]@,OpenCv30Sharp.Point2d[]@)">
            <summary>
            Refines coordinates of corresponding points.
            </summary>
            <param name="F">3x3 fundamental matrix.</param>
            <param name="points1">1xN array containing the first set of points.</param>
            <param name="points2">1xN array containing the second set of points.</param>
            <param name="newPoints1">The optimized points1.</param>
            <param name="newPoints2">The optimized points2.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FilterSpeckles(OpenCv30Sharp.InputOutputArray,System.Double,System.Int32,System.Double,OpenCv30Sharp.InputOutputArray)">
            <summary>
            filters off speckles (small regions of incorrectly computed disparity)
            </summary>
            <param name="img">The input 16-bit signed disparity image</param>
            <param name="newVal">The disparity value used to paint-off the speckles</param>
            <param name="maxSpeckleSize">The maximum speckle size to consider it a speckle. Larger blobs are not affected by the algorithm</param>
            <param name="maxDiff">Maximum difference between neighbor disparity pixels to put them into the same blob. 
            Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point disparity map, where disparity values 
            are multiplied by 16, this scale factor should be taken into account when specifying this parameter value.</param>
            <param name="buf">The optional temporary buffer to avoid memory allocation within the function.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetValidDisparityROI(OpenCv30Sharp.Rect,OpenCv30Sharp.Rect,System.Int32,System.Int32,System.Int32)">
            <summary>
            computes valid disparity ROI from the valid ROIs of the rectified images (that are returned by cv::stereoRectify())
            </summary>
            <param name="roi1"></param>
            <param name="roi2"></param>
            <param name="minDisparity"></param>
            <param name="numberOfDisparities"></param>
            <param name="SADWindowSize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ValidateDisparity(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            validates disparity using the left-right check. The matrix "cost" should be computed by the stereo correspondence algorithm
            </summary>
            <param name="disparity"></param>
            <param name="cost"></param>
            <param name="minDisparity"></param>
            <param name="numberOfDisparities"></param>
            <param name="disp12MaxDisp"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ReprojectImageTo3D(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,System.Boolean,System.Int32)">
            <summary>
            reprojects disparity image to 3D: (x,y,d)->(X,Y,Z) using the matrix Q returned by cv::stereoRectify
            </summary>
            <param name="disparity">Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit floating-point disparity image.</param>
            <param name="_3dImage">Output 3-channel floating-point image of the same size as disparity. 
            Each element of _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity map.</param>
            <param name="Q">4 x 4 perspective transformation matrix that can be obtained with stereoRectify().</param>
            <param name="handleMissingValues">Indicates, whether the function should handle missing values (i.e. points where the disparity was not computed). 
            If handleMissingValues=true, then pixels with the minimal disparity that corresponds to the outliers (see StereoBM::operator() ) are 
            transformed to 3D points with a very large Z value (currently set to 10000).</param>
            <param name="ddepth">he optional output array depth. If it is -1, the output image will have CV_32F depth. 
            ddepth can also be set to CV_16S, CV_32S or CV_32F.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.EstimateAffine3D(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Double,System.Double)">
            <summary>
            Computes an optimal affine transformation between two 3D point sets.
            </summary>
            <param name="src">First input 3D point set.</param>
            <param name="dst">Second input 3D point set.</param>
            <param name="outVal">Output 3D affine transformation matrix 3 x 4 .</param>
            <param name="inliers">Output vector indicating which points are inliers.</param>
            <param name="ransacThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. 
            Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. 
            Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.NamedWindow(System.String)">
            <summary>
            Creates a window.
            </summary>
            <param name="winname">Name of the window in the window caption that may be used as a window identifier.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.NamedWindow(System.String,OpenCv30Sharp.WindowMode)">
            <summary>
            Creates a window.
            </summary>
            <param name="winname">Name of the window in the window caption that may be used as a window identifier.</param>
            <param name="flags">
            Flags of the window. Currently the only supported flag is CV WINDOW AUTOSIZE. If this is set, 
            the window size is automatically adjusted to fit the displayed image (see imshow ), and the user can not change the window size manually.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DestroyWindow(System.String)">
            <summary>
            
            </summary>
            <param name="winName"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DestroyAllWindows">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ImShow(System.String,OpenCv30Sharp.Mat)">
            <summary>
            Displays the image in the specified window
            </summary>
            <param name="winname">Name of the window.</param>
            <param name="mat">Image to be shown.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.StartWindowThread">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.WaitKey(System.Int32)">
            <summary>
            Waits for a pressed key.
            </summary>
            <param name="delay">Delay in milliseconds. 0 is the special value that means ”forever”</param>
            <returns>Returns the code of the pressed key or -1 if no key was pressed before the specified time had elapsed.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ResizeWindow(System.String,System.Int32,System.Int32)">
            <summary>
            Resizes window to the specified size
            </summary>
            <param name="winName">Window name</param>
            <param name="width">The new window width</param>
            <param name="height">The new window height</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MoveWindow(System.String,System.Int32,System.Int32)">
            <summary>
            Moves window to the specified position
            </summary>
            <param name="winName">Window name</param>
            <param name="x">The new x-coordinate of the window</param>
            <param name="y">The new y-coordinate of the window</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SetWindowProperty(System.String,OpenCv30Sharp.WindowProperty,System.Double)">
            <summary>
            Changes parameters of a window dynamically.
            </summary>
            <param name="winName">Name of the window.</param>
            <param name="propId">Window property to retrieve.</param>
            <param name="propValue">New value of the window property.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SetWindowTitle(System.String,System.String)">
            <summary>
            Updates window title
            </summary>
            <param name="winname"></param>
            <param name="title"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetWindowProperty(System.String,OpenCv30Sharp.WindowProperty)">
            <summary>
            Provides parameters of a window.
            </summary>
            <param name="winName">Name of the window.</param>
            <param name="propId">Window property to retrieve.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SetMouseCallback(System.String,OpenCv30Sharp.CvMouseCallback)">
            <summary>
            Sets the callback function for mouse events occuting within the specified window.
            </summary>
            <param name="windowName">Name of the window. </param>
            <param name="onMouse">Reference to the function to be called every time mouse event occurs in the specified window. </param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SetNumThreads(System.Int32)">
            <summary>
            
            </summary>
            <param name="nthreads"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetNumThreads">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetThreadNum">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetBuildInformation">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetTickCount">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetTickFrequency">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetCpuTickCount">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CheckHardwareSupport(OpenCv30Sharp.CpuFeatures)">
            <summary>
            
            </summary>
            <param name="feature"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetNumberOfCpus">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FastMalloc(System.Int64)">
            <summary>
            
            </summary>
            <param name="bufSize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FastFree(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SetUseOptimized(System.Boolean)">
            <summary>
            Turns on/off available optimization.
            The function turns on or off the optimized code in OpenCV. Some optimization can not be enabled
            or disabled, but, for example, most of SSE code in OpenCV can be temporarily turned on or off this way.
            </summary>
            <param name="onoff"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.UseOptimized">
            <summary>
            Returns the current optimization status.
            The function returns the current optimization status, which is controlled by cv::setUseOptimized().
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.AlignSize(System.Int32,System.Int32)">
            <summary>
            Aligns buffer size by the certain number of bytes
            This small inline function aligns a buffer size by 
            the certian number of bytes by enlarging it.
            </summary>
            <param name="sz"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Abs(OpenCv30Sharp.Mat)">
            <summary>
            Computes absolute value of each matrix element
            </summary>
            <param name="src">matrix</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Abs(OpenCv30Sharp.MatExpr)">
            <summary>
            Computes absolute value of each matrix element
            </summary>
            <param name="src">matrix expression</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Add(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,System.Int32)">
            <summary>
            Computes the per-element sum of two arrays or an array and a scalar.
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. It must have the same size and same type as src1</param>
            <param name="dst">The destination array; it will have the same size and same type as src1</param>
            <param name="mask">The optional operation mask, 8-bit single channel array; specifies elements of the destination array to be changed. [By default this is null]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Subtract(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,System.Int32)">
            <summary>
            Calculates per-element difference between two arrays or array and a scalar
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. It must have the same size and same type as src1</param>
            <param name="dst">The destination array; it will have the same size and same type as src1</param>
            <param name="mask">The optional operation mask, 8-bit single channel array; specifies elements of the destination array to be changed. [By default this is null]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Multiply(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double,System.Int32)">
            <summary>
            Calculates the per-element scaled product of two arrays
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array of the same size and the same type as src1</param>
            <param name="dst">The destination array; will have the same size and the same type as src1</param>
            <param name="scale">The optional scale factor. [By default this is 1]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Divide(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double,System.Int32)">
            <summary>
            Performs per-element division of two arrays or a scalar by an array.
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array; should have the same size and same type as src1</param>
            <param name="dst">The destination array; will have the same size and same type as src2</param>
            <param name="scale">Scale factor [By default this is 1]</param>
            <param name="dtype"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Divide(System.Double,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            Performs per-element division of two arrays or a scalar by an array.
            </summary>
            <param name="scale">Scale factor</param>
            <param name="src2">The first source array</param>
            <param name="dst">The destination array; will have the same size and same type as src2</param>
            <param name="dtype"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ScaleAdd(OpenCv30Sharp.InputArray,System.Double,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            adds scaled array to another one (dst = alpha*src1 + src2)
            </summary>
            <param name="src1"></param>
            <param name="alpha"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.AddWeighted(OpenCv30Sharp.InputArray,System.Double,OpenCv30Sharp.InputArray,System.Double,System.Double,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            computes weighted sum of two arrays (dst = alpha*src1 + beta*src2 + gamma)
            </summary>
            <param name="src1"></param>
            <param name="alpha"></param>
            <param name="src2"></param>
            <param name="beta"></param>
            <param name="gamma"></param>
            <param name="dst"></param>
            <param name="dtype"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertScaleAbs(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double,System.Double)">
            <summary>
            Scales, computes absolute values and converts the result to 8-bit.
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array</param>
            <param name="alpha">The optional scale factor. [By default this is 1]</param>
            <param name="beta">The optional delta added to the scaled values. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.LUT(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            transforms array of numbers using a lookup table: dst(i)=lut(src(i))
            </summary>
            <param name="src">Source array of 8-bit elements</param>
            <param name="lut">Look-up table of 256 elements. 
            In the case of multi-channel source array, the table should either have 
            a single channel (in this case the same table is used for all channels)
             or the same number of channels as in the source array</param>
            <param name="dst">Destination array; 
            will have the same size and the same number of channels as src, 
            and the same depth as lut</param>
            <param name="interpolation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.LUT(OpenCv30Sharp.InputArray,System.Byte[],OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            transforms array of numbers using a lookup table: dst(i)=lut(src(i))
            </summary>
            <param name="src">Source array of 8-bit elements</param>
            <param name="lut">Look-up table of 256 elements. 
            In the case of multi-channel source array, the table should either have 
            a single channel (in this case the same table is used for all channels) 
            or the same number of channels as in the source array</param>
            <param name="dst">Destination array; 
            will have the same size and the same number of channels as src, 
            and the same depth as lut</param>
            <param name="interpolation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Sum(OpenCv30Sharp.InputArray)">
            <summary>
            computes sum of array elements
            </summary>
            <param name="src">The source array; must have 1 to 4 channels</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CountNonZero(OpenCv30Sharp.InputArray)">
            <summary>
            computes the number of nonzero array elements
            </summary>
            <param name="mtx">Single-channel array</param>
            <returns>number of non-zero elements in mtx</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindNonZero(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            returns the list of locations of non-zero pixels
            </summary>
            <param name="src"></param>
            <param name="idx"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Mean(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            computes mean value of selected array elements
            </summary>
            <param name="src">The source array; it should have 1 to 4 channels
             (so that the result can be stored in Scalar)</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MeanStdDev(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            computes mean value and standard deviation of all or selected array elements
            </summary>
            <param name="src">The source array; it should have 1 to 4 channels 
            (so that the results can be stored in Scalar's)</param>
            <param name="mean">The output parameter: computed mean value</param>
            <param name="stddev">The output parameter: computed standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MeanStdDev(OpenCv30Sharp.InputArray,OpenCv30Sharp.Scalar@,OpenCv30Sharp.Scalar@,OpenCv30Sharp.InputArray)">
            <summary>
            computes mean value and standard deviation of all or selected array elements
            </summary>
            <param name="src">The source array; it should have 1 to 4 channels 
            (so that the results can be stored in Scalar's)</param>
            <param name="mean">The output parameter: computed mean value</param>
            <param name="stddev">The output parameter: computed standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Norm(OpenCv30Sharp.InputArray,OpenCv30Sharp.NormTypes,OpenCv30Sharp.InputArray)">
            <summary>
            Calculates absolute array norm, absolute difference norm, or relative difference norm.
            </summary>
            <param name="src1">The first source array</param>
            <param name="normType">Type of the norm</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Norm(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.NormTypes,OpenCv30Sharp.InputArray)">
            <summary>
            computes norm of selected part of the difference between two arrays
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array of the same size and the same type as src1</param>
            <param name="normType">Type of the norm</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BatchDistance(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32,OpenCv30Sharp.OutputArray,OpenCv30Sharp.NormTypes,System.Int32,OpenCv30Sharp.InputArray,System.Int32,System.Boolean)">
            <summary>
            naive nearest neighbor finder
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dist"></param>
            <param name="dtype"></param>
            <param name="nidx"></param>
            <param name="normType"></param>
            <param name="k"></param>
            <param name="mask"></param>
            <param name="update"></param>
            <param name="crosscheck"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Normalize(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,System.Double,System.Double,OpenCv30Sharp.NormTypes,System.Int32,OpenCv30Sharp.InputArray)">
            <summary>
            scales and shifts array elements so that either the specified norm (alpha) 
            or the minimum (alpha) and maximum (beta) array values get the specified values
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array; will have the same size as src</param>
            <param name="alpha">The norm value to normalize to or the lower range boundary 
            in the case of range normalization</param>
            <param name="beta">The upper range boundary in the case of range normalization; 
            not used for norm normalization</param>
            <param name="normType">The normalization type</param>
            <param name="dtype">When the parameter is negative, 
            the destination array will have the same type as src, 
            otherwise it will have the same number of channels as src and the depth =CV_MAT_DEPTH(rtype)</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinMaxLoc(OpenCv30Sharp.InputArray,System.Double@,System.Double@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinMaxLoc(OpenCv30Sharp.InputArray,OpenCv30Sharp.Point@,OpenCv30Sharp.Point@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinMaxLoc(OpenCv30Sharp.InputArray,System.Double@,System.Double@,OpenCv30Sharp.Point@,OpenCv30Sharp.Point@,OpenCv30Sharp.InputArray)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask used to select a sub-array</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinMaxIdx(OpenCv30Sharp.InputArray,System.Double@,System.Double@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinMaxIdx(OpenCv30Sharp.InputArray,System.Int32@,System.Int32@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minIdx"></param>
            <param name="maxIdx"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinMaxIdx(OpenCv30Sharp.InputArray,System.Double@,System.Double@,System.Int32@,System.Int32@,OpenCv30Sharp.InputArray)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minIdx"></param>
            <param name="maxIdx"></param>
            <param name="mask"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Reduce(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.ReduceDimension,OpenCv30Sharp.ReduceTypes,System.Int32)">
            <summary>
            transforms 2D matrix to 1D row or column vector by taking sum, minimum, maximum or mean value over all the rows
            </summary>
            <param name="src">The source 2D matrix</param>
            <param name="dst">The destination vector. 
            Its size and type is defined by dim and dtype parameters</param>
            <param name="dim">The dimension index along which the matrix is reduced. 
            0 means that the matrix is reduced to a single row and 1 means that the matrix is reduced to a single column</param>
            <param name="rtype"></param>
            <param name="dtype">When it is negative, the destination vector will have 
            the same type as the source matrix, otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), mtx.channels())</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Merge(OpenCv30Sharp.Mat[],OpenCv30Sharp.Mat)">
            <summary>
            makes multi-channel array out of several single-channel arrays
            </summary>
            <param name="mv"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Split(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat[]@)">
            <summary>
            Copies each plane of a multi-channel array to a dedicated array
            </summary>
            <param name="src">The source multi-channel array</param>
            <param name="mv">The destination array or vector of arrays; 
            The number of arrays must match mtx.channels() . 
            The arrays themselves will be reallocated if needed</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Split(OpenCv30Sharp.Mat)">
            <summary>
            Copies each plane of a multi-channel array to a dedicated array
            </summary>
            <param name="src">The source multi-channel array</param>
            <returns>The number of arrays must match mtx.channels() . 
            The arrays themselves will be reallocated if needed</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MixChannels(OpenCv30Sharp.Mat[],OpenCv30Sharp.Mat[],System.Int32[])">
            <summary>
            copies selected channels from the input arrays to the selected channels of the output arrays
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="fromTo"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ExtractChannel(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            extracts a single channel from src (coi is 0-based index)
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="coi"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.InsertChannel(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,System.Int32)">
            <summary>
            inserts a single channel to dst (coi is 0-based index)
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="coi"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Flip(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.FlipMode)">
            <summary>
            reverses the order of the rows, columns or both in a matrix
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
            <param name="flipCode">Specifies how to flip the array: 
            0 means flipping around the x-axis, positive (e.g., 1) means flipping around y-axis, 
            and negative (e.g., -1) means flipping around both axes. See also the discussion below for the formulas.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Repeat(OpenCv30Sharp.InputArray,System.Int32,System.Int32,OpenCv30Sharp.OutputArray)">
            <summary>
            replicates the input matrix the specified number of times in the horizontal and/or vertical direction
            </summary>
            <param name="src">The source array to replicate</param>
            <param name="ny">How many times the src is repeated along the vertical axis</param>
            <param name="nx">How many times the src is repeated along the horizontal axis</param>
            <param name="dst">The destination array; will have the same type as src</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Repeat(OpenCv30Sharp.Mat,System.Int32,System.Int32)">
            <summary>
            replicates the input matrix the specified number of times in the horizontal and/or vertical direction
            </summary>
            <param name="src">The source array to replicate</param>
            <param name="ny">How many times the src is repeated along the vertical axis</param>
            <param name="nx">How many times the src is repeated along the horizontal axis</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.HConcat(OpenCv30Sharp.Mat[],OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.HConcat(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.VConcat(OpenCv30Sharp.Mat[],OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.VConcat(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BitwiseAnd(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            computes bitwise conjunction of the two arrays (dst = src1 &amp; src2)
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
            <param name="mask"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BitwiseOr(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            computes bitwise disjunction of the two arrays (dst = src1 | src2)
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
            <param name="mask"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BitwiseXor(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            computes bitwise exclusive-or of the two arrays (dst = src1 ^ src2)
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
            <param name="mask"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BitwiseNot(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            inverts each bit of array (dst = ~src)
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="mask"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Absdiff(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            computes element-wise absolute difference of two arrays (dst = abs(src1 - src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.InRange(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            set mask elements for those array elements which are within the element-specific bounding box (dst = lowerb &lt;= src &amp;&amp; src &lt; upperb)
            </summary>
            <param name="src">The first source array</param>
            <param name="lowerb">The inclusive lower boundary array of the same size and type as src</param>
            <param name="upperb">The exclusive upper boundary array of the same size and type as src</param>
            <param name="dst">The destination array, will have the same size as src and CV_8U type</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.InRange(OpenCv30Sharp.InputArray,OpenCv30Sharp.Scalar,OpenCv30Sharp.Scalar,OpenCv30Sharp.OutputArray)">
            <summary>
            set mask elements for those array elements which are within the element-specific bounding box (dst = lowerb &lt;= src &amp;&amp; src &lt; upperb)
            </summary>
            <param name="src">The first source array</param>
            <param name="lowerb">The inclusive lower boundary array of the same size and type as src</param>
            <param name="upperb">The exclusive upper boundary array of the same size and type as src</param>
            <param name="dst">The destination array, will have the same size as src and CV_8U type</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Compare(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.CmpTypes)">
            <summary>
            Performs the per-element comparison of two arrays or an array and scalar value.
            </summary>
            <param name="src1">first input array or a scalar; when it is an array, it must have a single channel.</param>
            <param name="src2">second input array or a scalar; when it is an array, it must have a single channel.</param>
            <param name="dst">output array of type ref CV_8U that has the same size and the same number of channels as the input arrays.</param>
            <param name="cmpop">a flag, that specifies correspondence between the arrays (cv::CmpTypes)</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Min(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            computes per-element minimum of two arrays (dst = min(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Min(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            computes per-element minimum of two arrays (dst = min(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Min(OpenCv30Sharp.Mat,System.Double,OpenCv30Sharp.Mat)">
            <summary>
            computes per-element minimum of array and scalar (dst = min(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Max(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            computes per-element maximum of two arrays (dst = max(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Max(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            computes per-element maximum of two arrays (dst = max(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Max(OpenCv30Sharp.Mat,System.Double,OpenCv30Sharp.Mat)">
            <summary>
            computes per-element maximum of array and scalar (dst = max(src1, src2))
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Sqrt(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            computes square root of each matrix element (dst = src**0.5)
            </summary>
            <param name="src">The source floating-point array</param>
            <param name="dst">The destination array; will have the same size and the same type as src</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Pow(OpenCv30Sharp.InputArray,System.Double,OpenCv30Sharp.OutputArray)">
            <summary>
            raises the input matrix elements to the specified power (b = a**power)
            </summary>
            <param name="src">The source array</param>
            <param name="power">The exponent of power</param>
            <param name="dst">The destination array; will have the same size and the same type as src</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Exp(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            computes exponent of each matrix element (dst = e**src)
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Log(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            computes natural logarithm of absolute value of each matrix element: dst = log(abs(src))
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CubeRoot(System.Single)">
            <summary>
            computes cube root of the argument
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FastAtan2(System.Single,System.Single)">
            <summary>
            computes the angle in degrees (0..360) of the vector (x,y)
            </summary>
            <param name="y"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PolarToCart(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Boolean)">
            <summary>
            converts polar coordinates to Cartesian
            </summary>
            <param name="magnitude"></param>
            <param name="angle"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="angleInDegrees"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CartToPolar(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Boolean)">
            <summary>
            converts Cartesian coordinates to polar
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="magnitude"></param>
            <param name="angle"></param>
            <param name="angleInDegrees"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Phase(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Boolean)">
            <summary>
            computes angle (angle(i)) of each (x(i), y(i)) vector
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="angle"></param>
            <param name="angleInDegrees"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Magnitude(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            computes magnitude (magnitude(i)) of each (x(i), y(i)) vector
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="magnitude"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CheckRange(OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            checks that each matrix element is within the specified range.
            </summary>
            <param name="src">The array to check</param>
            <param name="quiet">The flag indicating whether the functions quietly 
            return false when the array elements are out of range, 
            or they throw an exception.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CheckRange(OpenCv30Sharp.InputArray,System.Boolean,OpenCv30Sharp.Point@,System.Double,System.Double)">
            <summary>
            checks that each matrix element is within the specified range.
            </summary>
            <param name="src">The array to check</param>
            <param name="quiet">The flag indicating whether the functions quietly 
            return false when the array elements are out of range, 
            or they throw an exception.</param>
            <param name="pos">The optional output parameter, where the position of 
            the first outlier is stored.</param>
            <param name="minVal">The inclusive lower boundary of valid values range</param>
            <param name="maxVal">The exclusive upper boundary of valid values range</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PatchNaNs(OpenCv30Sharp.InputOutputArray,System.Double)">
            <summary>
            converts NaN's to the given number
            </summary>
            <param name="a"></param>
            <param name="val"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Gemm(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,System.Double,OpenCv30Sharp.InputArray,System.Double,OpenCv30Sharp.OutputArray,OpenCv30Sharp.GemmFlags)">
            <summary>
            implements generalized matrix product algorithm GEMM from BLAS
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="alpha"></param>
            <param name="src3"></param>
            <param name="gamma"></param>
            <param name="dst"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MulTransposed(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Boolean,OpenCv30Sharp.InputArray,System.Double,System.Int32)">
            <summary>
            multiplies matrix by its transposition from the left or from the right
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination square matrix</param>
            <param name="aTa">Specifies the multiplication ordering; see the description below</param>
            <param name="delta">The optional delta matrix, subtracted from src before the 
            multiplication. When the matrix is empty ( delta=Mat() ), it’s assumed to be 
            zero, i.e. nothing is subtracted, otherwise if it has the same size as src, 
            then it’s simply subtracted, otherwise it is "repeated" to cover the full src 
            and then subtracted. Type of the delta matrix, when it's not empty, must be the 
            same as the type of created destination matrix, see the rtype description</param>
            <param name="scale">The optional scale factor for the matrix product</param>
            <param name="dtype">When it’s negative, the destination matrix will have the 
            same type as src . Otherwise, it will have type=CV_MAT_DEPTH(rtype), 
            which should be either CV_32F or CV_64F</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Transpose(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            transposes the matrix
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array of the same type as src</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Transform(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            performs affine transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source array; must have as many channels (1 to 4) as mtx.cols or mtx.cols-1</param>
            <param name="dst">The destination array; will have the same size and depth as src and as many channels as mtx.rows</param>
            <param name="m">The transformation matrix</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PerspectiveTransform(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="dst">The destination array; it will have the same size and same type as src</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PerspectiveTransform(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},OpenCv30Sharp.Mat)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PerspectiveTransform(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d},OpenCv30Sharp.Mat)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PerspectiveTransform(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f},OpenCv30Sharp.Mat)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PerspectiveTransform(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3d},OpenCv30Sharp.Mat)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="src">The source two-channel or three-channel floating-point array; 
            each element is 2D/3D vector to be transformed</param>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CompleteSymm(OpenCv30Sharp.InputOutputArray,System.Boolean)">
            <summary>
            extends the symmetrical matrix from the lower half or from the upper half
            </summary>
            <param name="mtx"> Input-output floating-point square matrix</param>
            <param name="lowerToUpper">If true, the lower half is copied to the upper half, 
            otherwise the upper half is copied to the lower half</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SetIdentity(OpenCv30Sharp.InputOutputArray,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            initializes scaled identity matrix
            </summary>
            <param name="mtx">The matrix to initialize (not necessarily square)</param>
            <param name="s">The value to assign to the diagonal elements</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Determinant(OpenCv30Sharp.InputArray)">
            <summary>
            computes determinant of a square matrix
            </summary>
            <param name="mtx">The input matrix; must have CV_32FC1 or CV_64FC1 type and square size</param>
            <returns>determinant of the specified matrix.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Trace(OpenCv30Sharp.InputArray)">
            <summary>
            computes trace of a matrix
            </summary>
            <param name="mtx">The source matrix</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Invert(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DecompTypes)">
            <summary>
            computes inverse or pseudo-inverse matrix
            </summary>
            <param name="src">The source floating-point MxN matrix</param>
            <param name="dst">The destination matrix; will have NxM size and the same type as src</param>
            <param name="flags">The inversion method</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Solve(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DecompTypes)">
            <summary>
            solves linear system or a least-square problem
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="dst"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Sort(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.SortFlags)">
            <summary>
            sorts independently each matrix row or each matrix column
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="dst">The destination array of the same size and the same type as src</param>
            <param name="flags">The operation flags, a combination of the SortFlag values</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SortIdx(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.SortFlags)">
            <summary>
            sorts independently each matrix row or each matrix column
            </summary>
            <param name="src">The source single-channel array</param>
            <param name="dst">The destination integer array of the same size as src</param>
            <param name="flags">The operation flags, a combination of SortFlag values</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SolveCubic(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            finds real roots of a cubic polynomial
            </summary>
            <param name="coeffs">The equation coefficients, an array of 3 or 4 elements</param>
            <param name="roots">The destination array of real roots which will have 1 or 3 elements</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SolvePoly(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            finds real and complex roots of a polynomial
            </summary>
            <param name="coeffs">The array of polynomial coefficients</param>
            <param name="roots">The destination (complex) array of roots</param>
            <param name="maxIters">The maximum number of iterations the algorithm does</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Eigen(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Computes eigenvalues and eigenvectors of a symmetric matrix.
            </summary>
            <param name="src">The input matrix; must have CV_32FC1 or CV_64FC1 type, 
            square size and be symmetric: src^T == src</param>
            <param name="eigenvalues">The output vector of eigenvalues of the same type as src; 
            The eigenvalues are stored in the descending order.</param>
            <param name="eigenvectors">The output matrix of eigenvectors; 
            It will have the same size and the same type as src; The eigenvectors are stored 
            as subsequent matrix rows, in the same order as the corresponding eigenvalues</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcCovarMatrix(OpenCv30Sharp.Mat[],OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.CovarFlags)">
            <summary>
            computes covariation matrix of a set of samples
            </summary>
            <param name="samples"></param>
            <param name="covar"></param>
            <param name="mean"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcCovarMatrix(OpenCv30Sharp.Mat[],OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.CovarFlags,OpenCv30Sharp.MatType)">
            <summary>
            computes covariation matrix of a set of samples
            </summary>
            <param name="samples"></param>
            <param name="covar"></param>
            <param name="mean"></param>
            <param name="flags"></param>
            <param name="ctype"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcCovarMatrix(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.CovarFlags)">
            <summary>
            computes covariation matrix of a set of samples
            </summary>
            <param name="samples"></param>
            <param name="covar"></param>
            <param name="mean"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcCovarMatrix(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.CovarFlags,OpenCv30Sharp.MatType)">
            <summary>
            computes covariation matrix of a set of samples
            </summary>
            <param name="samples"></param>
            <param name="covar"></param>
            <param name="mean"></param>
            <param name="flags"></param>
            <param name="ctype"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PCACompute(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            PCA of the supplied dataset. 
            </summary>
            <param name="data">input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">optional mean value; if the matrix is empty (noArray()), the mean is computed from the data.</param>
            <param name="eigenvectors"></param>
            <param name="maxComponents">maximum number of components that PCA should
            retain; by default, all the components are retained.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PCAComputeVar(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.OutputArray,System.Double)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="mean"></param>
            <param name="eigenvectors"></param>
            <param name="retainedVariance"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PCAProject(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="mean"></param>
            <param name="eigenvectors"></param>
            <param name="result"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PCABackProject(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="mean"></param>
            <param name="eigenvectors"></param>
            <param name="result"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SVDecomp(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.SVD.Flags)">
            <summary>
            computes SVD of src
            </summary>
            <param name="src"></param>
            <param name="w"></param>
            <param name="u"></param>
            <param name="vt"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SVBackSubst(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            performs back substitution for the previously computed SVD
            </summary>
            <param name="w"></param>
            <param name="u"></param>
            <param name="vt"></param>
            <param name="rhs"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Mahalanobis(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="icovar"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Mahalonobis(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            computes Mahalanobis distance between two vectors: sqrt((v1-v2)'*icovar*(v1-v2)), where icovar is the inverse covariation matrix
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="icovar"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Dft(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DftFlags,System.Int32)">
            <summary>
            Performs a forward Discrete Fourier transform of 1D or 2D floating-point array.
            </summary>
            <param name="src">The source array, real or complex</param>
            <param name="dst">The destination array, which size and type depends on the flags</param>
            <param name="flags">Transformation flags, a combination of the DftFlag2 values</param>
            <param name="nonzeroRows">When the parameter != 0, the function assumes that 
            only the first nonzeroRows rows of the input array ( DFT_INVERSE is not set) 
            or only the first nonzeroRows of the output array ( DFT_INVERSE is set) contain non-zeros, 
            thus the function can handle the rest of the rows more efficiently and 
            thus save some time. This technique is very useful for computing array cross-correlation 
            or convolution using DFT</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Idft(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DftFlags,System.Int32)">
            <summary>
            Performs an inverse Discrete Fourier transform of 1D or 2D floating-point array.
            </summary>
            <param name="src">The source array, real or complex</param>
            <param name="dst">The destination array, which size and type depends on the flags</param>
            <param name="flags">Transformation flags, a combination of the DftFlag2 values</param>
            <param name="nonzeroRows">When the parameter != 0, the function assumes that 
            only the first nonzeroRows rows of the input array ( DFT_INVERSE is not set) 
            or only the first nonzeroRows of the output array ( DFT_INVERSE is set) contain non-zeros, 
            thus the function can handle the rest of the rows more efficiently and 
            thus save some time. This technique is very useful for computing array cross-correlation 
            or convolution using DFT</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Dct(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DctFlags)">
            <summary>
            Performs forward or inverse 1D or 2D Discrete Cosine Transformation
            </summary>
            <param name="src">The source floating-point array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
            <param name="flags">Transformation flags, a combination of DctFlag2 values</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Idct(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DctFlags)">
            <summary>
            Performs inverse 1D or 2D Discrete Cosine Transformation
            </summary>
            <param name="src">The source floating-point array</param>
            <param name="dst">The destination array; will have the same size and same type as src</param>
            <param name="flags">Transformation flags, a combination of DctFlag2 values</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MulSpectrums(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DftFlags,System.Boolean)">
            <summary>
            computes element-wise product of the two Fourier spectrums. The second spectrum can optionally be conjugated before the multiplication
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="flags"></param>
            <param name="conjB"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetOptimalDFTSize(System.Int32)">
            <summary>
            computes the minimal vector size vecsize1 >= vecsize so that the dft() of the vector of length vecsize1 can be computed efficiently
            </summary>
            <param name="vecsize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Kmeans(OpenCv30Sharp.InputArray,System.Int32,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.TermCriteria,System.Int32,OpenCv30Sharp.KMeansFlags,OpenCv30Sharp.OutputArray)">
            <summary>
            clusters the input data using k-Means algorithm
            </summary>
            <param name="data"></param>
            <param name="k"></param>
            <param name="bestLabels"></param>
            <param name="criteria"></param>
            <param name="attempts"></param>
            <param name="flags"></param>
            <param name="centers"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.TheRNG">
            <summary>
            returns the thread-local Random number generator
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Randu(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            fills array with uniformly-distributed random numbers from the range [low, high)
            </summary>
            <param name="dst">The output array of random numbers. 
            The array must be pre-allocated and have 1 to 4 channels</param>
            <param name="low">The inclusive lower boundary of the generated random numbers</param>
            <param name="high">The exclusive upper boundary of the generated random numbers</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Randu(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Scalar,OpenCv30Sharp.Scalar)">
            <summary>
            fills array with uniformly-distributed random numbers from the range [low, high)
            </summary>
            <param name="dst">The output array of random numbers. 
            The array must be pre-allocated and have 1 to 4 channels</param>
            <param name="low">The inclusive lower boundary of the generated random numbers</param>
            <param name="high">The exclusive upper boundary of the generated random numbers</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Randn(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            fills array with normally-distributed random numbers with the specified mean and the standard deviation
            </summary>
            <param name="dst">The output array of random numbers. 
            The array must be pre-allocated and have 1 to 4 channels</param>
            <param name="mean">The mean value (expectation) of the generated random numbers</param>
            <param name="stddev">The standard deviation of the generated random numbers</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Randn(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Scalar,OpenCv30Sharp.Scalar)">
            <summary>
            fills array with normally-distributed random numbers with the specified mean and the standard deviation
            </summary>
            <param name="dst">The output array of random numbers. 
            The array must be pre-allocated and have 1 to 4 channels</param>
            <param name="mean">The mean value (expectation) of the generated random numbers</param>
            <param name="stddev">The standard deviation of the generated random numbers</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.RandShuffle(OpenCv30Sharp.InputOutputArray,System.Double,OpenCv30Sharp.RNG)">
            <summary>
            shuffles the input array elements
            </summary>
            <param name="dst">The input/output numerical 1D array</param>
            <param name="iterFactor">The scale factor that determines the number of random swap operations.</param>
            <param name="rng">The optional random number generator used for shuffling. 
            If it is null, theRng() is used instead.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Write(OpenCv30Sharp.FileStorage,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Write(OpenCv30Sharp.FileStorage,System.String,System.Single)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Write(OpenCv30Sharp.FileStorage,System.String,System.Double)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Write(OpenCv30Sharp.FileStorage,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Write(OpenCv30Sharp.FileStorage,System.String,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Write(OpenCv30Sharp.FileStorage,System.String,OpenCv30Sharp.SparseMat)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Write(OpenCv30Sharp.FileStorage,System.String,System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint})">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Write(OpenCv30Sharp.FileStorage,System.String,System.Collections.Generic.IEnumerable{OpenCv30Sharp.DMatch})">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.WriteScalar(OpenCv30Sharp.FileStorage,System.Int32)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.WriteScalar(OpenCv30Sharp.FileStorage,System.Single)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.WriteScalar(OpenCv30Sharp.FileStorage,System.Double)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.WriteScalar(OpenCv30Sharp.FileStorage,System.String)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ReadInt(OpenCv30Sharp.FileNode,System.Int32)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ReadFloat(OpenCv30Sharp.FileNode,System.Single)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ReadDouble(OpenCv30Sharp.FileNode,System.Double)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ReadString(OpenCv30Sharp.FileNode,System.String)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ReadMat(OpenCv30Sharp.FileNode,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="defaultMat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ReadSparseMat(OpenCv30Sharp.FileNode,OpenCv30Sharp.SparseMat)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="defaultMat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ReadKeyPoints(OpenCv30Sharp.FileNode)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ReadDMatches(OpenCv30Sharp.FileNode)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetGaussianKernel(System.Int32,System.Double,System.Nullable{OpenCv30Sharp.MatType})">
            <summary>
            Returns Gaussian filter coefficients.
            </summary>
            <param name="ksize">Aperture size. It should be odd and positive.</param>
            <param name="sigma">Gaussian standard deviation.
            If it is non-positive, it is computed from ksize as `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.</param>
            <param name="ktype">Type of filter coefficients. It can be CV_32F or CV_64F.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetDerivKernels(OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Int32,System.Int32,System.Int32,System.Boolean,System.Nullable{OpenCv30Sharp.MatType})">
            <summary>
            Returns filter coefficients for computing spatial image derivatives.
            </summary>
            <param name="kx">Output matrix of row filter coefficients. It has the type ktype.</param>
            <param name="ky">Output matrix of column filter coefficients. It has the type ktype.</param>
            <param name="dx">Derivative order in respect of x.</param>
            <param name="dy">Derivative order in respect of y.</param>
            <param name="ksize">Aperture size. It can be CV_SCHARR, 1, 3, 5, or 7.</param>
            <param name="normalize">Flag indicating whether to normalize (scale down) the filter coefficients or not.
            Theoretically, the coefficients should have the denominator \f$=2^{ksize*2-dx-dy-2}\f$. 
            If you are going to filter floating-point images, you are likely to use the normalized kernels.
            But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, 
            and wish to preserve all the fractional bits, you may want to set normalize = false.</param>
            <param name="ktype">Type of filter coefficients. It can be CV_32f or CV_64F.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetGaborKernel(OpenCv30Sharp.Size,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            
            </summary>
            <param name="ksize"></param>
            <param name="sigma"></param>
            <param name="theta"></param>
            <param name="lambd"></param>
            <param name="gamma"></param>
            <param name="psi"></param>
            <param name="ktype"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetStructuringElement(OpenCv30Sharp.MorphShapes,OpenCv30Sharp.Size)">
            <summary>
            
            </summary>
            <param name="shape"></param>
            <param name="ksize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetStructuringElement(OpenCv30Sharp.MorphShapes,OpenCv30Sharp.Size,OpenCv30Sharp.Point)">
            <summary>
            
            </summary>
            <param name="shape"></param>
            <param name="ksize"></param>
            <param name="anchor"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CopyMakeBorder(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32,System.Int32,System.Int32,System.Int32,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Forms a border around the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same type as src and 
            the size Size(src.cols+left+right, src.rows+top+bottom)</param>
            <param name="top">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="bottom">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="left">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="right">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="borderType">The border type</param>
            <param name="value">The border value if borderType == Constant</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MedianBlur(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            Smoothes image using median filter
            </summary>
            <param name="src">The source 1-, 3- or 4-channel image. 
            When ksize is 3 or 5, the image depth should be CV_8U , CV_16U or CV_32F. 
            For larger aperture sizes it can only be CV_8U</param>
            <param name="dst">The destination array; will have the same size and the same type as src</param>
            <param name="ksize">The aperture linear size. It must be odd and more than 1, i.e. 3, 5, 7 ...</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GaussianBlur(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.Size,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Blurs an image using a Gaussian filter.
            </summary>
            <param name="src">input image; the image can have any number of channels, which are processed independently, 
            but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</param>
            <param name="dst">output image of the same size and type as src.</param>
            <param name="ksize">Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. 
            Or, they can be zero’s and then they are computed from sigma* .</param>
            <param name="sigmaX">Gaussian kernel standard deviation in X direction.</param>
            <param name="sigmaY">Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, 
            if both sigmas are zeros, they are computed from ksize.width and ksize.height, 
            respectively (see getGaussianKernel() for details); to fully control the result 
            regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</param>
            <param name="borderType">pixel extrapolation method</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BilateralFilter(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Applies bilateral filter to the image
            </summary>
            <param name="src">The source 8-bit or floating-point, 1-channel or 3-channel image</param>
            <param name="dst">The destination image; will have the same size and the same type as src</param>
            <param name="d">The diameter of each pixel neighborhood, that is used during filtering. 
            If it is non-positive, it's computed from sigmaSpace</param>
            <param name="sigmaColor">Filter sigma in the color space. 
            Larger value of the parameter means that farther colors within the pixel neighborhood 
            will be mixed together, resulting in larger areas of semi-equal color</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. 
            Larger value of the parameter means that farther pixels will influence each other 
            (as long as their colors are close enough; see sigmaColor). Then d>0 , it specifies 
            the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace</param>
            <param name="borderType"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BoxFilter(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.MatType,OpenCv30Sharp.Size,System.Nullable{OpenCv30Sharp.Point},System.Boolean,OpenCv30Sharp.BorderTypes)">
            <summary>
            Smoothes image using box filter
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same type as src</param>
            <param name="ddepth"></param>
            <param name="ksize">The smoothing kernel size</param>
            <param name="anchor">The anchor point. The default value Point(-1,-1) means that the anchor is at the kernel center</param>
            <param name="normalize">Indicates, whether the kernel is normalized by its area or not</param>
            <param name="borderType">The border mode used to extrapolate pixels outside of the image</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Blur(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.Size,System.Nullable{OpenCv30Sharp.Point},OpenCv30Sharp.BorderTypes)">
            <summary>
            Smoothes image using normalized box filter
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same type as src</param>
            <param name="ksize">The smoothing kernel size</param>
            <param name="anchor">The anchor point. The default value Point(-1,-1) means that the anchor is at the kernel center</param>
            <param name="borderType">The border mode used to extrapolate pixels outside of the image</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Filter2D(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.MatType,OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Convolves an image with the kernel
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image. It will have the same size and the same number of channels as src</param>
            <param name="ddepth">The desired depth of the destination image. If it is negative, it will be the same as src.depth()</param>
            <param name="kernel">Convolution kernel (or rather a correlation kernel), 
            a single-channel floating point matrix. If you want to apply different kernels to 
            different channels, split the image into separate color planes using split() and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of 
            a filtered point within the kernel. The anchor should lie within the kernel. 
            The special default value (-1,-1) means that the anchor is at the kernel center</param>
            <param name="delta">The optional value added to the filtered pixels before storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.SepFilter2D(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.MatType,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Applies separable linear filter to an image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same number of channels as src</param>
            <param name="ddepth">The destination image depth</param>
            <param name="kernelX">The coefficients for filtering each row</param>
            <param name="kernelY">The coefficients for filtering each column</param>
            <param name="anchor">The anchor position within the kernel; The default value (-1, 1) means that the anchor is at the kernel center</param>
            <param name="delta">The value added to the filtered results before storing them</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Sobel(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.MatType,System.Int32,System.Int32,System.Int32,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Calculates the first, second, third or mixed image derivatives using an extended Sobel operator
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same number of channels as src</param>
            <param name="ddepth">The destination image depth</param>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="ksize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7</param>
            <param name="scale">The optional scale factor for the computed derivative values (by default, no scaling is applied</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Scharr(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.MatType,System.Int32,System.Int32,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Calculates the first x- or y- image derivative using Scharr operator
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; will have the same size and the same number of channels as src</param>
            <param name="ddepth">The destination image depth</param>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="scale">The optional scale factor for the computed derivative values (by default, no scaling is applie</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Laplacian(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.MatType,System.Int32,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Calculates the Laplacian of an image
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image; will have the same size and the same number of channels as src</param>
            <param name="ddepth">The desired depth of the destination image</param>
            <param name="ksize">The aperture size used to compute the second-derivative filters</param>
            <param name="scale">The optional scale factor for the computed Laplacian values (by default, no scaling is applied</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Canny(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Finds edges in an image using Canny algorithm.
            </summary>
            <param name="src">Single-channel 8-bit input image</param>
            <param name="edges">The output edge map. It will have the same size and the same type as image</param>
            <param name="threshold1">The first threshold for the hysteresis procedure</param>
            <param name="threshold2">The second threshold for the hysteresis procedure</param>
            <param name="apertureSize">Aperture size for the Sobel operator [By default this is ApertureSize.Size3]</param>
            <param name="L2gradient">Indicates, whether the more accurate L2 norm should be used to compute the image gradient magnitude (true), or a faster default L1 norm is enough (false). [By default this is false]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CornerEigenValsAndVecs(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32,System.Int32,OpenCv30Sharp.BorderTypes)">
            <summary>
            computes both eigenvalues and the eigenvectors of 2x2 derivative covariation matrix  at each pixel. The output is stored as 6-channel matrix.
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="blockSize"></param>
            <param name="ksize"></param>
            <param name="borderType"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PreCornerDetect(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32,OpenCv30Sharp.BorderTypes)">
            <summary>
            computes another complex cornerness criteria at each pixel
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="ksize"></param>
            <param name="borderType"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CornerSubPix(OpenCv30Sharp.InputArray,System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},OpenCv30Sharp.Size,OpenCv30Sharp.Size,OpenCv30Sharp.TermCriteria)">
            <summary>
            adjusts the corner locations with sub-pixel accuracy to maximize the certain cornerness criteria
            </summary>
            <param name="image">Input image.</param>
            <param name="inputCorners">Initial coordinates of the input corners and refined coordinates provided for output.</param>
            <param name="winSize">Half of the side length of the search window.</param>
            <param name="zeroZone">Half of the size of the dead region in the middle of the search zone 
            over which the summation in the formula below is not done. It is used sometimes to avoid possible singularities 
            of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such a size.</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. 
            That is, the process of corner position refinement stops either after criteria.maxCount iterations 
            or when the corner position moves by less than criteria.epsilon on some iteration.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GoodFeaturesToTrack(OpenCv30Sharp.InputArray,System.Int32,System.Double,System.Double,OpenCv30Sharp.InputArray,System.Int32,System.Boolean,System.Double)">
            <summary>
            finds the strong enough corners where the cornerMinEigenVal() or cornerHarris() report the local maxima
            </summary>
            <param name="src">Input 8-bit or floating-point 32-bit, single-channel image.</param>
            <param name="maxCorners">Maximum number of corners to return. If there are more corners than are found, 
            the strongest of them is returned.</param>
            <param name="qualityLevel">Parameter characterizing the minimal accepted quality of image corners. 
            The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue 
            or the Harris function response (see cornerHarris() ). The corners with the quality measure less than 
            the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01, 
            then all the corners with the quality measure less than 15 are rejected.</param>
            <param name="minDistance">Minimum possible Euclidean distance between the returned corners.</param>
            <param name="mask">Optional region of interest. If the image is not empty
             (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region 
            in which the corners are detected.</param>
            <param name="blockSize">Size of an average block for computing a derivative covariation matrix over each pixel neighborhood.</param>
            <param name="useHarrisDetector">Parameter indicating whether to use a Harris detector</param>
            <param name="k">Free parameter of the Harris detector.</param>
            <returns>Output vector of detected corners.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.HoughLines(OpenCv30Sharp.InputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines in a binary image using standard Hough transform.
            </summary>
            <param name="image">The 8-bit, single-channel, binary source image. The image may be modified by the function</param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">The accumulator threshold parameter. Only those lines are returned that get enough votes ( &gt; threshold )</param>
            <param name="srn">For the multi-scale Hough transform it is the divisor for the distance resolution rho. [By default this is 0]</param>
            <param name="stn">For the multi-scale Hough transform it is the divisor for the distance resolution theta. [By default this is 0]</param>
            <returns>The output vector of lines. Each line is represented by a two-element vector (rho, theta) . 
            rho is the distance from the coordinate origin (0,0) (top-left corner of the image) and theta is the line rotation angle in radians</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.HoughLinesP(OpenCv30Sharp.InputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines segments in a binary image using probabilistic Hough transform.
            </summary>
            <param name="image"></param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">The accumulator threshold parameter. Only those lines are returned that get enough votes ( &gt; threshold )</param>
            <param name="minLineLength">The minimum line length. Line segments shorter than that will be rejected. [By default this is 0]</param>
            <param name="maxLineGap">The maximum allowed gap between points on the same line to link them. [By default this is 0]</param>
            <returns>The output lines. Each line is represented by a 4-element vector (x1, y1, x2, y2)</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.HoughCircles(OpenCv30Sharp.InputArray,OpenCv30Sharp.HoughMethods,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in a grayscale image using a Hough transform.
            </summary>
            <param name="image">The 8-bit, single-channel, grayscale input image</param>
            <param name="method">Currently, the only implemented method is HoughCirclesMethod.Gradient</param>
            <param name="dp">The inverse ratio of the accumulator resolution to the image resolution. </param>
            <param name="minDist">Minimum distance between the centers of the detected circles. </param>
            <param name="param1">The first method-specific parameter. [By default this is 100]</param>
            <param name="param2">The second method-specific parameter. [By default this is 100]</param>
            <param name="minRadius">Minimum circle radius. [By default this is 0]</param>
            <param name="maxRadius">Maximum circle radius. [By default this is 0] </param>
            <returns>The output vector found circles. Each vector is encoded as 3-element floating-point vector (x, y, radius)</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MorphologyDefaultBorderValue">
            <summary>
            Default borderValue for Dilate/Erode
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Dilate(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Int32,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Dilates an image by using a specific structuring element.
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image. It will have the same size and the same type as src</param>
            <param name="element">The structuring element used for dilation. If element=new Mat() , a 3x3 rectangular structuring element is used</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">The number of times dilation is applied. [By default this is 1]</param>
            <param name="borderType">The pixel extrapolation method. [By default this is BorderType.Constant]</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Erode(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Int32,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Erodes an image by using a specific structuring element.
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image. It will have the same size and the same type as src</param>
            <param name="element">The structuring element used for dilation. If element=new Mat(), a 3x3 rectangular structuring element is used</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">The number of times erosion is applied</param>
            <param name="borderType">The pixel extrapolation method</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MorphologyEx(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.MorphTypes,OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Int32,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Performs advanced morphological transformations
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image. It will have the same size and the same type as src</param>
            <param name="op">Type of morphological operation</param>
            <param name="element">Structuring element</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">Number of times erosion and dilation are applied. [By default this is 1]</param>
            <param name="borderType">The pixel extrapolation method. [By default this is BorderType.Constant]</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Resize(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.Size,System.Double,System.Double,OpenCv30Sharp.InterpolationFlags)">
            <summary>
            Resizes an image.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image; it has the size dsize (when it is non-zero) or the size computed 
            from src.size(), fx, and fy; the type of dst is the same as of src.</param>
            <param name="dsize">output image size; if it equals zero, it is computed as: 
            dsize = Size(round(fx*src.cols), round(fy*src.rows))
            Either dsize or both fx and fy must be non-zero.</param>
            <param name="fx">scale factor along the horizontal axis; when it equals 0, 
            it is computed as: (double)dsize.width/src.cols</param>
            <param name="fy">scale factor along the vertical axis; when it equals 0, 
            it is computed as: (double)dsize.height/src.rows</param>
            <param name="interpolation">interpolation method</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.WarpAffine(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.InterpolationFlags,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Applies an affine transformation to an image.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image that has the size dsize and the same type as src.</param>
            <param name="m">2x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods and the optional flag 
            WARP_INVERSE_MAP that means that M is the inverse transformation (dst -> src) .</param>
            <param name="borderMode">pixel extrapolation method; when borderMode=BORDER_TRANSPARENT, 
            it means that the pixels in the destination image corresponding to the "outliers" 
            in the source image are not modified by the function.</param>
            <param name="borderValue">value used in case of a constant border; by default, it is 0.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.WarpPerspective(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.InterpolationFlags,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Applies a perspective transformation to an image.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image that has the size dsize and the same type as src.</param>
            <param name="m">3x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods (INTER_LINEAR or INTER_NEAREST) 
            and the optional flag WARP_INVERSE_MAP, that sets M as the inverse transformation (dst -> src).</param>
            <param name="borderMode">pixel extrapolation method (BORDER_CONSTANT or BORDER_REPLICATE).</param>
            <param name="borderValue">value used in case of a constant border; by default, it equals 0.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.WarpPerspective(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Single[0:,0:],OpenCv30Sharp.Size,OpenCv30Sharp.InterpolationFlags,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Applies a perspective transformation to an image.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image that has the size dsize and the same type as src.</param>
            <param name="m">3x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods (INTER_LINEAR or INTER_NEAREST) 
            and the optional flag WARP_INVERSE_MAP, that sets M as the inverse transformation (dst -> src).</param>
            <param name="borderMode">pixel extrapolation method (BORDER_CONSTANT or BORDER_REPLICATE).</param>
            <param name="borderValue">value used in case of a constant border; by default, it equals 0.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Remap(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InterpolationFlags,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Applies a generic geometrical transformation to an image.
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image. It has the same size as map1 and the same type as src</param>
            <param name="map1">The first map of either (x,y) points or just x values having the type CV_16SC2, CV_32FC1, or CV_32FC2.</param>
            <param name="map2">The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively.</param>
            <param name="interpolation">Interpolation method. The method INTER_AREA is not supported by this function.</param>
            <param name="borderMode">Pixel extrapolation method. When borderMode=BORDER_TRANSPARENT, 
            it means that the pixels in the destination image that corresponds to the "outliers" in 
            the source image are not modified by the function.</param>
            <param name="borderValue">Value used in case of a constant border. By default, it is 0.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvertMaps(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.MatType,System.Boolean)">
            <summary>
            
            </summary>
            <param name="map1"></param>
            <param name="map2"></param>
            <param name="dstmap1"></param>
            <param name="dstmap2"></param>
            <param name="dstmap1Type"></param>
            <param name="nnInterpolation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetRotationMatrix2D(OpenCv30Sharp.Point2f,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="center"></param>
            <param name="angle"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.InvertAffineTransform(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Inverts an affine transformation.
            </summary>
            <param name="m">Original affine transformation.</param>
            <param name="im">Output reverse affine transformation.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetPerspectiveTransform(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f})">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetPerspectiveTransform(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetAffineTransform(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f})">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetAffineTransform(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetRectSubPix(OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.Point2f,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            Retrieves a pixel rectangle from an image with sub-pixel accuracy.
            </summary>
            <param name="image">Source image.</param>
            <param name="patchSize">Size of the extracted patch.</param>
            <param name="center">Floating point coordinates of the center of the extracted rectangle 
            within the source image. The center must be inside the image.</param>
            <param name="patch">Extracted patch that has the size patchSize and the same number of channels as src .</param>
            <param name="patchType">Depth of the extracted pixels. By default, they have the same depth as src.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.LogPolar(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.Point2f,System.Double,OpenCv30Sharp.InterpolationFlags)">
            <summary>
            Remaps an image to log-polar space.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center; where the output precision is maximal</param>
            <param name="m">Magnitude scale parameter.</param>
            <param name="flags">A combination of interpolation methods, see cv::InterpolationFlags</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.LinearPolar(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.Point2f,System.Double,OpenCv30Sharp.InterpolationFlags)">
            <summary>
            Remaps an image to polar space.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center</param>
            <param name="maxRadius">Inverse magnitude scale parameter</param>
            <param name="flags">A combination of interpolation methods, see cv::InterpolationFlags</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Integral(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="sum"></param>
            <param name="sdepth"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Integral(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="sum"></param>
            <param name="sqsum"></param>
            <param name="sdepth"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Integral(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="sum"></param>
            <param name="sqsum"></param>
            <param name="tilted"></param>
            <param name="sdepth"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Accumulate(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            Adds an image to the accumulator.
            </summary>
            <param name="src">Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</param>
            <param name="dst">Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</param>
            <param name="mask">Optional operation mask.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.AccumulateSquare(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            Adds the square of a source image to the accumulator.
            </summary>
            <param name="src">Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</param>
            <param name="dst">Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</param>
            <param name="mask">Optional operation mask.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.AccumulateProduct(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            Adds the per-element product of two input images to the accumulator.
            </summary>
            <param name="src1">First input image, 1- or 3-channel, 8-bit or 32-bit floating point.</param>
            <param name="src2">Second input image of the same type and the same size as src1</param>
            <param name="dst">Accumulator with the same number of channels as input images, 32-bit or 64-bit floating-point.</param>
            <param name="mask">Optional operation mask.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.AccumulateWeighted(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,System.Double,OpenCv30Sharp.InputArray)">
            <summary>
            Updates a running average.
            </summary>
            <param name="src">Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</param>
            <param name="dst">Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</param>
            <param name="alpha">Weight of the input image.</param>
            <param name="mask">Optional operation mask.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PSNR(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PhaseCorrelate(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PhaseCorrelateRes(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PhaseCorrelateRes(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,System.Double@)">
            <summary>
            
            </summary>
            <param name="src1"></param>
            <param name="src2"></param>
            <param name="window"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateHanningWindow(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            Computes a Hanning window coefficients in two dimensions.
            </summary>
            <param name="dst">Destination array to place Hann coefficients in</param>
            <param name="winSize">The window size specifications</param>
            <param name="type">Created array type</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Threshold(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double,System.Double,OpenCv30Sharp.ThresholdTypes)">
            <summary>
            Applies a fixed-level threshold to each array element.
            </summary>
            <param name="src">input array (single-channel, 8-bit or 32-bit floating point).</param>
            <param name="dst">output array of the same size and type as src.</param>
            <param name="thresh">threshold value.</param>
            <param name="maxval">maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding types.</param>
            <param name="type">thresholding type (see the details below).</param>
            <returns>the computed threshold value when type == OTSU</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.AdaptiveThreshold(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double,OpenCv30Sharp.AdaptiveThresholdTypes,OpenCv30Sharp.ThresholdTypes,System.Int32,System.Double)">
            <summary>
            Applies an adaptive threshold to an array.
            </summary>
            <param name="src">Source 8-bit single-channel image.</param>
            <param name="dst">Destination image of the same size and the same type as src .</param>
            <param name="maxValue">Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.</param>
            <param name="adaptiveMethod">Adaptive thresholding algorithm to use, ADAPTIVE_THRESH_MEAN_C or ADAPTIVE_THRESH_GAUSSIAN_C .</param>
            <param name="thresholdType">Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV .</param>
            <param name="blockSize">Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.</param>
            <param name="c">Constant subtracted from the mean or weighted mean (see the details below). 
            Normally, it is positive but may be zero or negative as well.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PyrDown(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Nullable{OpenCv30Sharp.Size},OpenCv30Sharp.BorderTypes)">
            <summary>
            Blurs an image and downsamples it.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image; it has the specified size and the same type as src.</param>
            <param name="dstSize">size of the output image; by default, it is computed as Size((src.cols+1)/2</param>
            <param name="borderType"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PyrUp(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Nullable{OpenCv30Sharp.Size},OpenCv30Sharp.BorderTypes)">
            <summary>
            Upsamples an image and then blurs it.
            </summary>
            <param name="src">input image.</param>
            <param name="dst">output image. It has the specified size and the same type as src.</param>
            <param name="dstSize">size of the output image; by default, it is computed as Size(src.cols*2, (src.rows*2)</param>
            <param name="borderType"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Undistort(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            corrects lens distortion for the given camera matrix and distortion coefficients
            </summary>
            <param name="src">Input (distorted) image.</param>
            <param name="dst">Output (corrected) image that has the same size and type as src .</param>
            <param name="cameraMatrix"> Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, 
            or 8 elements. If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="newCameraMatrix">Camera matrix of the distorted image. 
            By default, it is the same as cameraMatrix but you may additionally scale 
            and shift the result by using a different matrix.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.InitUndistortRectifyMap(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.MatType,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            initializes maps for cv::remap() to correct lens distortion and optionally rectify the image
            </summary>
            <param name="cameraMatrix"></param>
            <param name="distCoeffs"></param>
            <param name="r"></param>
            <param name="newCameraMatrix"></param>
            <param name="size"></param>
            <param name="m1Type"></param>
            <param name="map1"></param>
            <param name="map2"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.InitWideAngleProjMap(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,System.Int32,OpenCv30Sharp.MatType,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.ProjectionType,System.Double)">
            <summary>
            initializes maps for cv::remap() for wide-angle
            </summary>
            <param name="cameraMatrix"></param>
            <param name="distCoeffs"></param>
            <param name="imageSize"></param>
            <param name="destImageWidth"></param>
            <param name="m1Type"></param>
            <param name="map1"></param>
            <param name="map2"></param>
            <param name="projType"></param>
            <param name="alpha"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetDefaultNewCameraMatrix(OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Size},System.Boolean)">
            <summary>
            returns the default new camera matrix (by default it is the same as cameraMatrix unless centerPricipalPoint=true)
            </summary>
            <param name="cameraMatrix">Input camera matrix.</param>
            <param name="imgSize">Camera view image size in pixels.</param>
            <param name="centerPrincipalPoint">Location of the principal point in the new camera matrix. 
            The parameter indicates whether this location should be at the image center or not.</param>
            <returns>the camera matrix that is either an exact copy of the input cameraMatrix 
            (when centerPrinicipalPoint=false), or the modified one (when centerPrincipalPoint=true).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.UndistortPoints(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            Computes the ideal point coordinates from the observed point coordinates.
            </summary>
            <param name="src">Observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or CV_64FC2).</param>
            <param name="dst">Output ideal point coordinates after undistortion and reverse perspective transformation. 
            If matrix P is identity or omitted, dst will contain normalized point coordinates.</param>
            <param name="cameraMatrix">Camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="r">Rectification transformation in the object space (3x3 matrix). 
            R1 or R2 computed by stereoRectify() can be passed here. 
            If the matrix is empty, the identity transformation is used.</param>
            <param name="p">New camera matrix (3x3) or new projection matrix (3x4). 
            P1 or P2 computed by stereoRectify() can be passed here. If the matrix is empty, 
            the identity new camera matrix is used.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcHist(OpenCv30Sharp.Mat[],System.Int32[],OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32,System.Int32[],OpenCv30Sharp.Rangef[],System.Boolean,System.Boolean)">
            <summary>
            computes the joint dense histogram for a set of images.
            </summary>
            <param name="images"></param>
            <param name="channels"></param>
            <param name="mask"></param>
            <param name="hist"></param>
            <param name="dims"></param>
            <param name="histSize"></param>
            <param name="ranges"></param>
            <param name="uniform"></param>
            <param name="accumulate"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcHist(OpenCv30Sharp.Mat[],System.Int32[],OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32,System.Int32[],System.Single[][],System.Boolean,System.Boolean)">
            <summary>
            computes the joint dense histogram for a set of images.
            </summary>
            <param name="images"></param>
            <param name="channels"></param>
            <param name="mask"></param>
            <param name="hist"></param>
            <param name="dims"></param>
            <param name="histSize"></param>
            <param name="ranges"></param>
            <param name="uniform"></param>
            <param name="accumulate"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CalcBackProject(OpenCv30Sharp.Mat[],System.Int32[],OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.Rangef[],System.Boolean)">
            <summary>
            computes the joint dense histogram for a set of images.
            </summary>
            <param name="images"></param>
            <param name="channels"></param>
            <param name="hist"></param>
            <param name="backProject"></param>
            <param name="ranges"></param>
            <param name="uniform"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CompareHist(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.HistCompMethods)">
            <summary>
            compares two histograms stored in dense arrays
            </summary>
            <param name="h1">The first compared histogram</param>
            <param name="h2">The second compared histogram of the same size as h1</param>
            <param name="method">The comparison method</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.EqualizeHist(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            normalizes the grayscale image brightness and contrast by normalizing its histogram
            </summary>
            <param name="src">The source 8-bit single channel image</param>
            <param name="dst">The destination image; will have the same size and the same type as src</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CreateCLAHE(System.Double,System.Nullable{OpenCv30Sharp.Size})">
            <summary>
            Creates a predefined CLAHE object
            </summary>
            <param name="clipLimit"></param>
            <param name="tileGridSize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.EMD(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.DistanceTypes)">
            <summary>
            
            </summary>
            <param name="signature1"></param>
            <param name="signature2"></param>
            <param name="distType"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.EMD(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.DistanceTypes,OpenCv30Sharp.InputArray)">
            <summary>
            
            </summary>
            <param name="signature1"></param>
            <param name="signature2"></param>
            <param name="distType"></param>
            <param name="cost"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.EMD(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.DistanceTypes,OpenCv30Sharp.InputArray,System.Single@)">
            <summary>
            
            </summary>
            <param name="signature1"></param>
            <param name="signature2"></param>
            <param name="distType"></param>
            <param name="cost"></param>
            <param name="lowerBound"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.EMD(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.DistanceTypes,OpenCv30Sharp.InputArray,System.Single@,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="signature1"></param>
            <param name="signature2"></param>
            <param name="distType"></param>
            <param name="cost"></param>
            <param name="lowerBound"></param>
            <param name="flow"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Watershed(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray)">
            <summary>
            Performs a marker-based image segmentation using the watershed algorithm.
            </summary>
            <param name="image">Input 8-bit 3-channel image.</param>
            <param name="markers">Input/output 32-bit single-channel image (map) of markers. 
            It should have the same size as image.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PyrMeanShiftFiltering(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double,System.Double,System.Int32,System.Nullable{OpenCv30Sharp.TermCriteria})">
            <summary>
            Performs initial step of meanshift segmentation of an image.
            </summary>
            <param name="src">The source 8-bit, 3-channel image.</param>
            <param name="dst">The destination image of the same format and the same size as the source.</param>
            <param name="sp">The spatial window radius.</param>
            <param name="sr">The color window radius.</param>
            <param name="maxLevel">Maximum level of the pyramid for the segmentation.</param>
            <param name="termcrit">Termination criteria: when to stop meanshift iterations.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GrabCut(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Rect,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputOutputArray,System.Int32,OpenCv30Sharp.GrabCutModes)">
            <summary>
            Segments the image using GrabCut algorithm
            </summary>
            <param name="img">Input 8-bit 3-channel image.</param>
            <param name="mask">Input/output 8-bit single-channel mask. 
            The mask is initialized by the function when mode is set to GC_INIT_WITH_RECT. 
            Its elements may have Cv2.GC_BGD / Cv2.GC_FGD / Cv2.GC_PR_BGD / Cv2.GC_PR_FGD</param>
            <param name="rect">ROI containing a segmented object. The pixels outside of the ROI are 
            marked as "obvious background". The parameter is only used when mode==GC_INIT_WITH_RECT.</param>
            <param name="bgdModel">Temporary array for the background model. Do not modify it while you are processing the same image.</param>
            <param name="fgdModel">Temporary arrays for the foreground model. Do not modify it while you are processing the same image.</param>
            <param name="iterCount">Number of iterations the algorithm should make before returning the result. 
            Note that the result can be refined with further calls with mode==GC_INIT_WITH_MASK or mode==GC_EVAL .</param>
            <param name="mode">Operation mode that could be one of GrabCutFlag value.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DistanceTransformWithLabels(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DistanceTypes,OpenCv30Sharp.DistanceMaskSize,OpenCv30Sharp.DistanceTransformLabelTypes)">
            <summary>
            builds the discrete Voronoi diagram
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="labels"></param>
            <param name="distanceType"></param>
            <param name="maskSize"></param>
            <param name="labelType"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DistanceTransform(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DistanceTypes,OpenCv30Sharp.DistanceMaskSize)">
            <summary>
            computes the distance transform map
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="distanceType"></param>
            <param name="maskSize"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FloodFill(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar)">
            <summary>
            Fills a connected component with the given color.
            </summary>
            <param name="image">Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FloodFill(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,OpenCv30Sharp.Rect@,System.Nullable{OpenCv30Sharp.Scalar},System.Nullable{OpenCv30Sharp.Scalar},OpenCv30Sharp.FloodFillFlags)">
            <summary>
            Fills a connected component with the given color.
            </summary>
            <param name="image">Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <param name="rect">Optional output parameter set by the function to the 
            minimum bounding rectangle of the repainted domain.</param>
            <param name="loDiff">Maximal lower brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="upDiff">Maximal upper brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="flags">Operation flags. Lower bits contain a connectivity value, 
            4 (default) or 8, used within the function. Connectivity determines which 
            neighbors of a pixel are considered. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FloodFill(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar)">
            <summary>
            Fills a connected component with the given color.
            </summary>
            <param name="image">Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.</param>
            <param name="mask">(For the second function only) Operation mask that should be a single-channel 8-bit image, 
            2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of 
            initializing the mask content. Flood-filling cannot go across non-zero pixels in the mask. For example, 
            an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask 
            in multiple calls to the function to make sure the filled area does not overlap.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FloodFill(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,OpenCv30Sharp.Rect@,System.Nullable{OpenCv30Sharp.Scalar},System.Nullable{OpenCv30Sharp.Scalar},OpenCv30Sharp.FloodFillFlags)">
            <summary>
            Fills a connected component with the given color.
            </summary>
            <param name="image">Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.</param>
            <param name="mask">(For the second function only) Operation mask that should be a single-channel 8-bit image, 
            2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of 
            initializing the mask content. Flood-filling cannot go across non-zero pixels in the mask. For example, 
            an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask 
            in multiple calls to the function to make sure the filled area does not overlap.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <param name="rect">Optional output parameter set by the function to the 
            minimum bounding rectangle of the repainted domain.</param>
            <param name="loDiff">Maximal lower brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="upDiff">Maximal upper brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="flags">Operation flags. Lower bits contain a connectivity value, 
            4 (default) or 8, used within the function. Connectivity determines which 
            neighbors of a pixel are considered. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.CvtColor(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.ColorConversionCodes,System.Int32)">
            <summary>
            Converts image from one color space to another
            </summary>
            <param name="src">The source image, 8-bit unsigned, 16-bit unsigned or single-precision floating-point</param>
            <param name="dst">The destination image; will have the same size and the same depth as src</param>
            <param name="code">The color space conversion code</param>
            <param name="dstCn">The number of channels in the destination image; if the parameter is 0, the number of the channels will be derived automatically from src and the code</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Moments(OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (single-channel, 8-bit or floating-point 
            2D array) or an array ( 1xN or Nx1 ) of 2D points ( Point or Point2f )</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Moments(System.Byte[0:,0:],System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (8-bit) 2D array</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Moments(System.Single[0:,0:],System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (floating-point) 2D array</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Moments(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">Array of 2D points</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Moments(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">Array of 2D points</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MatchTemplate(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.TemplateMatchModes,OpenCv30Sharp.InputArray)">
            <summary>
            Computes the proximity map for the raster template and the image where the template is searched for
            </summary>
            <param name="image">Image where the search is running; should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and have the same data type</param>
            <param name="result">A map of comparison results; will be single-channel 32-bit floating-point. 
            If image is WxH and templ is wxh then result will be (W-w+1) x (H-h+1).</param>
            <param name="method">Specifies the comparison method</param>
            <param name="mask">Mask of searched template. It must have the same datatype and size with templ. It is not set by default.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConnectedComponents(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled image</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConnectedComponents(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.PixelConnectivity,OpenCv30Sharp.MatType)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled image</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConnectedComponents(OpenCv30Sharp.InputArray,System.Int32[0:,0:]@,OpenCv30Sharp.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled rectangular array</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConnectedComponentsWithStats(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled image</param>
            <param name="stats">statistics output for each label, including the background label, 
            see below for available statistics. Statistics are accessed via stats(label, COLUMN) 
            where COLUMN is one of cv::ConnectedComponentsTypes</param>
            <param name="centroids">floating point centroid (x,y) output for each label, 
            including the background label</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConnectedComponentsWithStats(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.PixelConnectivity,OpenCv30Sharp.MatType)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="labels">destination labeled image</param>
            <param name="stats">statistics output for each label, including the background label, 
            see below for available statistics. Statistics are accessed via stats(label, COLUMN) 
            where COLUMN is one of cv::ConnectedComponentsTypes</param>
            <param name="centroids">floating point centroid (x,y) output for each label, 
            including the background label</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConnectedComponentsEx(OpenCv30Sharp.InputArray,OpenCv30Sharp.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="image">the image to be labeled</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindContours(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point[][]@,OpenCv30Sharp.HierarchyIndex[]@,OpenCv30Sharp.RetrievalModes,OpenCv30Sharp.ContourApproximationModes,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Finds contours in a binary image.
            </summary>
            <param name="image">Source, an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary.
            The function modifies the image while extracting the contours.</param> 
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology. 
            It has as many elements as the number of contours. For each i-th contour contours[i], 
            the members of the elements hierarchy[i] are set to 0-based indices in contours of the next 
            and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. 
            If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.</param>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindContours(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Mat[]@,OpenCv30Sharp.OutputArray,OpenCv30Sharp.RetrievalModes,OpenCv30Sharp.ContourApproximationModes,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Finds contours in a binary image.
            </summary>
            <param name="image">Source, an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary.
            The function modifies the image while extracting the contours.</param> 
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology. 
            It has as many elements as the number of contours. For each i-th contour contours[i], 
            the members of the elements hierarchy[i] are set to 0-based indices in contours of the next 
            and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. 
            If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.</param>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindContoursAsArray(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.RetrievalModes,OpenCv30Sharp.ContourApproximationModes,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Finds contours in a binary image.
            </summary>
            <param name="image">Source, an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary.
            The function modifies the image while extracting the contours.</param> 
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
            <returns>Detected contours. Each contour is stored as a vector of points.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FindContoursAsMat(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.RetrievalModes,OpenCv30Sharp.ContourApproximationModes,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Finds contours in a binary image.
            </summary>
            <param name="image">Source, an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary.
            The function modifies the image while extracting the contours.</param> 
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
            <returns>Detected contours. Each contour is stored as a vector of points.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ApproxPolyDP(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double,System.Boolean)">
            <summary>
            Approximates contour or a curve using Douglas-Peucker algorithm
            </summary>
            <param name="curve">The polygon or curve to approximate. 
            Must be 1 x N or N x 1 matrix of type CV_32SC2 or CV_32FC2.</param>
            <param name="approxCurve">The result of the approximation; 
            The type should match the type of the input curve</param>
            <param name="epsilon">Specifies the approximation accuracy. 
            This is the maximum distance between the original curve and its approximation.</param>
            <param name="closed">The result of the approximation; 
            The type should match the type of the input curve</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ApproxPolyDP(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Double,System.Boolean)">
            <summary>
            Approximates contour or a curve using Douglas-Peucker algorithm
            </summary>
            <param name="curve">The polygon or curve to approximate.</param>
            <param name="epsilon">Specifies the approximation accuracy. 
            This is the maximum distance between the original curve and its approximation.</param>
            <param name="closed">The result of the approximation; 
            The type should match the type of the input curve</param>
            <returns>The result of the approximation; 
            The type should match the type of the input curve</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ApproxPolyDP(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Double,System.Boolean)">
            <summary>
            Approximates contour or a curve using Douglas-Peucker algorithm
            </summary>
            <param name="curve">The polygon or curve to approximate.</param>
            <param name="epsilon">Specifies the approximation accuracy. 
            This is the maximum distance between the original curve and its approximation.</param>
            <param name="closed">If true, the approximated curve is closed 
            (i.e. its first and last vertices are connected), otherwise it’s not</param>
            <returns>The result of the approximation; 
            The type should match the type of the input curve</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ArcLength(OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length.
            </summary>
            <param name="curve">The input vector of 2D points, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <param name="closed">Indicates, whether the curve is closed or not.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ArcLength(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length.
            </summary>
            <param name="curve">The input vector of 2D points.</param>
            <param name="closed">Indicates, whether the curve is closed or not.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ArcLength(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length.
            </summary>
            <param name="curve">The input vector of 2D points.</param>
            <param name="closed">Indicates, whether the curve is closed or not.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BoundingRect(OpenCv30Sharp.InputArray)">
            <summary>
            Calculates the up-right bounding rectangle of a point set.
            </summary>
            <param name="curve">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns>Minimal up-right bounding rectangle for the specified point set.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BoundingRect(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point})">
            <summary>
            Calculates the up-right bounding rectangle of a point set.
            </summary>
            <param name="curve">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns>Minimal up-right bounding rectangle for the specified point set.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.BoundingRect(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f})">
            <summary>
            Calculates the up-right bounding rectangle of a point set.
            </summary>
            <param name="curve">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns>Minimal up-right bounding rectangle for the specified point set.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ContourArea(OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Calculates the contour area
            </summary>
            <param name="contour">The contour vertices, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="oriented"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ContourArea(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Boolean)">
            <summary>
            Calculates the contour area
            </summary>
            <param name="contour">The contour vertices, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="oriented"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ContourArea(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Boolean)">
            <summary>
            Calculates the contour area
            </summary>
            <param name="contour">The contour vertices, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="oriented"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinAreaRect(OpenCv30Sharp.InputArray)">
            <summary>
            Finds the minimum area rotated rectangle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinAreaRect(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point})">
            <summary>
            Finds the minimum area rotated rectangle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinAreaRect(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f})">
            <summary>
            Finds the minimum area rotated rectangle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinEnclosingCircle(OpenCv30Sharp.InputArray,OpenCv30Sharp.Point2f@,System.Single@)">
            <summary>
            Finds the minimum area circle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <param name="center">The output center of the circle</param>
            <param name="radius">The output radius of the circle</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinEnclosingCircle(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},OpenCv30Sharp.Point2f@,System.Single@)">
            <summary>
            Finds the minimum area circle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <param name="center">The output center of the circle</param>
            <param name="radius">The output radius of the circle</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MinEnclosingCircle(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},OpenCv30Sharp.Point2f@,System.Single@)">
            <summary>
            Finds the minimum area circle enclosing a 2D point set.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.</param>
            <param name="center">The output center of the circle</param>
            <param name="radius">The output radius of the circle</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MatchShapes(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.ShapeMatchModes,System.Double)">
            <summary>
            matches two contours using one of the available algorithms
            </summary>
            <param name="contour1"></param>
            <param name="contour2"></param>
            <param name="method"></param>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.MatchShapes(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},OpenCv30Sharp.ShapeMatchModes,System.Double)">
            <summary>
            matches two contours using one of the available algorithms
            </summary>
            <param name="contour1"></param>
            <param name="contour2"></param>
            <param name="method"></param>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvexHull(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Boolean,System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="hull">The output convex hull. It is either a vector of points that form the 
            hull (must have the same type as the input points), or a vector of 0-based point 
            indices of the hull points in the original array (since the set of convex hull 
            points is a subset of the original point set).</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <param name="returnPoints"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvexHull(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of points that form 
            the hull (must have the same type as the input points).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvexHull(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of points that form 
            the hull (must have the same type as the input points).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvexHullIndices(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of 0-based point indices of the 
            hull points in the original array (since the set of convex hull points is a subset of the original point set).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvexHullIndices(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of 0-based point indices of the 
            hull points in the original array (since the set of convex hull points is a subset of the original point set).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvexityDefects(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="contour">Input contour.</param>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <param name="convexityDefects">
            The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvexityDefects(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="contour">Input contour.</param>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <returns>The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ConvexityDefects(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="contour">Input contour.</param>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <returns>The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.IsContourConvex(OpenCv30Sharp.InputArray)">
            <summary>
            returns true if the contour is convex. 
            Does not support contours with self-intersection
            </summary>
            <param name="contour">Input vector of 2D points</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.IsContourConvex(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point})">
            <summary>
            returns true if the contour is convex. 
            Does not support contours with self-intersection
            </summary>
            <param name="contour">Input vector of 2D points</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.IsContourConvex(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f})">
            <summary>
            returns true if the contour is convex. D
            oes not support contours with self-intersection
            </summary>
            <param name="contour">Input vector of 2D points</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.IntersectConvexConvex(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Boolean)">
            <summary>
            finds intersection of two convex polygons
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p12"></param>
            <param name="handleNested"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.IntersectConvexConvex(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},OpenCv30Sharp.Point[]@,System.Boolean)">
            <summary>
            finds intersection of two convex polygons
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p12"></param>
            <param name="handleNested"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.IntersectConvexConvex(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},OpenCv30Sharp.Point2f[]@,System.Boolean)">
            <summary>
            finds intersection of two convex polygons
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p12"></param>
            <param name="handleNested"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FitEllipse(OpenCv30Sharp.InputArray)">
            <summary>
            Fits ellipse to the set of 2D points.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FitEllipse(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point})">
            <summary>
            Fits ellipse to the set of 2D points.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FitEllipse(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f})">
            <summary>
            Fits ellipse to the set of 2D points.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FitLine(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 2D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="line">Output line parameters. 
            In case of 2D fitting, it should be a vector of 4 elements 
            (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector 
            collinear to the line and (x0, y0) is a point on the line. 
            In case of 3D fitting, it should be a vector of 6 elements 
            (like Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a 
            normalized vector collinear to the line and (x0, y0, z0) is a point on the line.</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FitLine(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},OpenCv30Sharp.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 2D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FitLine(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},OpenCv30Sharp.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 2D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FitLine(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3i},OpenCv30Sharp.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 3D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FitLine(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f},OpenCv30Sharp.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 3D points using M-estimator algorithm
            </summary>
            <param name="points">Input vector of 2D or 3D points</param>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PointPolygonTest(OpenCv30Sharp.InputArray,OpenCv30Sharp.Point2f,System.Boolean)">
            <summary>
            Checks if the point is inside the contour. Optionally computes the signed distance from the point to the contour boundary
            </summary>
            <param name="contour"></param>
            <param name="pt"></param>
            <param name="measureDist"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PointPolygonTest(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},OpenCv30Sharp.Point2f,System.Boolean)">
            <summary>
            Checks if the point is inside the contour. Optionally computes the signed distance from the point to the contour boundary
            </summary>
            <param name="contour"></param>
            <param name="pt"></param>
            <param name="measureDist"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PointPolygonTest(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},OpenCv30Sharp.Point2f,System.Boolean)">
            <summary>
            Checks if the point is inside the contour. 
            Optionally computes the signed distance from the point to the contour boundary.
            </summary>
            <param name="contour">Input contour.</param>
            <param name="pt">Point tested against the contour.</param>
            <param name="measureDist">If true, the function estimates the signed distance 
            from the point to the nearest contour edge. Otherwise, the function only checks 
            if the point is inside a contour or not.</param>
            <returns>Positive (inside), negative (outside), or zero (on an edge) value.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.RotatedRectangleIntersection(OpenCv30Sharp.RotatedRect,OpenCv30Sharp.RotatedRect,OpenCv30Sharp.OutputArray)">
            <summary>
            Finds out if there is any intersection between two rotated rectangles.
            If there is then the vertices of the interesecting region are returned as well.
            Below are some examples of intersection configurations. 
            The hatched pattern indicates the intersecting region and the red 
            vertices are returned by the function.
            </summary>
            <param name="rect1">First rectangle</param>
            <param name="rect2">Second rectangle</param>
            <param name="intersectingRegion">
            The output array of the verticies of the intersecting region. 
            It returns at most 8 vertices.
            Stored as std::vector&lt;cv::Point2f&gt; or cv::Mat as Mx1 of type CV_32FC2.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.RotatedRectangleIntersection(OpenCv30Sharp.RotatedRect,OpenCv30Sharp.RotatedRect,OpenCv30Sharp.Point2f[]@)">
            <summary>
            Finds out if there is any intersection between two rotated rectangles.
            If there is then the vertices of the interesecting region are returned as well.
            Below are some examples of intersection configurations. 
            The hatched pattern indicates the intersecting region and the red 
            vertices are returned by the function.
            </summary>
            <param name="rect1">First rectangle</param>
            <param name="rect2">Second rectangle</param>
            <param name="intersectingRegion">
            The output array of the verticies of the intersecting region. 
            It returns at most 8 vertices.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ApplyColorMap(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.ColormapTypes)">
            <summary>
            Applies a GNU Octave/MATLAB equivalent colormap on a given image.
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="colormap"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Line(OpenCv30Sharp.InputOutputArray,System.Int32,System.Int32,System.Int32,System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws a line segment connecting two points
            </summary>
            <param name="img">The image. </param>
            <param name="pt1X">First point's x-coordinate of the line segment. </param>
            <param name="pt1Y">First point's y-coordinate of the line segment. </param>
            <param name="pt2X">Second point's x-coordinate of the line segment. </param>
            <param name="pt2Y">Second point's y-coordinate of the line segment. </param>
            <param name="color">Line color. </param>
            <param name="thickness">Line thickness. [By default this is 1]</param>
            <param name="lineType">Type of the line. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Line(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws a line segment connecting two points
            </summary>
            <param name="img">The image. </param>
            <param name="pt1">First point of the line segment. </param>
            <param name="pt2">Second point of the line segment. </param>
            <param name="color">Line color. </param>
            <param name="thickness">Line thickness. [By default this is 1]</param>
            <param name="lineType">Type of the line. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ArrowedLine(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32,System.Double)">
            <summary>
            Draws a arrow segment pointing from the first point to the second one.
            The function arrowedLine draws an arrow between pt1 and pt2 points in the image. 
            See also cv::line.
            </summary>
            <param name="img">Image.</param>
            <param name="pt1">The point the arrow starts from.</param>
            <param name="pt2">The point the arrow points to.</param>
            <param name="color">Line color.</param>
            <param name="thickness">Line thickness.</param>
            <param name="lineType">Type of the line, see cv::LineTypes</param>
            <param name="shift">Number of fractional bits in the point coordinates.</param>
            <param name="tipLength">The length of the arrow tip in relation to the arrow length</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rectangle(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="img">Image. </param>
            <param name="pt1">One of the rectangle vertices. </param>
            <param name="pt2">Opposite rectangle vertex. </param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rectangle(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Rect,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="img">Image. </param>
            <param name="rect">Rectangle.</param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rectangle(OpenCv30Sharp.Mat,OpenCv30Sharp.Point,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="img">Image. </param>
            <param name="pt1">One of the rectangle vertices. </param>
            <param name="pt2">Opposite rectangle vertex. </param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Rectangle(OpenCv30Sharp.Mat,OpenCv30Sharp.Rect,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="img">Image. </param>
            <param name="rect">Rectangle.</param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Circle(OpenCv30Sharp.InputOutputArray,System.Int32,System.Int32,System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws a circle
            </summary>
            <param name="img">Image where the circle is drawn. </param>
            <param name="centerX">X-coordinate of the center of the circle. </param>
            <param name="centerY">Y-coordinate of the center of the circle. </param>
            <param name="radius">Radius of the circle. </param>
            <param name="color">Circle color. </param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn. [By default this is 1]</param>
            <param name="lineType">Type of the circle boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Circle(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws a circle
            </summary>
            <param name="img">Image where the circle is drawn. </param>
            <param name="center">Center of the circle. </param>
            <param name="radius">Radius of the circle. </param>
            <param name="color">Circle color. </param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn. [By default this is 1]</param>
            <param name="lineType">Type of the circle boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Ellipse(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Size,System.Double,System.Double,System.Double,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws simple or thick elliptic arc or fills ellipse sector
            </summary>
            <param name="img">Image. </param>
            <param name="center">Center of the ellipse. </param>
            <param name="axes">Length of the ellipse axes. </param>
            <param name="angle">Rotation angle. </param>
            <param name="startAngle">Starting angle of the elliptic arc. </param>
            <param name="endAngle">Ending angle of the elliptic arc. </param>
            <param name="color">Ellipse color. </param>
            <param name="thickness">Thickness of the ellipse arc. [By default this is 1]</param>
            <param name="lineType">Type of the ellipse boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Ellipse(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.RotatedRect,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes)">
            <summary>
            Draws simple or thick elliptic arc or fills ellipse sector
            </summary>
            <param name="img">Image. </param>
            <param name="box">The enclosing box of the ellipse drawn </param>
            <param name="color">Ellipse color. </param>
            <param name="thickness">Thickness of the ellipse boundary. [By default this is 1]</param>
            <param name="lineType">Type of the ellipse boundary. [By default this is LineType.Link8]</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FillConvexPoly(OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},OpenCv30Sharp.Scalar,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Fills a convex polygon.
            </summary>
            <param name="img">Image</param>
            <param name="pts">The polygon vertices</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FillConvexPoly(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Scalar,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Fills a convex polygon.
            </summary>
            <param name="img">Image</param>
            <param name="pts">The polygon vertices</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FillPoly(OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point}},OpenCv30Sharp.Scalar,OpenCv30Sharp.LineTypes,System.Int32,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Fills the area bounded by one or more polygons
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of polygons, each represented as an array of points</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
            <param name="offset"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.FillPoly(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.Scalar,OpenCv30Sharp.LineTypes,System.Int32,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Fills the area bounded by one or more polygons
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of polygons, each represented as an array of points</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
            <param name="offset"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Polylines(OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point}},System.Boolean,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            draws one or more polygonal curves
            </summary>
            <param name="img"></param>
            <param name="pts"></param>
            <param name="isClosed"></param>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="lineType"></param>
            <param name="shift"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Polylines(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray,System.Boolean,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            draws one or more polygonal curves
            </summary>
            <param name="img"></param>
            <param name="pts"></param>
            <param name="isClosed"></param>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="lineType"></param>
            <param name="shift"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DrawContours(OpenCv30Sharp.InputOutputArray,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point}},System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Collections.Generic.IEnumerable{OpenCv30Sharp.HierarchyIndex},System.Int32,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            draws contours in the image
            </summary>
            <param name="image">Destination image.</param>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours.</param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative (for example, thickness=CV_FILLED ), 
            the contour interiors are drawn.</param>
            <param name="lineType">Line connectivity. </param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="maxLevel">Maximal level for drawn contours. If it is 0, only the specified contour is drawn. 
            If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, 
            all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account 
            when there is hierarchy available.</param>
            <param name="offset">Optional contour shift parameter. Shift all the drawn contours by the specified offset = (dx, dy)</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.DrawContours(OpenCv30Sharp.InputOutputArray,System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,OpenCv30Sharp.Mat,System.Int32,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            draws contours in the image
            </summary>
            <param name="image">Destination image.</param>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours.</param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative (for example, thickness=CV_FILLED ), 
            the contour interiors are drawn.</param>
            <param name="lineType">Line connectivity. </param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="maxLevel">Maximal level for drawn contours. If it is 0, only the specified contour is drawn. 
            If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, 
            all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account 
            when there is hierarchy available.</param>
            <param name="offset">Optional contour shift parameter. Shift all the drawn contours by the specified offset = (dx, dy)</param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ClipLine(OpenCv30Sharp.Size,OpenCv30Sharp.Point@,OpenCv30Sharp.Point@)">
            <summary>
            Clips the line against the image rectangle
            </summary>
            <param name="imgSize">The image size</param>
            <param name="pt1">The first line point</param>
            <param name="pt2">The second line point</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.ClipLine(OpenCv30Sharp.Rect,OpenCv30Sharp.Point@,OpenCv30Sharp.Point@)">
            <summary>
            Clips the line against the image rectangle
            </summary>
            <param name="imgRect">sThe image rectangle</param>
            <param name="pt1">The first line point</param>
            <param name="pt2">The second line point</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.Ellipse2Poly(OpenCv30Sharp.Point,OpenCv30Sharp.Size,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Approximates an elliptic arc with a polyline.
            The function ellipse2Poly computes the vertices of a polyline that 
            approximates the specified elliptic arc. It is used by cv::ellipse.
            </summary>
            <param name="center">Center of the arc.</param>
            <param name="axes">Half of the size of the ellipse main axes. See the ellipse for details.</param>
            <param name="angle">Rotation angle of the ellipse in degrees. See the ellipse for details.</param>
            <param name="arcStart">Starting angle of the elliptic arc in degrees.</param>
            <param name="arcEnd">Ending angle of the elliptic arc in degrees.</param>
            <param name="delta">Angle between the subsequent polyline vertices. It defines the approximation</param>
            <returns>Output vector of polyline vertices.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.PutText(OpenCv30Sharp.InputOutputArray,System.String,OpenCv30Sharp.Point,OpenCv30Sharp.HersheyFonts,System.Double,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Boolean)">
            <summary>
            renders text string in the image
            </summary>
            <param name="img"></param>
            <param name="text"></param>
            <param name="org"></param>
            <param name="fontFace"></param>
            <param name="fontScale"></param>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="lineType"></param>
            <param name="bottomLeftOrigin"></param>
        </member>
        <member name="M:OpenCv30Sharp.Cv2.GetTextSize(System.String,OpenCv30Sharp.HersheyFonts,System.Double,System.Int32,System.Int32@)">
            <summary>
            returns bounding box of the text string
            </summary>
            <param name="text"></param>
            <param name="fontFace"></param>
            <param name="fontScale"></param>
            <param name="thickness"></param>
            <param name="baseLine"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.MatProxy">
            <summary>
            DebuggrVisualizerにおいて、シリアライズ不可能なクラスをやり取りするために使うプロキシ。
            送る際に、このProxyに表示に必要なシリアライズ可能なデータを詰めて送り、受信側で復元する。
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatProxy.ImageData">
            <summary>
            画像をエンコードしたデータ
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatProxy.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            初期化
            </summary>
            <param name="image"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatProxy.Dispose">
            <summary>
            リソースの解放
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatProxy.CreateBitmapStream">
            <summary>
            ImageDataをストリームにして返す
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.CriteriaType">
            <summary>
            Type of termination criteria 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CriteriaType.Count">
            <summary>
            the maximum number of iterations or elements to compute
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CriteriaType.MaxIter">
            <summary>
            the maximum number of iterations or elements to compute
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CriteriaType.Eps">
            <summary>
            the desired accuracy or change in parameters at which the iterative algorithm stops
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.OutputArrayOfMatList">
            <summary>
            Proxy datatype for passing Mat's and List&lt;&gt;'s as output parameters
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OutputArrayOfMatList.#ctor(System.Collections.Generic.List{OpenCv30Sharp.Mat})">
            <summary>
            
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:OpenCv30Sharp.OutputArrayOfMatList.GetVectorOfMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArrayOfMatList.AssignResult">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OutputArrayOfMatList.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:OpenCv30Sharp.OutputArrayOfStructList`1">
            <summary>
            Proxy datatype for passing Mat's and List&lt;&gt;'s as output parameters
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OutputArrayOfStructList`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:OpenCv30Sharp.OutputArrayOfStructList`1.AssignResult">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OutputArrayOfStructList`1.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:OpenCv30Sharp.AgastFeatureDetector">
            <summary>
            Detects corners using the AGAST algorithm
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.AgastFeatureDetector.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.AgastFeatureDetector.Create(System.Int32,System.Boolean,OpenCv30Sharp.AGASTType)">
            <summary>
            The AgastFeatureDetector constructor
            </summary>
            <param name="threshold">threshold on difference between intensity of the central pixel 
            and pixels of a circle around this pixel.</param>
            <param name="nonmaxSuppression">if true, non-maximum suppression is applied to detected corners (keypoints).</param>
            <param name="type"></param>
        </member>
        <member name="M:OpenCv30Sharp.AgastFeatureDetector.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.AgastFeatureDetector.Threshold">
            <summary>
            threshold on difference between intensity of the central pixel and pixels of a circle around this pixel.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.AgastFeatureDetector.NonmaxSuppression">
            <summary>
            if true, non-maximum suppression is applied to detected corners (keypoints).
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.AgastFeatureDetector.Type">
            <summary>
            type one of the four neighborhoods as defined in the paper
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.BOWImgDescriptorExtractor">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.#ctor(OpenCv30Sharp.Feature2D,OpenCv30Sharp.DescriptorMatcher)">
            <summary>
            The constructor.
            </summary>
            <param name="dextractor">Descriptor extractor that is used to compute descriptors for an input image and its keypoints.</param>
            <param name="dmatcher">Descriptor matcher that is used to find the nearest word of the trained vocabulary for each keypoint descriptor of the image.</param>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.#ctor(OpenCv30Sharp.DescriptorMatcher)">
            <summary>
            The constructor.
            </summary>
            <param name="dmatcher">Descriptor matcher that is used to find the nearest word of the trained vocabulary for each keypoint descriptor of the image.</param>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.SetVocabulary(OpenCv30Sharp.Mat)">
            <summary>
            Sets a visual vocabulary.
            </summary>
            <param name="vocabulary">Vocabulary (can be trained using the inheritor of BOWTrainer ). 
            Each row of the vocabulary is a visual word(cluster center).</param>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.GetVocabulary">
            <summary>
            Returns the set vocabulary.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.Compute(OpenCv30Sharp.InputArray,OpenCv30Sharp.KeyPoint[]@,OpenCv30Sharp.OutputArray,System.Int32[][]@,OpenCv30Sharp.Mat)">
            <summary>
            Computes an image descriptor using the set visual vocabulary.
            </summary>
            <param name="image">Image, for which the descriptor is computed.</param>
            <param name="keypoints">Keypoints detected in the input image.</param>
            <param name="imgDescriptor">Computed output image descriptor.</param>
            <param name="pointIdxsOfClusters">pointIdxsOfClusters Indices of keypoints that belong to the cluster. 
            This means that pointIdxsOfClusters[i] are keypoint indices that belong to the i -th cluster(word of vocabulary) returned if it is non-zero.</param>
            <param name="descriptors">Descriptors of the image keypoints that are returned if they are non-zero.</param>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.Compute(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32[][]@)">
            <summary>
            Computes an image descriptor using the set visual vocabulary.
            </summary>
            <param name="keypointDescriptors">Computed descriptors to match with vocabulary.</param>
            <param name="imgDescriptor">Computed output image descriptor.</param>
            <param name="pointIdxsOfClusters">Indices of keypoints that belong to the cluster. 
            This means that pointIdxsOfClusters[i] are keypoint indices that belong to the i -th cluster(word of vocabulary) returned if it is non-zero.</param>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.Compute2(OpenCv30Sharp.Mat,OpenCv30Sharp.KeyPoint[]@,OpenCv30Sharp.Mat)">
            <summary>
            Computes an image descriptor using the set visual vocabulary.
            </summary>
            <param name="image">Image, for which the descriptor is computed.</param>
            <param name="keypoints">Keypoints detected in the input image.</param>
            <param name="imgDescriptor">Computed output image descriptor.</param>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.DescriptorSize">
            <summary>
            Returns an image descriptor size if the vocabulary is set. Otherwise, it returns 0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BOWImgDescriptorExtractor.DescriptorType">
            <summary>
            Returns an image descriptor type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.BOWKMeansTrainer">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BOWKMeansTrainer.#ctor(System.Int32,System.Nullable{OpenCv30Sharp.TermCriteria},System.Int32,OpenCv30Sharp.KMeansFlags)">
            <summary>
            
            </summary>
            <param name="clusterCount"></param>
            <param name="termcrit"></param>
            <param name="attempts"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.BOWKMeansTrainer.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.BOWKMeansTrainer.Cluster">
            <summary>
            Clusters train descriptors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BOWKMeansTrainer.Cluster(OpenCv30Sharp.Mat)">
            <summary>
            Clusters train descriptors.
            </summary>
            <param name="descriptors">Descriptors to cluster. Each row of the descriptors matrix is a descriptor. Descriptors are not added to the inner train descriptor set.
            The vocabulary consists of cluster centers. So, this method returns the vocabulary. In the first variant of the method, train descriptors stored in the object 
            are clustered.In the second variant, input descriptors are clustered.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.BOWTrainer">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BOWTrainer.Add(OpenCv30Sharp.Mat)">
            <summary>
            Adds descriptors to a training set.
            </summary>
            <param name="descriptors">descriptors Descriptors to add to a training set. Each row of the descriptors matrix is a descriptor.
            The training set is clustered using clustermethod to construct the vocabulary.</param>
        </member>
        <member name="M:OpenCv30Sharp.BOWTrainer.GetDescriptors">
            <summary>
            Returns a training set of descriptors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BOWTrainer.DescriptorsCount">
            <summary>
            Returns the count of all descriptors stored in the training set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BOWTrainer.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BOWTrainer.Cluster">
            <summary>
            Clusters train descriptors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BOWTrainer.Cluster(OpenCv30Sharp.Mat)">
            <summary>
            Clusters train descriptors.
            </summary>
            <param name="descriptors">Descriptors to cluster. Each row of the descriptors matrix is a descriptor. Descriptors are not added to the inner train descriptor set.
            The vocabulary consists of cluster centers. So, this method returns the vocabulary. In the first variant of the method, train descriptors stored in the object 
            are clustered.In the second variant, input descriptors are clustered.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.KeyPointsFilter">
            <summary>
            A class filters a vector of keypoints.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.KeyPointsFilter.RunByImageBorder(System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint},OpenCv30Sharp.Size,System.Int32)">
            <summary>
            Remove keypoints within borderPixels of an image edge.
            </summary>
            <param name="keypoints"></param>
            <param name="imageSize"></param>
            <param name="borderSize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.KeyPointsFilter.RunByKeypointSize(System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint},System.Single,System.Single)">
            <summary>
            Remove keypoints of sizes out of range.
            </summary>
            <param name="keypoints"></param>
            <param name="minSize"></param>
            <param name="maxSize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.KeyPointsFilter.RunByPixelsMask(System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint},OpenCv30Sharp.Mat)">
            <summary>
            Remove keypoints from some image by mask for pixels of this image.
            </summary>
            <param name="keypoints"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.KeyPointsFilter.RemoveDuplicated(System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint})">
            <summary>
            Remove duplicated keypoints.
            </summary>
            <param name="keypoints"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.KeyPointsFilter.RetainBest(System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint},System.Int32)">
            <summary>
            Retain the specified number of the best keypoints (according to the response)
            </summary>
            <param name="keypoints"></param>
            <param name="npoints"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.FASTType">
            <summary>
            AGAST type one of the four neighborhoods as defined in the paper
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.AGASTType">
            <summary>
            AGAST type one of the four neighborhoods as defined in the paper
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.AKAZEDescriptorType">
            <summary>
            cv::AKAZE descriptor type
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.AKAZEDescriptorType.KAZEUpright">
            <summary>
            Upright descriptors, not invariant to rotation
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.AKAZEDescriptorType.KAZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.AKAZEDescriptorType.MLDBUpright">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.AKAZEDescriptorType.MLDB">
            <summary>
            Upright descriptors, not invariant to rotation
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.KAZEDiffusivity">
            <summary>
            cv::KAZE diffusivity type
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KAZEDiffusivity.DiffPmG1">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KAZEDiffusivity.DiffPmG2">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KAZEDiffusivity.DiffWeickert">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KAZEDiffusivity.DiffCharbonnier">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.AKAZE">
            <summary>
            Class implementing the AKAZE keypoint detector and descriptor extractor, 
            described in @cite ANB13
            </summary>
            <remarks>
            AKAZE descriptors can only be used with KAZE or AKAZE keypoints. 
            Try to avoid using *extract* and *detect* instead of *operator()* due to performance reasons. 
            .. [ANB13] Fast Explicit Diffusion for Accelerated Features in Nonlinear Scale 
            Spaces. Pablo F. Alcantarilla, Jesús Nuevo and Adrien Bartoli. 
            In British Machine Vision Conference (BMVC), Bristol, UK, September 2013.
            </remarks>
        </member>
        <member name="M:OpenCv30Sharp.AKAZE.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.AKAZE.Create(OpenCv30Sharp.AKAZEDescriptorType,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,OpenCv30Sharp.KAZEDiffusivity)">
            <summary>
            The AKAZE constructor
            </summary>
            <param name="descriptorType"></param>
            <param name="descriptorSize"></param>
            <param name="descriptorChannels"></param>
            <param name="threshold"></param>
            <param name="nOctaves"></param>
            <param name="nOctaveLayers"></param>
            <param name="diffusivity"></param>
        </member>
        <member name="M:OpenCv30Sharp.AKAZE.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.AKAZE.AKAZEDescriptorType">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.AKAZE.AKAZEDescriptorSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.AKAZE.AKAZEDescriptorChannels">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.AKAZE.Threshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.AKAZE.NOctaves">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.AKAZE.NOctaveLayers">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.AKAZE.Diffusivity">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.KAZE">
            <summary>
            Class implementing the KAZE keypoint detector and descriptor extractor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.KAZE.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.KAZE.Create(System.Boolean,System.Boolean,System.Single,System.Int32,System.Int32,OpenCv30Sharp.KAZEDiffusivity)">
            <summary>
            The KAZE constructor
            </summary>
            <param name="extended">Set to enable extraction of extended (128-byte) descriptor.</param>
            <param name="upright">Set to enable use of upright descriptors (non rotation-invariant).</param>
            <param name="threshold">Detector response threshold to accept point</param>
            <param name="nOctaves">Maximum octave evolution of the image</param>
            <param name="nOctaveLayers">Default number of sublevels per scale level</param>
            <param name="diffusivity">Diffusivity type. DIFF_PM_G1, DIFF_PM_G2, DIFF_WEICKERT or DIFF_CHARBONNIER</param>
        </member>
        <member name="M:OpenCv30Sharp.KAZE.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.KAZE.Diffusivity">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KAZE.Extended">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KAZE.NOctaveLayers">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KAZE.NOctaves">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KAZE.Threshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KAZE.Upright">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ConvertImageModes">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ConvertImageModes.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ConvertImageModes.Flip">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ConvertImageModes.SwapRB">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.GeneralizedHoughGuil">
            <summary>
            Guil, N., González-Linares, J.M. and Zapata, E.L. (1999). 
            Bidimensional shape detection using an invariant approach. 
            Pattern Recognition 32 (6): 1025-1038.
            Detects position, traslation and rotation
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GeneralizedHoughGuil.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt; object
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHoughGuil.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHoughGuil.Create">
            <summary>
            Creates a predefined GeneralizedHoughBallard object
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHoughGuil.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.Xi">
            <summary>
            Angle difference in degrees between two points in feature.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.Levels">
            <summary>
            Feature table levels.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.AngleEpsilon">
            <summary>
            Maximal difference between angles that treated as equal.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.MinAngle">
            <summary>
            Minimal rotation angle to detect in degrees.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.MaxAngle">
            <summary>
            Maximal rotation angle to detect in degrees.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.AngleStep">
            <summary>
            Angle step in degrees.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.AngleThresh">
            <summary>
            Angle votes threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.MinScale">
            <summary>
            Minimal scale to detect.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.MaxScale">
            <summary>
            Maximal scale to detect.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.ScaleStep">
            <summary>
            Scale step.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.ScaleThresh">
            <summary>
            Scale votes threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughGuil.PosThresh">
            <summary>
            Position votes threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.GeneralizedHoughBallard">
            <summary>
            Ballard, D.H. (1981). Generalizing the Hough transform to detect arbitrary shapes. 
            Pattern Recognition 13 (2): 111-122.
            Detects position only without traslation and rotation
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GeneralizedHoughBallard.ptrObj">
            <summary>
            cv::Ptr&lt;T&gt; object
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHoughBallard.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHoughBallard.Create">
            <summary>
            Creates a predefined GeneralizedHoughBallard object
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHoughBallard.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughBallard.Levels">
            <summary>
            R-Table levels.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHoughBallard.VotesThreshold">
            <summary>
            The accumulator threshold for the template centers at the detection stage. 
            The smaller it is, the more false positions may be detected.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.GeneralizedHough">
            <summary>
            finds arbitrary template in the grayscale image using Generalized Hough Transform
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHough.CannyLowThresh">
            <summary>
            Canny low threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHough.CannyHighThresh">
            <summary>
            Canny high threshold.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHough.MinDist">
            <summary>
            Minimum distance between the centers of the detected objects.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHough.Dp">
            <summary>
            Inverse ratio of the accumulator resolution to the image resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.GeneralizedHough.MaxBufferSize">
            <summary>
            Maximal size of inner buffers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHough.SetTemplate(OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            set template to search
            </summary>
            <param name="templ"></param>
            <param name="templCenter"></param>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHough.SetTemplate(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            set template to search
            </summary>
            <param name="edges"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <param name="templCenter"></param>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHough.Detect(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            find template on image
            </summary>
            <param name="image"></param>
            <param name="positions"></param>
            <param name="votes"></param>
        </member>
        <member name="M:OpenCv30Sharp.GeneralizedHough.Detect(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            find template on image
            </summary>
            <param name="edges"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <param name="positions"></param>
            <param name="votes"></param>
        </member>
        <member name="T:OpenCv30Sharp.LineSegmentDetectorModes">
            <summary>
            Variants of Line Segment %Detector
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineSegmentDetectorModes.RefineNone">
            <summary>
            No refinement applied
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineSegmentDetectorModes.RefineStd">
            <summary>
            Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineSegmentDetectorModes.RefineAdv">
            <summary>
            Advanced refinement. Number of false alarms is calculated, lines are
            refined through increase of precision, decrement in size, etc.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.LineSegmentDetector">
            <summary>
            Line segment detector class
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineSegmentDetector.ptrObj">
            <summary>
            cv::Ptr&lt;LineSegmentDetector&gt;
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentDetector.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentDetector.Create(OpenCv30Sharp.LineSegmentDetectorModes,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Creates a smart pointer to a LineSegmentDetector object and initializes it.
            </summary>
            <param name="refine">The way found lines will be refined, see cv::LineSegmentDetectorModes</param>
            <param name="scale">The scale of the image that will be used to find the lines. Range (0..1].</param>
            <param name="sigmaScale">Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale.</param>
            <param name="quant">Bound to the quantization error on the gradient norm.</param>
            <param name="angTh">Gradient angle tolerance in degrees.</param>
            <param name="logEps">Detection threshold: -log10(NFA) \> log_eps. 
            Used only when advancent refinement is chosen.</param>
            <param name="densityTh">Minimal density of aligned region points in the enclosing rectangle.</param>
            <param name="nBins">Number of bins in pseudo-ordering of gradient modulus.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentDetector.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentDetector.Detect(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Finds lines in the input image.
            This is the output of the default parameters of the algorithm on the above shown image.
            </summary>
            <param name="image">A grayscale (CV_8UC1) input image. </param>
            <param name="lines">A vector of Vec4i or Vec4f elements specifying the beginning and ending point of a line. 
            Where Vec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly oriented depending on the gradient.</param>
            <param name="width">Vector of widths of the regions, where the lines are found. E.g. Width of line.</param>
            <param name="prec">Vector of precisions with which the lines are found.</param>
            <param name="nfa">Vector containing number of false alarms in the line region, 
            with precision of 10%. The bigger the value, logarithmically better the detection.</param>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentDetector.Detect(OpenCv30Sharp.InputArray,OpenCv30Sharp.Vec4f[]@,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>
            Finds lines in the input image.
            This is the output of the default parameters of the algorithm on the above shown image.
            </summary>
            <param name="image">A grayscale (CV_8UC1) input image. </param>
            <param name="lines">A vector of Vec4i or Vec4f elements specifying the beginning and ending point of a line. 
            Where Vec4i/Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end. Returned lines are strictly oriented depending on the gradient.</param>
            <param name="width">Vector of widths of the regions, where the lines are found. E.g. Width of line.</param>
            <param name="prec">Vector of precisions with which the lines are found.</param>
            <param name="nfa">Vector containing number of false alarms in the line region, 
            with precision of 10%. The bigger the value, logarithmically better the detection.</param>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentDetector.DrawSegments(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            Draws the line segments on a given image.
            </summary>
            <param name="image">The image, where the liens will be drawn. 
            Should be bigger or equal to the image, where the lines were found.</param>
            <param name="lines">A vector of the lines that needed to be drawn.</param>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentDetector.CompareSegments(OpenCv30Sharp.Size,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray)">
            <summary>
            Draws two groups of lines in blue and red, counting the non overlapping (mismatching) pixels.
            </summary>
            <param name="size">The size of the image, where lines1 and lines2 were found.</param>
            <param name="lines1">The first group of lines that needs to be drawn. It is visualized in blue color.</param>
            <param name="lines2">The second group of lines. They visualized in red color.</param>
            <param name="image">Optional image, where the lines will be drawn. 
            The image should be color(3-channel) in order for lines1 and lines2 to be drawn 
            in the above mentioned colors.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.CLAHE">
            <summary>
            Contrast Limited Adaptive Histogram Equalization
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CLAHE.ptrObj">
            <summary>
            cv::Ptr&lt;CLAHE&gt;
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CLAHE.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CLAHE.Create(System.Double,System.Nullable{OpenCv30Sharp.Size})">
            <summary>
            Creates a predefined CLAHE object
            </summary>
            <param name="clipLimit"></param>
            <param name="tileGridSize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.CLAHE.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.CLAHE.Apply(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.CLAHE.SetClipLimit(System.Double)">
            <summary>
            
            </summary>
            <param name="clipLimit"></param>
        </member>
        <member name="M:OpenCv30Sharp.CLAHE.GetClipLimit">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.CLAHE.ClipLimit">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CLAHE.SetTilesGridSize(OpenCv30Sharp.Size)">
            <summary>
            
            </summary>
            <param name="tileGridSize"></param>
        </member>
        <member name="M:OpenCv30Sharp.CLAHE.GetTilesGridSize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.CLAHE.TilesGridSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CLAHE.CollectGarbage">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CvObject">
            <summary>
            A class which has a pointer of OpenCV structure
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CvObject.ptr">
            <summary>
            Data pointer
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CvObject.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CvObject.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="P:OpenCv30Sharp.CvObject.CvPtr">
            <summary>
            Native pointer of OpenCV structure
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CvErrorCallback">
            <summary>
            Error Handler
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
            <param name="userdata">Pointer to the user data. Ignored by the standard handlers</param>
        </member>
        <member name="T:OpenCv30Sharp.CvMouseCallback">
            <summary>
            Delegate to be called every time mouse event occurs in the specified window.
            </summary>
            <param name="event">one of CV_EVENT_</param>
            <param name="x">x-coordinates of mouse pointer in image coordinates</param>
            <param name="y">y-coordinates of mouse pointer in image coordinates</param>
            <param name="flags">a combination of CV_EVENT_FLAG</param>
        </member>
        <member name="T:OpenCv30Sharp.CvTrackbarCallback">
            <summary>
            Delegate to be called every time the slider changes the position.
            </summary>
            <param name="pos"></param>
        </member>
        <member name="T:OpenCv30Sharp.CvTrackbarCallback2">
            <summary>
            Delegate to be called every time the slider changes the position.
            </summary>
            <param name="pos"></param>
            <param name="userdata"></param>
        </member>
        <member name="T:OpenCv30Sharp.CvTrackbarCallback2Native">
            <summary>
            
            </summary>
            <param name="pos"></param>
            <param name="userdata"></param>
        </member>
        <member name="T:OpenCv30Sharp.DisposableCvObject">
            <summary>
            DisposableObject + ICvPtrHolder
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DisposableCvObject.ptr">
            <summary>
            Data pointer
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DisposableCvObject.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DisposableCvObject.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DisposableCvObject.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.DisposableCvObject.#ctor(System.Boolean)">
            <summary>
             
            </summary>
            <param name="isEnabledDispose"></param>
        </member>
        <member name="M:OpenCv30Sharp.DisposableCvObject.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
            <param name="isEnabledDispose"></param>
        </member>
        <member name="M:OpenCv30Sharp.DisposableCvObject.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.DisposableCvObject.CvPtr">
            <summary>
            Native pointer of OpenCV structure
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DisposableObject">
            <summary>
            Represents a class which manages its own memory. 
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DisposableObject.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DisposableObject.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="isEnabledDispose">true if you permit disposing this class by GC</param>
        </member>
        <member name="M:OpenCv30Sharp.DisposableObject.Dispose">
            <summary>
            Releases the resources
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DisposableObject.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.DisposableObject.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.DisposableObject.IsDisposed">
            <summary>
            Gets a value indicating whether this instance has been disposed.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.DisposableObject.IsEnabledDispose">
            <summary>
            Gets or sets a value indicating whether you permit disposing this instance.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DisposableObject.dataHandle">
            <summary>
            Gets or sets a handle which allocates using cvSetData.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.DisposableObject.AllocatedMemory">
            <summary>
            Gets or sets a memory address allocated by AllocMemory.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.DisposableObject.AllocatedMemorySize">
            <summary>
            Gets or sets the byte length of the allocated memory
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DisposableObject.AllocGCHandle(System.Object)">
            <summary>
            Pins the object to be allocated by cvSetData.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DisposableObject.AllocMemory(System.Int32)">
            <summary>
            Allocates the specified size of memory.
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DisposableObject.NotifyMemoryPressure(System.Int64)">
            <summary>
            Notifies the allocated size of memory.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.DisposableObject.ThrowIfDisposed">
            <summary>
            If this object is disposed, then ObjectDisposedException is thrown.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ConnectedComponents">
            <summary>
            connected components that is returned from Cv2.ConnectedComponentsEx
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Blobs">
            <summary>
            All blobs
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Labels">
            <summary>
            destination labeled value
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.LabelCount">
            <summary>
            The number of labels -1
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ConnectedComponents.#ctor(System.Collections.Generic.IList{OpenCv30Sharp.ConnectedComponents.Blob},System.Int32[0:,0:],System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="blobs"></param>
            <param name="labels"></param>
            <param name="labelCount"></param>
        </member>
        <member name="M:OpenCv30Sharp.ConnectedComponents.FilterByLabel(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Int32)">
            <summary>
            Filter a image with the specified label value. 
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="labelValue">Label value.</param>
            <returns>Filtered image.</returns>
        </member>
        <member name="M:OpenCv30Sharp.ConnectedComponents.FilterByLabels(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Filter a image with the specified label values. 
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="labelValues">Label values.</param>
            <returns>Filtered image.</returns>
        </member>
        <member name="M:OpenCv30Sharp.ConnectedComponents.FilterByBlob(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.ConnectedComponents.Blob)">
            <summary>
            Filter a image with the specified blob object. 
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="blob">Blob value.</param>
            <returns>Filtered image.</returns>
        </member>
        <member name="M:OpenCv30Sharp.ConnectedComponents.FilterBlobs(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Collections.Generic.IEnumerable{OpenCv30Sharp.ConnectedComponents.Blob})">
            <summary>
            Filter a image with the specified blob objects. 
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="blobs">Blob values.</param>
            <returns>Filtered image.</returns>
        </member>
        <member name="M:OpenCv30Sharp.ConnectedComponents.RenderBlobs(OpenCv30Sharp.Mat)">
            <summary>
            Draws all blobs to the specified image.
            </summary>
            <param name="img">The target image to be drawn.</param>
        </member>
        <member name="M:OpenCv30Sharp.ConnectedComponents.GetLargestBlob">
            <summary>
            Find the largest blob.
            </summary>
            <returns>the largest blob</returns>
        </member>
        <member name="M:OpenCv30Sharp.ConnectedComponents.GetLabelMask(System.Int32)">
            <summary>
            指定したラベル値のところのみを非0で残したマスク画像を返す
            </summary>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ConnectedComponents.Blob">
            <summary>
            One blob
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Blob.Label">
            <summary>
            Label value
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Blob.Centroid">
            <summary>
            Floating point centroid (x,y)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Blob.Left">
            <summary>
            The leftmost (x) coordinate which is the inclusive start of the bounding box in the horizontal direction.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Blob.Top">
            <summary>
            The topmost (y) coordinate which is the inclusive start of the bounding box in the vertical direction.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Blob.Width">
            <summary>
            The horizontal size of the bounding box.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Blob.Height">
            <summary>
            The vertical size of the bounding box.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Blob.Rect">
            <summary>
            The bounding box.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ConnectedComponents.Blob.Area">
            <summary>
            The total area (in pixels) of the connected component.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ConnectedComponentsTypes">
            <summary>
            components algorithm output formats
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ConnectedComponentsTypes.Left">
            <summary>
            The leftmost (x) coordinate which is the inclusive start of the bounding
            box in the horizontal direction.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ConnectedComponentsTypes.Top">
            <summary>
            The topmost (y) coordinate which is the inclusive start of the bounding
            box in the vertical direction.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ConnectedComponentsTypes.Width">
            <summary>
            The horizontal size of the bounding box
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ConnectedComponentsTypes.Height">
            <summary>
            The vertical size of the bounding box
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ConnectedComponentsTypes.Area">
            <summary>
            The total area (in pixels) of the connected component
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.GrabCutClasses">
            <summary>
            class of the pixel in GrabCut algorithm
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GrabCutClasses.BGD">
            <summary>
            an obvious background pixels
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GrabCutClasses.FGD">
            <summary>
            an obvious foreground (object) pixel
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GrabCutClasses.PR_BGD">
            <summary>
            a possible background pixel
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GrabCutClasses.PR_FGD">
            <summary>
            a possible foreground pixel
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.RectanglesIntersectTypes">
            <summary>
            types of intersection between rectangles
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RectanglesIntersectTypes.None">
            <summary>
            No intersection
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RectanglesIntersectTypes.Partial">
            <summary>
            There is a partial intersection
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RectanglesIntersectTypes.Full">
            <summary>
            One of the rectangle is fully enclosed in the other
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CircleSegment">
            <summary>
            circle structure retrieved from cvHoughCircle
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CircleSegment.Center">
            <summary>
            Center coordinate of the circle
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CircleSegment.Radius">
            <summary>
            Radius
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CircleSegment.#ctor(OpenCv30Sharp.Point2f,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="center">center</param>
            <param name="radius">radius</param>
        </member>
        <member name="M:OpenCv30Sharp.CircleSegment.Equals(OpenCv30Sharp.CircleSegment)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.CircleSegment.op_Equality(OpenCv30Sharp.CircleSegment,OpenCv30Sharp.CircleSegment)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.CircleSegment.op_Inequality(OpenCv30Sharp.CircleSegment,OpenCv30Sharp.CircleSegment)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.CircleSegment.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.CircleSegment.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.CircleSegment.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:OpenCv30Sharp.HierarchyIndex">
            <summary>
            Information about the image topology for cv::findContours
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HierarchyIndex.Next">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HierarchyIndex.Previous">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HierarchyIndex.Child">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HierarchyIndex.Parent">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.HierarchyIndex.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.HierarchyIndex.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="next"></param>
            <param name="previous"></param>
            <param name="child"></param>
            <param name="parent"></param>
        </member>
        <member name="M:OpenCv30Sharp.HierarchyIndex.FromVec4i(OpenCv30Sharp.Vec4i)">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.HierarchyIndex.ToVec4i">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Line2D">
            <summary>
            2-dimentional line vector
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line2D.Vx">
            <summary>
            The X component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line2D.Vy">
            <summary>
            The Y component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line2D.X1">
            <summary>
            X-coordinate of some point on the line
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line2D.Y1">
            <summary>
            Y-coordinate of some point on the line
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Line2D.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes this object
            </summary>
            <param name="vx">The X component of the normalized vector collinear to the line</param>
            <param name="vy">The Y component of the normalized vector collinear to the line</param>
            <param name="x1">Z-coordinate of some point on the line</param>
            <param name="y1">Z-coordinate of some point on the line</param>
        </member>
        <member name="M:OpenCv30Sharp.Line2D.#ctor(System.Single[])">
            <summary>
            Initializes by cvFitLine output 
            </summary>
            <param name="line">The returned value from cvFitLine</param>param>
        </member>
        <member name="M:OpenCv30Sharp.Line2D.GetVectorRadian">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Line2D.GetVectorAngle">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Line2D.Distance(OpenCv30Sharp.Point)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line2D.Distance(OpenCv30Sharp.Point2f)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line2D.Distance(OpenCv30Sharp.Point2d)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line2D.Distance(System.Double,System.Double)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line2D.FitSize(System.Int32,System.Int32,OpenCv30Sharp.Point@,OpenCv30Sharp.Point@)">
            <summary>
            Fits this line to the specified size (for drawing)
            </summary>
            <param name="width">Width of fit size</param>
            <param name="height">Height of fit size</param>
            <param name="pt1">1st edge point of fitted line</param>
            <param name="pt2">2nd edge point of fitted line</param>
        </member>
        <member name="T:OpenCv30Sharp.Line3D">
            <summary>
            A 3-dimensional line object
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line3D.Vx">
            <summary>
            The X component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line3D.Vy">
            <summary>
            The Y component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line3D.Vz">
            <summary>
            The Z component of the normalized vector collinear to the line
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line3D.X1">
            <summary>
            X-coordinate of some point on the line
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line3D.Y1">
            <summary>
            Y-coordinate of some point on the line
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Line3D.Z1">
            <summary>
            Z-coordinate of some point on the line
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializes this object
            </summary>
            <param name="vx">The X component of the normalized vector collinear to the line</param>
            <param name="vy">The Y component of the normalized vector collinear to the line</param>
            <param name="vz">The Z component of the normalized vector collinear to the line</param>
            <param name="x1">Z-coordinate of some point on the line</param>
            <param name="y1">Z-coordinate of some point on the line</param>
            <param name="z1">Z-coordinate of some point on the line</param>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.#ctor(System.Single[])">
            <summary>
            Initializes by cvFitLine output 
            </summary>
            <param name="line">The returned value from cvFitLine</param>param>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.PerpendicularFoot(OpenCv30Sharp.Point3f)">
            <summary>
            
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.PerpendicularFoot(OpenCv30Sharp.Point3d)">
            <summary>
            
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.PerpendicularFoot(System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.Distance(OpenCv30Sharp.Point3f)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.Distance(OpenCv30Sharp.Point3d)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="point"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.Distance(System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between this line and the specified point
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.CrossProduct(OpenCv30Sharp.Point3d,OpenCv30Sharp.Point3d)">
            <summary>
            ベクトルの外積
            </summary>
            <param name="vl"></param>
            <param name="vr"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.VectorLength(OpenCv30Sharp.Point3d)">
            <summary>
            ベクトルの長さ(原点からの距離)
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Line3D.VertexDistance(OpenCv30Sharp.Point3d,OpenCv30Sharp.Point3d)">
            <summary>
            2点間(2ベクトル)の距離
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.LineSegmentPoint">
            <summary>
            Line segment structure retrieved from cvHoughLines2
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineSegmentPoint.P1">
            <summary>
            1st Point
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineSegmentPoint.P2">
            <summary>
            2nd Point
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.#ctor(OpenCv30Sharp.Point,OpenCv30Sharp.Point)">
            <summary>
            Constructor
            </summary>
            <param name="p1">1st Point</param>
            <param name="p2">2nd Point</param>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.Equals(OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.op_Equality(OpenCv30Sharp.LineSegmentPoint,OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.op_Inequality(OpenCv30Sharp.LineSegmentPoint,OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.LineIntersection(OpenCv30Sharp.LineSegmentPoint,OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Calculates a intersection of the specified two lines
            </summary>
            <param name="line1"></param>
            <param name="line2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.LineIntersection(OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Calculates a intersection of the specified two lines
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.SegmentIntersection(OpenCv30Sharp.LineSegmentPoint,OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Calculates a intersection of the specified two segments
            </summary>
            <param name="seg1"></param>
            <param name="seg2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.SegmentIntersection(OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Calculates a intersection of the specified two segments
            </summary>
            <param name="seg"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.IntersectedSegments(OpenCv30Sharp.LineSegmentPoint,OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Returns a boolean value indicating whether the specified two segments intersect.
            </summary>
            <param name="seg1"></param>
            <param name="seg2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.IntersectedSegments(OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Returns a boolean value indicating whether the specified two segments intersect.
            </summary>
            <param name="seg"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.IntersectedLineAndSegment(OpenCv30Sharp.LineSegmentPoint,OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Returns a boolean value indicating whether a line and a segment intersect.
            </summary>
            <param name="line">Line</param>
            <param name="seg">Segment</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.LineAndSegmentIntersection(OpenCv30Sharp.LineSegmentPoint,OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            Calculates a intersection of a line and a segment
            </summary>
            <param name="line"></param>
            <param name="seg"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.Length(OpenCv30Sharp.LineSegmentPoint)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.Offset(System.Int32,System.Int32)">
            <summary>
            Translates the Point by the specified amount. 
            </summary>
            <param name="x">The amount to offset the x-coordinate. </param>
            <param name="y">The amount to offset the y-coordinate. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPoint.Offset(OpenCv30Sharp.Point)">
            <summary>
            Translates the Point by the specified amount. 
            </summary>
            <param name="p">The Point used offset this CvPoint.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.LineSegmentPolar">
            <summary>
            Polar line segment retrieved from cvHoughLines2
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineSegmentPolar.Rho">
            <summary>
            Length of the line
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineSegmentPolar.Theta">
            <summary>
            Angle of the line (radian)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.#ctor(System.Single,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="rho">Length of the line</param>
            <param name="theta">Angle of the line (radian)</param>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.Equals(OpenCv30Sharp.LineSegmentPolar)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.op_Equality(OpenCv30Sharp.LineSegmentPolar,OpenCv30Sharp.LineSegmentPolar)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.op_Inequality(OpenCv30Sharp.LineSegmentPolar,OpenCv30Sharp.LineSegmentPolar)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.LineIntersection(OpenCv30Sharp.LineSegmentPolar,OpenCv30Sharp.LineSegmentPolar)">
            <summary>
            Calculates a intersection of the specified two lines
            </summary>
            <param name="line1"></param>
            <param name="line2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.LineIntersection(OpenCv30Sharp.LineSegmentPolar)">
            <summary>
            Calculates a intersection of the specified two lines
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.ToSegmentPoint(System.Double)">
            <summary>
            CvLineSegmentPointに変換する
            </summary>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.ToSegmentPointX(System.Int32,System.Int32)">
            <summary>
            指定したx座標を両端とするような線分に変換する
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.ToSegmentPointY(System.Int32,System.Int32)">
            <summary>
            指定したy座標を両端とするような線分に変換する
            </summary>
            <param name="y1"></param>
            <param name="y2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.XPosOfLine(System.Int32)">
            <summary>
            指定したy座標を通るときのx座標を求める
            </summary>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineSegmentPolar.YPosOfLine(System.Int32)">
            <summary>
            指定したx座標を通るときのy座標を求める
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ML.LogisticRegression">
            <summary>
            Implements Logistic Regression classifier.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.LogisticRegression.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.LogisticRegression.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::LogisticRegression*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.LogisticRegression.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.LogisticRegression.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.ML.LogisticRegression.LearningRate">
            <summary>
            Learning rate
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.LogisticRegression.Iterations">
            <summary>
            Number of iterations.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.LogisticRegression.Regularization">
            <summary>
            Kind of regularization to be applied. See LogisticRegression::RegKinds.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.LogisticRegression.TrainMethod">
            <summary>
            Kind of training method used. See LogisticRegression::Methods.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.LogisticRegression.MiniBatchSize">
            <summary>
            Specifies the number of training samples taken in each step of Mini-Batch Gradient. 
            Descent. Will only be used if using LogisticRegression::MINI_BATCH training algorithm. 
            It has to take values less than the total number of training samples.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.LogisticRegression.TermCriteria">
            <summary>
            Termination criteria of the training algorithm.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.LogisticRegression.Predict(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            Predicts responses for input samples and returns a float type.
            </summary>
            <param name="samples">The input data for the prediction algorithm. Matrix [m x n], 
            where each row contains variables (features) of one object being classified. 
            Should have data type CV_32F.</param>
            <param name="results">Predicted labels as a column matrix of type CV_32S.</param>
            <param name="flags">Not used.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.LogisticRegression.GetLearntThetas">
            <summary>
            This function returns the trained paramters arranged across rows.
             For a two class classifcation problem, it returns a row matrix. 
            It returns learnt paramters of the Logistic Regression as a matrix of type CV_32F.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ML.LogisticRegression.RegKinds">
            <summary>
            Regularization kinds
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.LogisticRegression.RegKinds.RegDisable">
            <summary>
            Regularization disabled
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.LogisticRegression.RegKinds.RegL1">
            <summary>
            L1 norm
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.LogisticRegression.RegKinds.RegL2">
            <summary>
            L2 norm
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.LogisticRegression.Methods">
            <summary>
            Training methods
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.LogisticRegression.Methods.Batch">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.LogisticRegression.Methods.MiniBatch">
            <summary>
            Set MiniBatchSize to a positive integer when using this method.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.SampleTypes">
            <summary>
            Sample types
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SampleTypes.RowSample">
            <summary>
            each training sample is a row of samples
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SampleTypes.ColSample">
            <summary>
            each training sample occupies a column of samples
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.ParamGrid">
            <summary>
            The structure represents the logarithmic grid range of statmodel parameters.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ParamGrid.MinVal">
            <summary>
            Minimum value of the statmodel parameter. Default value is 0.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ParamGrid.MaxVal">
            <summary>
            Maximum value of the statmodel parameter. Default value is 0.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ParamGrid.LogStep">
            <summary>
            Logarithmic step for iterating the statmodel parameter.
            </summary>
            <remarks>
            The grid determines the following iteration sequence of the statmodel parameter values:
            \f[(minVal, minVal*step, minVal*{step}^2, \dots,  minVal*{logStep}^n),\f]
            where \f$n\f$ is the maximal index satisfying
            \f[\texttt{minVal} * \texttt{logStep} ^n &lt; \texttt{maxVal}\f]
            The grid is logarithmic, so logStep must always be greater then 1. Default value is 1.
            </remarks>
        </member>
        <member name="M:OpenCv30Sharp.ML.ParamGrid.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructor with parameters
            </summary>
            <param name="minVal"></param>
            <param name="maxVal"></param>
            <param name="logStep"></param>
        </member>
        <member name="T:OpenCv30Sharp.ML.TrainData">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.TrainData.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.Boost">
            <summary>
            Boosted tree classifier derived from DTrees
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.Boost.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.Boost.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::Boost*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.Boost.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.Boost.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.ML.Boost.BoostType">
            <summary>
            Type of the boosting algorithm.
            See Boost::Types. Default value is Boost::REAL.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.Boost.WeakCount">
            <summary>
            The number of weak classifiers. 
            Default value is 100.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.Boost.WeightTrimRate">
            <summary>
            A threshold between 0 and 1 used to save computational time. 
            Samples with summary weight \f$\leq 1 - weight_trim_rate
            do not participate in the *next* iteration of training. 
            Set this parameter to 0 to turn off this functionality. Default value is 0.95.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.Boost.Types">
            <summary>
            Boosting type.
            Gentle AdaBoost and Real AdaBoost are often the preferable choices.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.Boost.Types.Discrete">
            <summary>
            Discrete AdaBoost.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.Boost.Types.Real">
            <summary>
            Real AdaBoost. It is a technique that utilizes confidence-rated predictions
            and works well with categorical data.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.Boost.Types.Logit">
            <summary>
            LogitBoost. It can produce good regression fits.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.Boost.Types.Gentle">
            <summary>
            Gentle AdaBoost. It puts less weight on outlier data points and for that
            reason is often good with regression data.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.DTrees">
            <summary>
            Decision tree
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.DTrees.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.DTrees.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::SVM*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.DTrees.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.DTrees.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.ML.DTrees.MaxCategories">
            <summary>
            Cluster possible values of a categorical variable into 
            K &lt; =maxCategories clusters to find a suboptimal split.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.DTrees.MaxDepth">
            <summary>
            The maximum possible depth of the tree.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.DTrees.MinSampleCount">
            <summary>
            If the number of samples in a node is less than this parameter then the 
            node will not be split. Default value is 10.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.DTrees.CVFolds">
            <summary>
            If CVFolds \> 1 then algorithms prunes the built decision tree using K-fold 
            cross-validation procedure where K is equal to CVFolds. Default value is 10.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.DTrees.UseSurrogates">
            <summary>
            If true then surrogate splits will be built.
            These splits allow to work with missing data and compute variable 
            importance correctly. Default value is false.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.DTrees.Use1SERule">
            <summary>
            If true then a pruning will be harsher.
            This will make a tree more compact and more resistant to the training 
            data noise but a bit less accurate. Default value is true.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.DTrees.TruncatePrunedTree">
            <summary>
            If true then pruned branches are physically removed from the tree.
            Otherwise they are retained and it is possible to get results from the 
            original unpruned (or pruned less aggressively) tree. Default value is true.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.DTrees.RegressionAccuracy">
            <summary>
            Termination criteria for regression trees.
            If all absolute differences between an estimated value in a node and 
            values of train samples in this node are less than this parameter 
            then the node will not be split further. Default value is 0.01f.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.DTrees.Priors">
            <summary>
            The array of a priori class probabilities, sorted by the class label value.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.DTrees.GetRoots">
            <summary>
            Returns indices of root nodes
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.DTrees.GetNodes">
            <summary>
            Returns all the nodes. 
            all the node indices are indices in the returned vector
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.DTrees.GetSplits">
            <summary>
            Returns all the splits.
            all the split indices are indices in the returned vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.DTrees.GetSubsets">
            <summary>
            Returns all the bitsets for categorical splits.
            Split::subsetOfs is an offset in the returned vector
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ML.DTrees.Node">
            <summary>
            The class represents a decision tree node.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Node.Value">
            <summary>
            Value at the node: a class label in case of classification or estimated 
            function value in case of regression.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Node.ClassIdx">
            <summary>
            Class index normalized to 0..class_count-1 range and assigned to the 
            node. It is used internally in classification trees and tree ensembles.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Node.Parent">
            <summary>
            Index of the parent node
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Node.Left">
            <summary>
            Index of the left child node
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Node.Right">
            <summary>
            Index of right child node
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Node.DefaultDir">
            <summary>
            Default direction where to go (-1: left or +1: right). It helps in the
            case of missing values.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Node.Split">
            <summary>
            Index of the first split
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.DTrees.Split">
            <summary>
            The class represents split in a decision tree.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Split.VarIdx">
            <summary>
            Index of variable on which the split is created.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Split.Inversed">
            <summary>
            If not 0, then the inverse split rule is used (i.e. left and right
            branches are exchanged in the rule expressions below).
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Split.Quality">
            <summary>
            The split quality, a positive number. It is used to choose the best split.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Split.Next">
            <summary>
            Index of the next split in the list of splits for the node
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Split.C">
            <summary>
            The threshold value in case of split on an ordered variable.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.DTrees.Split.SubsetOfs">
            <summary>
            Offset of the bitset used by the split on a categorical variable.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.NormalBayesClassifier">
            <summary>
            Bayes classifier for normally distributed data
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.NormalBayesClassifier.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.NormalBayesClassifier.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::NormalBayesClassifier*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.NormalBayesClassifier.Create">
            <summary>
            Creates empty model. 
            Use StatModel::train to train the model after creation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.NormalBayesClassifier.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.ML.NormalBayesClassifier.PredictProb(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,System.Int32)">
            <summary>
            Predicts the response for sample(s).
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <param name="outputProbs"></param>
            <param name="flags"></param>
            <returns></returns>
            <remarks>
            The method estimates the most probable classes for input vectors. Input vectors (one or more)
            are stored as rows of the matrix inputs. In case of multiple input vectors, there should be one 
            output vector outputs. The predicted class for a single input vector is returned by the method. 
            The vector outputProbs contains the output probabilities corresponding to each element of result.
            </remarks>
        </member>
        <member name="T:OpenCv30Sharp.ML.RTrees">
            <summary>
            The class implements the random forest predictor.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.RTrees.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.RTrees.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::RTrees*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.RTrees.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.RTrees.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.ML.RTrees.CalculateVarImportance">
            <summary>
            If true then variable importance will be calculated and then 
            it can be retrieved by RTrees::getVarImportance. Default value is false.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.RTrees.ActiveVarCount">
            <summary>
            The size of the randomly selected subset of features at each tree node 
            and that are used to find the best split(s).
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.RTrees.TermCriteria">
            <summary>
            The termination criteria that specifies when the training algorithm stops.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.RTrees.GetVarImportance">
            <summary>
            Returns the variable importance array. 
            The method returns the variable importance vector, computed at the training 
            stage when CalculateVarImportance is set to true. If this flag was set to false, 
            the empty matrix is returned.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ML.KNearest">
            <summary>
            K nearest neighbors classifier
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.KNearest.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.KNearest.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::KNearest*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.KNearest.Create">
            <summary>
            Creates the empty model
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.KNearest.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.ML.KNearest.DefaultK">
            <summary>
            Default number of neighbors to use in predict method.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.KNearest.IsClassifier">
            <summary>
            Whether classification or regression model should be trained.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.KNearest.Emax">
            <summary>
            Parameter for KDTree implementation
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.KNearest.AlgorithmType">
            <summary>
            Algorithm type, one of KNearest::Types.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.KNearest.FindNearest(OpenCv30Sharp.InputArray,System.Int32,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Finds the neighbors and predicts responses for input vectors.
            </summary>
            <param name="samples">Input samples stored by rows. 
            It is a single-precision floating-point matrix of `[number_of_samples] * k` size.</param>
            <param name="k">Number of used nearest neighbors. Should be greater than 1.</param>
            <param name="results">Vector with results of prediction (regression or classification) for each 
            input sample. It is a single-precision floating-point vector with `[number_of_samples]` elements.</param>
            <param name="neighborResponses">neighborResponses Optional output values for corresponding neighbors. 
            It is a single-precision floating-point matrix of `[number_of_samples] * k` size.</param>
            <param name="dist">Optional output distances from the input vectors to the corresponding neighbors. 
            It is a single-precision floating-point matrix of `[number_of_samples] * k` size.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ML.KNearest.Types">
            <summary>
            Implementations of KNearest algorithm
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.SVM">
            <summary>
            Support Vector Machines
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.SVM.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::SVM*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.SVM.Create">
            <summary>
            Creates empty model.
            Use StatModel::Train to train the model. 
            Since %SVM has several parameters, you may want to find the best 
            parameters for your problem, it can be done with SVM::TrainAuto.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.SVM.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.Type">
            <summary>
            Type of a %SVM formulation. 
            Default value is SVM::C_SVC.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.Gamma">
            <summary>
            Parameter gamma of a kernel function.
            For SVM::POLY, SVM::RBF, SVM::SIGMOID or SVM::CHI2. Default value is 1. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.Coef0">
            <summary>
            Parameter coef0 of a kernel function.
            For SVM::POLY or SVM::SIGMOID. Default value is 0.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.Degree">
            <summary>
            Parameter degree of a kernel function.
            For SVM::POLY. Default value is 0.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.C">
            <summary>
            Parameter C of a %SVM optimization problem.
            For SVM::C_SVC, SVM::EPS_SVR or SVM::NU_SVR. Default value is 0.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.Nu">
            <summary>
            Parameter nu of a %SVM optimization problem.
            For SVM::NU_SVC, SVM::ONE_CLASS or SVM::NU_SVR. Default value is 0.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.P">
            <summary>
            Parameter epsilon of a %SVM optimization problem.
            For SVM::EPS_SVR. Default value is 0.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.ClassWeights">
            <summary>
            Optional weights in the SVM::C_SVC problem, assigned to particular classes.
            </summary>
            <remarks>
            They are multiplied by _C_ so the parameter _C_ of class _i_ becomes `classWeights(i) * C`. 
            Thus these weights affect the misclassification penalty for different classes. 
            The larger weight, the larger penalty on misclassification of data from the 
            corresponding class. Default value is empty Mat.
            </remarks>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.TermCriteria">
            <summary>
            Termination criteria of the iterative SVM training procedure 
            which solves a partial case of constrained quadratic optimization problem.
            </summary>
            <remarks>
            You can specify tolerance and/or the maximum number of iterations. 
            Default value is `TermCriteria( TermCriteria::MAX_ITER + TermCriteria::EPS, 1000, FLT_EPSILON )`;
            </remarks>
        </member>
        <member name="P:OpenCv30Sharp.ML.SVM.KernelType">
            <summary>
            Type of a %SVM kernel. See SVM::KernelTypes. Default value is SVM::RBF.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.SVM.SetCustomKernel(OpenCv30Sharp.ML.SVM.Kernel)">
            <summary>
            Initialize with custom kernel.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:OpenCv30Sharp.ML.SVM.TrainAuto(OpenCv30Sharp.ML.TrainData,System.Int32,System.Nullable{OpenCv30Sharp.ML.ParamGrid},System.Nullable{OpenCv30Sharp.ML.ParamGrid},System.Nullable{OpenCv30Sharp.ML.ParamGrid},System.Nullable{OpenCv30Sharp.ML.ParamGrid},System.Nullable{OpenCv30Sharp.ML.ParamGrid},System.Nullable{OpenCv30Sharp.ML.ParamGrid},System.Boolean)">
            <summary>
            Trains an %SVM with optimal parameters.
            </summary>
            <param name="data">the training data that can be constructed using 
            TrainData::create or TrainData::loadFromCSV.</param>
            <param name="kFold">Cross-validation parameter. The training set is divided into kFold subsets. 
            One subset is used to test the model, the others form the train set. So, the %SVM algorithm is 
            executed kFold times.</param>
            <param name="cGrid">grid for C</param>
            <param name="gammaGrid">grid for gamma</param>
            <param name="pGrid">grid for p</param>
            <param name="nuGrid">grid for nu</param>
            <param name="coeffGrid">grid for coeff</param>
            <param name="degreeGrid">grid for degree</param>
            <param name="balanced">If true and the problem is 2-class classification then the method creates 
            more balanced cross-validation subsets that is proportions between classes in subsets are close 
            to such proportion in the whole train dataset.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.SVM.GetSupportVectors">
            <summary>
            Retrieves all the support vectors
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.SVM.GetDecisionFunction(System.Int32,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Retrieves the decision function
            </summary>
            <param name="i">i the index of the decision function. 
            If the problem solved is regression, 1-class or 2-class classification, then 
            there will be just one decision function and the index should always be 0. 
            Otherwise, in the case of N-class classification, there will be N(N-1)/2 decision functions.</param>
            <param name="alpha">alpha the optional output vector for weights, corresponding to 
            different support vectors. In the case of linear %SVM all the alpha's will be 1's.</param>
            <param name="svidx">the optional output vector of indices of support vectors 
            within the matrix of support vectors (which can be retrieved by SVM::getSupportVectors). 
            In the case of linear %SVM each decision function consists of a single "compressed" support vector.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.SVM.GetDefaultGrid(OpenCv30Sharp.ML.SVM.ParamTypes)">
            <summary>
            Generates a grid for SVM parameters.
            </summary>
            <param name="paramId">SVM parameters IDs that must be one of the SVM::ParamTypes. 
            The grid is generated for the parameter with this ID.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ML.SVM.Kernel">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.SVM.Kernel.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.SVM.Types">
            <summary>
            SVM type
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.Types.CSvc">
            <summary>
            C-Support Vector Classification. n-class classification (n \f$\geq\f$ 2), 
            allows imperfect separation of classes with penalty multiplier C for outliers.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.Types.NuSvc">
            <summary>
            nu-Support Vector Classification. n-class classification with possible
            imperfect separation. Parameter \f$\nu\f$ (in the range 0..1, the larger 
            the value, the smoother the decision boundary) is used instead of C.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.Types.OneClass">
            <summary>
            Distribution Estimation (One-class %SVM). All the training data are from
            the same class, %SVM builds a boundary that separates the class from the 
            rest of the feature space.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.Types.EpsSvr">
            <summary>
            epsilon-Support Vector Regression. 
            The distance between feature vectors from the training set and the fitting 
            hyper-plane must be less than p. For outliers the penalty multiplier C is used.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.Types.NuSvr">
            <summary>
            nu-Support Vector Regression. \f$\nu\f$ is used instead of p.
            See @cite LibSVM for details.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.SVM.KernelTypes">
            <summary>
            SVM kernel type
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.KernelTypes.Custom">
            <summary>
            Returned by SVM::getKernelType in case when custom kernel has been set
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.KernelTypes.Linear">
            <summary>
            Linear kernel. No mapping is done, linear discrimination (or regression) is
            done in the original feature space. It is the fastest option. \f$K(x_i, x_j) = x_i^T x_j\f$.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.KernelTypes.Poly">
            <summary>
            Polynomial kernel:
            \f$K(x_i, x_j) = (\gamma x_i^T x_j + coef0)^{degree}, \gamma &gt; 0\f$.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.KernelTypes.Rbf">
            <summary>
            Radial basis function (RBF), a good choice in most cases.
            \f$K(x_i, x_j) = e^{-\gamma ||x_i - x_j||^2}, \gamma > 0\f$.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.KernelTypes.Sigmoid">
            <summary>
            Sigmoid kernel: 
            \f$K(x_i, x_j) = \tanh(\gamma x_i^T x_j + coef0)\f$.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.KernelTypes.Chi2">
            <summary>
            Exponential Chi2 kernel, similar to the RBF kernel:
            \f$K(x_i, x_j) = e^{-\gamma \chi^2(x_i,x_j)}, \chi^2(x_i,x_j) = (x_i-x_j)^2/(x_i+x_j), \gamma &gt; 0\f$. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.SVM.KernelTypes.Inter">
            <summary>
            Histogram intersection kernel. 
            A fast kernel. \f$K(x_i, x_j) = min(x_i,x_j)\f$. 
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.SVM.ParamTypes">
            <summary>
            SVM params type
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.ANN_MLP">
            <summary>
            Artificial Neural Networks - Multi-Layer Perceptrons.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ANN_MLP.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.ANN_MLP.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::ANN_MLP*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.ANN_MLP.Create">
            <summary>
            Creates the empty model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.ANN_MLP.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.ML.ANN_MLP.TermCriteria">
            <summary>
            Termination criteria of the training algorithm.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.ANN_MLP.BackpropWeightScale">
            <summary>
            Strength of the weight gradient term.
            The recommended value is about 0.1. Default value is 0.1.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.ANN_MLP.BackpropMomentumScale">
            <summary>
            Strength of the momentum term (the difference between weights on the 2 previous iterations).
            This parameter provides some inertia to smooth the random fluctuations of the weights. 
            It can vary from 0 (the feature is disabled) to 1 and beyond. The value 0.1 or 
            so is good enough. Default value is 0.1.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.ANN_MLP.RpropDW0">
            <summary>
            Initial value Delta_0 of update-values Delta_{ij}. Default value is 0.1.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.ANN_MLP.RpropDWPlus">
            <summary>
            Increase factor eta^+.
            It must be &gt;1. Default value is 1.2.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.ANN_MLP.RpropDWMinus">
            <summary>
            Decrease factor eta^-.
            It must be \&gt;1. Default value is 0.5.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.ANN_MLP.RpropDWMin">
            <summary>
            Update-values lower limit Delta_{min}.
            It must be positive. Default value is FLT_EPSILON.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ML.ANN_MLP.RpropDWMax">
            <summary>
            Update-values upper limit Delta_{max}.
            It must be &gt;1. Default value is 50.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.ANN_MLP.SetLayerSizes(OpenCv30Sharp.InputArray)">
            <summary>
            Integer vector specifying the number of neurons in each layer including the input and output layers.
            The very first element specifies the number of elements in the input layer.
            The last element - number of elements in the output layer.Default value is empty Mat.
            </summary>
            <param name="layerSizes"></param>
        </member>
        <member name="M:OpenCv30Sharp.ML.ANN_MLP.GetLayerSizes">
            <summary>
            Integer vector specifying the number of neurons in each layer including the input and output layers.
            The very first element specifies the number of elements in the input layer.
            The last element - number of elements in the output layer.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ML.ANN_MLP.ActivationFunctions">
            <summary>
            possible activation functions
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ANN_MLP.ActivationFunctions.Identity">
            <summary>
            Identity function: $f(x)=x
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ANN_MLP.ActivationFunctions.SigmoidSym">
            <summary>
            Symmetrical sigmoid: f(x)=\beta*(1-e^{-\alpha x})/(1+e^{-\alpha x}
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ANN_MLP.ActivationFunctions.Gaussian">
            <summary>
            Gaussian function: f(x)=\beta e^{-\alpha x*x}
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.ANN_MLP.TrainFlags">
            <summary>
            Train options
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ANN_MLP.TrainFlags.UpdateWeights">
            <summary>
            Update the network weights, rather than compute them from scratch. 
            In the latter case the weights are initialized using the Nguyen-Widrow algorithm.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ANN_MLP.TrainFlags.NoInputScale">
            <summary>
            Do not normalize the input vectors. 
            If this flag is not set, the training algorithm normalizes each input feature 
            independently, shifting its mean value to 0 and making the standard deviation 
            equal to 1. If the network is assumed to be updated frequently, the new 
            training data could be much different from original one. In this case, 
            you should take care of proper normalization.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ANN_MLP.TrainFlags.NoOutputScale">
            <summary>
            Do not normalize the output vectors. If the flag is not set, 
            the training algorithm normalizes each output feature independently, 
            by transforming it to the certain range depending on the used activation function.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.ANN_MLP.TrainingMethods">
            <summary>
            Available training methods
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ANN_MLP.TrainingMethods.BackProp">
            <summary>
            The back-propagation algorithm.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.ANN_MLP.TrainingMethods.RProp">
            <summary>
            The RPROP algorithm. See @cite RPROP93 for details.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ML.StatModel">
            <summary>
            Base class for statistical models in ML
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.StatModel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ML.StatModel.GetVarCount">
            <summary>
            Returns the number of variables in training samples
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.StatModel.Empty">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.StatModel.IsTrained">
            <summary>
            Returns true if the model is trained
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.StatModel.IsClassifier">
            <summary>
            Returns true if the model is classifier
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.StatModel.Train(OpenCv30Sharp.ML.TrainData,System.Int32)">
            <summary>
            Trains the statistical model
            </summary>
            <param name="trainData">training data that can be loaded from file using TrainData::loadFromCSV 
            or created with TrainData::create.</param>
            <param name="flags"> optional flags, depending on the model. Some of the models can be updated with the 
            new training samples, not completely overwritten (such as NormalBayesClassifier or ANN_MLP).</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.StatModel.Train(OpenCv30Sharp.InputArray,OpenCv30Sharp.ML.SampleTypes,OpenCv30Sharp.InputArray)">
            <summary>
            Trains the statistical model
            </summary>
            <param name="samples">training samples</param>
            <param name="layout">SampleTypes value</param>
            <param name="responses">vector of responses associated with the training samples.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.StatModel.CalcError(OpenCv30Sharp.ML.TrainData,System.Boolean,OpenCv30Sharp.OutputArray)">
            <summary>
            Computes error on the training or test dataset
            </summary>
            <param name="data">the training data</param>
            <param name="test">if true, the error is computed over the test subset of the data, 
            otherwise it's computed over the training subset of the data. Please note that if you 
            loaded a completely different dataset to evaluate already trained classifier, you will 
            probably want not to set the test subset at all with TrainData::setTrainTestSplitRatio 
            and specify test=false, so that the error is computed for the whole new set. Yes, this 
            sounds a bit confusing.</param>
            <param name="resp">the optional output responses.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ML.StatModel.Predict(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.ML.StatModel.Flags)">
            <summary>
            Predicts response(s) for the provided sample(s)
            </summary>
            <param name="samples">The input samples, floating-point matrix</param>
            <param name="results">The optional output matrix of results.</param>
            <param name="flags">The optional flags, model-dependent.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ML.StatModel.Flags">
            <summary>
            Predict options
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ML.StatModel.Flags.RawOutput">
            <summary>
            makes the method return the raw results (the sum), not the class label
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CalibrateDebevec">
            <summary>
            The base class for camera response calibration algorithms.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrateDebevec.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CalibrateDebevec.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::Boost*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CalibrateDebevec.Create(System.Int32,System.Single,System.Boolean)">
            <summary>
            Creates the empty model.
            </summary>
            <param name="samples">number of pixel locations to use</param>
            <param name="lambda">smoothness term weight. Greater values produce smoother results, 
            but can alter the response.</param>
            <param name="random">if true sample pixel locations are chosen at random, 
            otherwise the form a rectangular grid.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.CalibrateDebevec.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.CalibrateCRF">
            <summary>
            The base class for camera response calibration algorithms.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CalibrateCRF.Process(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},OpenCv30Sharp.OutputArray,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Recovers inverse camera response.
            </summary>
            <param name="src">vector of input images</param>
            <param name="dst">256x1 matrix with inverse camera response function</param>
            <param name="times">vector of exposure time values for each image</param>
        </member>
        <member name="T:OpenCv30Sharp.EdgePreservingMethods">
            <summary>
            Edge preserving filters
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.EdgePreservingMethods.RecursFilter">
             <summary>
            
             </summary>
        </member>
        <member name="F:OpenCv30Sharp.EdgePreservingMethods.NormconvFilter">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.SeamlessCloneMethods">
            <summary>
            SeamlessClone method
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SeamlessCloneMethods.NormalClone">
            <summary>
            The power of the method is fully expressed when inserting objects with 
            complex outlines into a new background.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SeamlessCloneMethods.MixedClone">
            <summary>
            The classic method, color-based selection and alpha masking might be time 
            consuming and often leaves an undesirable halo. Seamless cloning, even averaged 
            with the original image, is not effective. Mixed seamless cloning based on a 
            loose selection proves effective.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SeamlessCloneMethods.MonochromeTransfer">
            <summary>
            Feature exchange allows the user to easily replace certain features of one 
            object by alternative features.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.HausdorffDistanceExtractor">
            <summary>
            A simple Hausdorff distance measure between shapes defined by contours
            </summary>
            <remarks>
            according to the paper "Comparing Images using the Hausdorff distance." 
            by D.P. Huttenlocher, G.A. Klanderman, and W.J. Rucklidge. (PAMI 1993). :
            </remarks>
        </member>
        <member name="M:OpenCv30Sharp.HausdorffDistanceExtractor.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.HausdorffDistanceExtractor.Create(OpenCv30Sharp.DistanceTypes,System.Single)">
            <summary>
            Complete constructor
            </summary>
            <param name="distanceFlag">Flag indicating which norm is used to compute the Hausdorff distance (NORM_L1, NORM_L2).</param>
            <param name="rankProp">fractional value (between 0 and 1).</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.HausdorffDistanceExtractor.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.HausdorffDistanceExtractor.DistanceFlag">
            <summary>
            Flag indicating which norm is used to compute the Hausdorff distance (NORM_L1, NORM_L2).
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HausdorffDistanceExtractor.RankProportion">
            <summary>
            fractional value (between 0 and 1).
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ShapeContextDistanceExtractor">
            <summary>
            Implementation of the Shape Context descriptor and matching algorithm
            </summary>
            <remarks>
            proposed by Belongie et al. in "Shape Matching and Object Recognition Using Shape Contexts" 
            (PAMI2002). This implementation is packaged in a generic scheme, in order to allow 
            you the implementation of the common variations of the original pipeline.
            </remarks>
        </member>
        <member name="M:OpenCv30Sharp.ShapeContextDistanceExtractor.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ShapeContextDistanceExtractor.Create(System.Int32,System.Int32,System.Single,System.Single,System.Int32)">
            <summary>
            Complete constructor
            </summary>
            <param name="nAngularBins">The number of angular bins in the shape context descriptor.</param>
            <param name="nRadialBins">The number of radial bins in the shape context descriptor.</param>
            <param name="innerRadius">The value of the inner radius.</param>
            <param name="outerRadius">The value of the outer radius.</param>
            <param name="iterations"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.ShapeContextDistanceExtractor.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.AngularBins">
            <summary>
            The number of angular bins in the shape context descriptor.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.RadialBins">
            <summary>
            The number of radial bins in the shape context descriptor.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.InnerRadius">
            <summary>
            The value of the inner radius.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.OuterRadius">
            <summary>
            The value of the outer radius.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.RotationInvariant">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.ShapeContextWeight">
            <summary>
            The weight of the shape context distance in the final distance value.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.ImageAppearanceWeight">
            <summary>
            The weight of the appearance cost in the final distance value.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.BendingEnergyWeight">
            <summary>
            The weight of the Bending Energy in the final distance value.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.Iterations">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ShapeContextDistanceExtractor.StdDev">
            <summary>
            The value of the standard deviation for the Gaussian window for the image appearance cost.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ShapeContextDistanceExtractor.SetImages(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            Set the images that correspond to each shape. 
            This images are used in the calculation of the Image Appearance cost.
            </summary>
            <param name="image1">Image corresponding to the shape defined by contours1.</param>
            <param name="image2">Image corresponding to the shape defined by contours2.</param>
        </member>
        <member name="M:OpenCv30Sharp.ShapeContextDistanceExtractor.GetImages(OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Get the images that correspond to each shape. 
            This images are used in the calculation of the Image Appearance cost.
            </summary>
            <param name="image1">Image corresponding to the shape defined by contours1.</param>
            <param name="image2">Image corresponding to the shape defined by contours2.</param>
        </member>
        <member name="T:OpenCv30Sharp.ShapeDistanceExtractor">
            <summary>
            Abstract base class for shape distance algorithms.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ShapeDistanceExtractor.ComputeDistance(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            Compute the shape distance between two shapes defined by its contours.
            </summary>
            <param name="contour1">Contour defining first shape.</param>
            <param name="contour2">Contour defining second shape.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.NativeMethods">
            <summary>
            P/Invoke methods of OpenCV 2.x C++ interface
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NativeMethods.tried">
            <summary>
            Is tried P/Invoke once
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.NativeMethods.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.NativeMethods.LoadLibraries(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Load DLL files dynamically using Win32 LoadLibrary
            </summary>
            <param name="additionalPaths"></param>
        </member>
        <member name="M:OpenCv30Sharp.NativeMethods.TryPInvoke">
            <summary>
            Checks whether PInvoke functions can be called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.NativeMethods.IsWindows">
            <summary>
            Returns whether the OS is Windows or not
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.NativeMethods.IsUnix">
            <summary>
            Returns whether the OS is *nix or not
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.NativeMethods.IsMono">
            <summary>
            Returns whether the runtime is Mono or not
            </summary>
            <returns></returns>
        </member>
        <member name="F:OpenCv30Sharp.NativeMethods.ErrorHandlerThrowException">
            <summary>
            Custom error handler to be thrown by OpenCV
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NativeMethods.ErrorHandlerIgnorance">
            <summary>
            Custom error handler to ignore all OpenCV errors
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NativeMethods.ErrorHandlerDefault">
            <summary>
            Default error handler
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Util.EnumerableEx">
            <summary>
            IEnumerable&lt;T&gt; extension methods for .NET Framework 2.0 
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.Select``2(System.Collections.Generic.IEnumerable{``0},OpenCv30Sharp.Util.Func{``0,``1})">
            <summary>
            Enumerable.Select
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="enumerable"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.SelectToArray``2(System.Collections.Generic.IEnumerable{``0},OpenCv30Sharp.Util.Func{``0,``1})">
            <summary>
            Enumerable.Select -> ToArray
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="enumerable"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.SelectToArray``2(System.Collections.IEnumerable,OpenCv30Sharp.Util.Func{``0,``1})">
            <summary>
            Enumerable.Select -> ToArray
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="enumerable"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.SelectPtrs(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat})">
            <summary>
            Enumerable.Select -> ToArray
            </summary>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.SelectPtrs(System.Collections.Generic.IEnumerable{OpenCv30Sharp.InputArray})">
            <summary>
            Enumerable.Select -> ToArray
            </summary>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.Where``1(System.Collections.Generic.IEnumerable{``0},OpenCv30Sharp.Util.Func{``0,System.Boolean})">
            <summary>
            Enumerable.Where
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="enumerable"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.WhereToArray``1(System.Collections.Generic.IEnumerable{``0},OpenCv30Sharp.Util.Func{``0,System.Boolean})">
            <summary>
            Enumerable.Where -> ToArray
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="enumerable"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enumerable.ToArray
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.Any``1(System.Collections.Generic.IEnumerable{``0},OpenCv30Sharp.Util.Func{``0,System.Boolean})">
            <summary>
            Enumerable.Any
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="enumerable"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.AnyNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enumerable.Any
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.All``1(System.Collections.Generic.IEnumerable{``0},OpenCv30Sharp.Util.Func{``0,System.Boolean})">
            <summary>
            Enumerable.All
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="enumerable"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.Count``1(System.Collections.Generic.IEnumerable{``0},OpenCv30Sharp.Util.Func{``0,System.Boolean})">
            <summary>
            Enumerable.Count
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="enumerable"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enumerable.Count
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.EnumerableEx.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            
            </summary>
            <typeparam name="TSource"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Util.PInvokeHelper">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.PInvokeHelper.TryPInvoke">
            <summary>
            Checks whether PInvoke functions can be called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.PInvokeHelper.DllImportError(System.Exception)">
            <summary>
            DllImportの際にDllNotFoundExceptionかBadImageFormatExceptionが発生した際に呼び出されるメソッド。
            エラーメッセージを表示して解決策をユーザに示す。
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.PInvokeHelper.CreateException(System.Exception)">
            <summary>
            
            </summary>
            <param name="ex"></param>
        </member>
        <member name="T:OpenCv30Sharp.Util.WindowsLibraryLoader">
            <summary>
            Handles loading embedded dlls into memory, based on http://stackoverflow.com/questions/666799/embedding-unmanaged-dll-into-a-managed-c-sharp-dll.
            </summary>
            <remarks>This code is based on https://github.com/charlesw/tesseract </remarks>
        </member>
        <member name="P:OpenCv30Sharp.Util.WindowsLibraryLoader.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Util.WindowsLibraryLoader.ProcessorArchitecture">
            <summary>
            The default base directory name to copy the assemblies too.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Util.WindowsLibraryLoader.processorArchitecturePlatforms">
            <summary>
            Map processor 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Util.WindowsLibraryLoader.processorArchitectureAddressWidthPlatforms">
            <summary>
            Used as a sanity check for the returned processor architecture to double check the returned value.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.WindowsLibraryLoader.AdditionalPaths">
            <summary>
            Additional user-defined DLL paths 
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.WindowsLibraryLoader.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.WindowsLibraryLoader.IsLibraryLoaded(System.String)">
            <summary>
            
            </summary>
            <param name="dllName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.WindowsLibraryLoader.IsCurrentPlatformSupported">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.WindowsLibraryLoader.LoadLibrary(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            
            </summary>
            <param name="dllName"></param>
            <param name="additionalPaths"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.WindowsLibraryLoader.GetProcessArchitecture">
            <summary>
            Get's the current process architecture while keeping track of any assumptions or possible errors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.WindowsLibraryLoader.FixUpDllFileName(System.String)">
            <summary>
            Determines if the dynamic link library file name requires a suffix
            and adds it if necessary.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.WindowsLibraryLoader.GetPlatformName(System.String)">
            <summary>
            Given the processor architecture, returns the name of the platform.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Util.WindowsLibraryLoader.ProcessArchitectureInfo">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Util.ArrayAddress1`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress1`1.#ctor(`0[])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress1`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            
            </summary>
            <param name="enumerable"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress1`1.#ctor(`0[0:,0:])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress1`1.Dispose(System.Boolean)">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.ArrayAddress1`1.Pointer">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress1`1.op_Implicit(OpenCv30Sharp.Util.ArrayAddress1{`0})~System.IntPtr">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Util.ArrayAddress1`1.Length">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Util.ArrayAddress2`1">
            <summary>
            Class to get address of specified jagged array 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress2`1.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress2`1.#ctor(`0[][])">
            <summary>
            
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress2`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            
            </summary>
            <param name="enumerable"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress2`1.Dispose(System.Boolean)">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.ArrayAddress2`1.Pointer">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.ArrayAddress2`1.op_Implicit(OpenCv30Sharp.Util.ArrayAddress2{`0})~System.IntPtr[]">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Util.ArrayAddress2`1.Dim1Length">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.ArrayAddress2`1.Dim2Lengths">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Util.DynamicInvoker`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OpenCv30Sharp.Util.DynamicInvoker`1.DllName">
            <summary>
            Name of library to be loaded
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.DynamicInvoker`1.FunctionName">
            <summary>
            Name of function to be called
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.DynamicInvoker`1.PtrLib">
            <summary>
            Pointer which retrieved by LoadLibrary
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.DynamicInvoker`1.PtrProc">
            <summary>
            Pointer which retrieved by GetProcAddress
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.DynamicInvoker`1.Call">
            <summary>
            Delegate which is converted from function pointer
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.DynamicInvoker`1.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="dllName">Name of library</param>
            <param name="functionName">Name of function</param>
        </member>
        <member name="M:OpenCv30Sharp.Util.DynamicInvoker`1.Dispose(System.Boolean)">
            <summary>
            Releases resources
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:OpenCv30Sharp.Util.Platform">
            <summary>
            Provides information for the platform which the user is using 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Util.Platform.OS">
            <summary>
            OS type
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Util.Platform.Runtime">
            <summary>
            Runtime type
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Util.ScopedGCHandle">
            <summary>
            Original GCHandle that implement IDisposable 
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.#ctor(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.#ctor(System.Object,System.Runtime.InteropServices.GCHandleType)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="type"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.#ctor(System.Runtime.InteropServices.GCHandle)">
            <summary>
            
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.Alloc(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.Alloc(System.Object,System.Runtime.InteropServices.GCHandleType)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.FromIntPtr(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.ToIntPtr(OpenCv30Sharp.Util.ScopedGCHandle)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Util.ScopedGCHandle.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.ScopedGCHandle.IsAllocated">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.ScopedGCHandle.Target">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.AddrOfPinnedObject">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.Free">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.ScopedGCHandle.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Util.StringArrayAddress">
            <summary>
            Class to get address of string array
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.StringArrayAddress.#ctor(System.String[])">
            <summary>
            
            </summary>
            <param name="stringArray"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.StringArrayAddress.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            
            </summary>
            <param name="enumerable"></param>
        </member>
        <member name="T:OpenCv30Sharp.Util.StructurePointer">
            <summary>
            Class that converts structure into pointer and cleans up resources automatically 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.StructurePointer.Ptr">
            <summary>
            Pointer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.StructurePointer.SrcObj">
            <summary>
            Structure
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Util.StructurePointer.Size">
            <summary>
            Size of allocated memory
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.StructurePointer.#ctor(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.StructurePointer.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.StructurePointer.op_Implicit(OpenCv30Sharp.Util.StructurePointer)~System.IntPtr">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.StructurePointer.ToStructure">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.StructurePointer.Dispose">
            <summary>
            Clean up resources to be used
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Util.StructurePointer`1">
            <summary>
            Class that converts structure into pointer and cleans up resources automatically (generic version)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:OpenCv30Sharp.Util.StructurePointer`1.#ctor(`0)">
            <summary>
            
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.StructurePointer`1.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.StructurePointer`1.op_Implicit(OpenCv30Sharp.Util.StructurePointer{`0})~System.IntPtr">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.StructurePointer`1.ToStructure">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Util.Action">
            <summary>
            Substitute of System.Action
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Util.TimeMeasurer">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.TimeMeasurer.Measure(OpenCv30Sharp.Util.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Util.Utility">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Util.Utility.CopyMemory(System.Void*,System.Void*,System.UInt32)">
            <summary>
            
            </summary>
            <param name="outDest"></param>
            <param name="inSrc"></param>
            <param name="inNumOfBytes"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.Utility.ZeroMemory(System.Void*,System.UInt32)">
            <summary>
            
            </summary>
            <param name="outDest"></param>
            <param name="inNumOfBytes"></param>
        </member>
        <member name="M:OpenCv30Sharp.Util.Utility.Cast``1(System.IntPtr)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.Utility.ToObject``1(System.IntPtr)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.Utility.CheckType(System.Type,System.Type)">
            <summary>
            
            </summary>
            <param name="test"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Util.Utility.SizeOf(System.Type)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.AdaptiveThresholdTypes">
            <summary>
            Adaptive thresholding algorithms
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.AdaptiveThresholdTypes.MeanC">
            <summary>
            It is a mean of block_size × block_size pixel neighborhood, subtracted by param1.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.AdaptiveThresholdTypes.GaussianC">
            <summary>
            it is a weighted sum (Gaussian) of block_size × block_size pixel neighborhood, subtracted by param1.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CmpTypes">
            <summary>
            The flag specifying the relation between the elements to be checked
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CmpTypes.EQ">
            <summary>
            src1(I) "equal to" src2(I)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CmpTypes.GT">
            <summary>
            src1(I) "greater than" src2(I)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CmpTypes.GE">
            <summary>
            src1(I) "greater or equal" src2(I)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CmpTypes.LT">
            <summary>
            src1(I) "less than" src2(I)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CmpTypes.LE">
            <summary>
            src1(I) "less or equal" src2(I)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CmpTypes.NE">
            <summary>
            src1(I) "not equal to" src2(I)
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.BorderTypes">
            <summary>
            Type of the border to create around the copied source image rectangle
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BorderTypes.Constant">
            <summary>
            Border is filled with the fixed value, passed as last parameter of the function.
            `iiiiii|abcdefgh|iiiiiii`  with some specified `i`
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BorderTypes.Replicate">
            <summary>
            The pixels from the top and bottom rows, the left-most and right-most columns are replicated to fill the border.
            `aaaaaa|abcdefgh|hhhhhhh`
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BorderTypes.Reflect">
            <summary>
            `fedcba|abcdefgh|hgfedcb`
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BorderTypes.Wrap">
            <summary>
            `cdefgh|abcdefgh|abcdefg`
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BorderTypes.Reflect101">
            <summary>
            `gfedcb|abcdefgh|gfedcba`
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BorderTypes.Transparent">
            <summary>
            `uvwxyz|absdefgh|ijklmno`
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BorderTypes.Default">
            <summary>
            same as BORDER_REFLECT_101
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BorderTypes.Isolated">
            <summary>
            do not look outside of ROI
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ButtonTypes">
            <summary>
            Button type flags (cv::createButton)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ButtonTypes.PushButton">
            <summary>
            The button will be a push button.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ButtonTypes.Checkbox">
            <summary>
            The button will be a checkbox button.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ButtonTypes.Radiobox">
            <summary>
            The button will be a radiobox button. The radiobox on the same buttonbar (same line) are exclusive; one on can be select at the time.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CalibrationFlags">
            <summary>
            Different flags for cvCalibrateCamera2 and cvStereoCalibrate
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.UseIntrinsicGuess">
            <summary>
            The flag allows the function to optimize some or all of the intrinsic parameters, depending on the other flags, but the initial values are provided by the user
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixAspectRatio">
            <summary>
            fyk is optimized, but the ratio fxk/fyk is fixed.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixPrincipalPoint">
            <summary>
            The principal points are fixed during the optimization.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.ZeroTangentDist">
            <summary>
            Tangential distortion coefficients are set to zeros and do not change during the optimization.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixFocalLength">
            <summary>
            fxk and fyk are fixed.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixK1">
            <summary>
            The 0-th distortion coefficients (k1) are fixed 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixK2">
            <summary>
            The 1-th distortion coefficients (k2) are fixed 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixK3">
            <summary>
            The 4-th distortion coefficients (k3) are fixed 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixK4">
            <summary>
            Do not change the corresponding radial distortion coefficient during the optimization. 
            If CV_CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used, otherwise it is set to 0.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixK5">
            <summary>
            Do not change the corresponding radial distortion coefficient during the optimization. 
            If CV_CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used, otherwise it is set to 0.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixK6">
            <summary>
            Do not change the corresponding radial distortion coefficient during the optimization. 
            If CV_CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the supplied distCoeffs matrix is used, otherwise it is set to 0.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.RationalModel">
            <summary>
            Enable coefficients k4, k5 and k6. 
            To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function 
            use the rational model and return 8 coefficients. If the flag is not set, the function will compute only 5 distortion coefficients.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.ThinPrismModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixS1S2S3S4">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.FixIntrinsic">
            <summary>
            If it is set, camera_matrix1,2, as well as dist_coeffs1,2 are fixed, so that only extrinsic parameters are optimized.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.SameFocalLength">
            <summary>
            Enforces fx0=fx1 and fy0=fy1. CV_CALIB_ZERO_TANGENT_DIST - Tangential distortion coefficients for each camera are set to zeros and fixed there.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CalibrationFlags.ZeroDisparity">
            <summary>
            for stereo rectification
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CameraChannels">
            <summary>
            channel indices for multi-head camera live streams
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CameraChannels.OpenNI_DepthMap">
            <summary>
            Depth values in mm (CV_16UC1)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CameraChannels.OpenNI_PointCloudMap">
            <summary>
            XYZ in meters (CV_32FC3)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CameraChannels.OpenNI_DisparityMap">
            <summary>
            Disparity in pixels (CV_8UC1)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CameraChannels.OpenNI_DisparityMap32F">
            <summary>
            Disparity in pixels (CV_32FC1)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CameraChannels.OpenNI_ValidDepthMask">
            <summary>
            CV_8UC1
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CaptureDevice">
            <summary>
            Camera device types
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.Any">
            <summary>
            autodetect
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.VFW">
            <summary>
            platform native
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.V4L">
            <summary>
            platform native
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.V4L2">
            <summary>
            platform native
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.Firewire">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.Fireware">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.IEEE1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.DC1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.CMU1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.Qt">
            <summary>
            QuickTime
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.Unicap">
            <summary>
            Unicap drivers
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.DShow">
            <summary>
            DirectShow (via videoInput)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.PVAPI">
            <summary>
            PvAPI, Prosilica GigE SDK
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.OpenNI">
            <summary>
            OpenNI (for Kinect)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.OpenNI_ASUS">
            <summary>
            OpenNI (for Asus Xtion)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.Android">
            <summary>
            Android
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.XIAPI">
            <summary>
            XIMEA Camera API
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.AVFoundation">
            <summary>
            AVFoundation framework for iOS (OS X Lion will have the same API)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.Giganetix">
            <summary>
            Smartek Giganetix GigEVisionSDK
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.MSMF">
            <summary>
            Microsoft Media Foundation (via videoInput)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.WinRT">
            <summary>
            Microsoft Windows Runtime using Media Foundation
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.IntelPERC">
            <summary>
            Intel Perceptual Computing SDK
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.OpenNI2">
            <summary>
            OpenNI2 (for Kinect)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.OpenNI2_ASUS">
            <summary>
            OpenNI2 (for Asus Xtion and Occipital Structure sensors)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureDevice.GPhoto2">
            <summary>
            gPhoto2 connection
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CapturePosAviRatio">
            <summary>
            Position in relative units
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CapturePosAviRatio.Start">
            <summary>
            Start of the file
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CapturePosAviRatio.End">
            <summary>
            End of the file
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CaptureProperty">
            <summary>
            Property identifiers for CvCapture
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PosMsec">
            <summary>
            Position in milliseconds from the file beginning
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PosFrames">
            <summary>
            Position in frames (only for video files)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PosAviRatio">
            <summary>
            Position in relative units (0 - start of the file, 1 - end of the file)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.FrameWidth">
            <summary>
            Width of frames in the video stream (only for cameras)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.FrameHeight">
            <summary>
            Height of frames in the video stream (only for cameras)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Fps">
            <summary>
            Frame rate (only for cameras)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.FourCC">
            <summary>
            4-character code of codec (only for cameras). 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.FrameCount">
            <summary>
            Number of frames in the video stream
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Format">
            <summary>
            The format of the Mat objects returned by retrieve()
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Mode">
            <summary>
            A backend-specific value indicating the current capture mode
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Brightness">
            <summary>
            Brightness of image (only for cameras) 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Contrast">
            <summary>
            contrast of image (only for cameras) 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Saturation">
            <summary>
            Saturation of image (only for cameras) 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Hue">
            <summary>
            hue of image (only for cameras) 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Gain">
            <summary>
            Gain of the image (only for cameras)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Exposure">
            <summary>
            Exposure (only for cameras)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.ConvertRgb">
            <summary>
            Boolean flags indicating whether images should be converted to RGB
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.WhiteBalanceBlueU">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Rectification">
            <summary>
            TOWRITE (note: only supported by DC1394 v 2.x backend currently)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Monocrome">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Sharpness">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.AutoExposure">
            <summary>
            exposure control done by camera,
            user can adjust refernce level using this feature
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Gamma">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Temperature">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Trigger">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.TriggerDelay">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.WhiteBalanceRedV">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Zoom">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Focus">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Guid">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.IsoSpeed">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.BackLight">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Pan">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Tilt">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Roll">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Iris">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Settings">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_OutputMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_FrameMaxDepth">
            <summary>
            in mm
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_Baseline">
            <summary>
            in mm
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_FocalLength">
            <summary>
            in pixels
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_Registration">
            <summary>
            flag that synchronizes the remapping depth map to image map
            by changing depth generator's view point (if the flag is "on") or
            sets this view point to its normal one (if the flag is "off").
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OPENNI_ApproxFrameSync">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OPENNI_MaxBufferSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OPENNI_CircleBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OPENNI_MaxTimeDuration">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OPENNI_GeneratorPresent">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OPENNI2_Sync">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OPENNI2_Mirror">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_DepthGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_ImageGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_ImageGeneratorPresent">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_ImageGeneratorOutputMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_DepthGeneratorBaseline">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_DepthGeneratorFocalLength">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.OpenNI_DepthGeneratorRegistrationON">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GStreamerQueueLength">
            <summary>
            default is 1
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PvAPIMulticastIP">
            <summary>
            ip for anable multicast master mode. 0 for disable multicast
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PVAPI_FrameStartTriggerMode">
            <summary>
            Determines how a frame is initiated
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PVAPI_DecimationHorizontal">
            <summary>
            Horizontal sub-sampling of the image
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PVAPI_DecimationVertical">
            <summary>
            Vertical sub-sampling of the image
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PVAPI_BinningX">
            <summary>
            Horizontal binning factor
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PVAPI_BinningY">
            <summary>
            Vertical binning factor
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.PVAPI_PixelFormat">
            <summary>
            Pixel format
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_Downsampling">
            <summary>
            Change image resolution by binning or skipping. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_DataFormat">
            <summary>
            Output data format.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_OffsetX">
            <summary>
            Horizontal offset from the origin to the area of interest (in pixels).
            </summary>        
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_OffsetY">
            <summary>
            Vertical offset from the origin to the area of interest (in pixels).
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_TrgSource">
            <summary>
            Defines source of trigger.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_TrgSoftware">
            <summary>
            Generates an internal trigger. PRM_TRG_SOURCE must be set to TRG_SOFTWARE.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_GpiSelector">
            <summary>
            Selects general purpose input 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_GpiMode">
            <summary>
            Set general purpose input mode
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_GpiLevel">
            <summary>
            Get general purpose level
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_GpoSelector">
            <summary>
            Selects general purpose output 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_GpoMode">
            <summary>
            Set general purpose output mode
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_LedSelector">
            <summary>
            Selects camera signalling LED 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_LedMode">
            <summary>
            Define camera signalling LED functionality
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_ManualWB">
            <summary>
            Calculates White Balance(must be called during acquisition)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_AutoWB">
            <summary>
            Automatic white balance
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_AEAG">
            <summary>
            Automatic exposure/gain
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_ExpPriority">
            <summary>
            Exposure priority (0.5 - exposure 50%, gain 50%).
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_AEMaxLimit">
            <summary>
            Maximum limit of exposure in AEAG procedure
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_AGMaxLimit">
            <summary>
            Maximum limit of gain in AEAG procedure
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_AEAGLevel">
            <summary>
            Average intensity of output signal AEAG should achieve(in %)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.XI_Timeout">
            <summary>
            Image capture timeout in milliseconds
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.IOS_DeviceFocus">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.IOS_DeviceExposure">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.IOS_DeviceFlash">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.IOS_DeviceWhiteBalance">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.IOS_DeviceTorch">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GIGA_FrameOffsetX">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GIGA_FrameOffsetY">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GIGA_FrameWidthMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GIGA_FrameHeightMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GIGA_FrameSensWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GIGA_FrameSensHeight">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.INTELPERC_ProfileCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.INTELPERC_ProfileIdx">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.INTELPERC_DepthLowConfidenceValue">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.INTELPERC_DepthSaturationValue">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.INTELPERC_DepthConfidenceThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.INTELPERC_DepthFocalLengthHorz">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.INTELPERC_DepthFocalLengthVert">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GPhoto2_Preview">
            <summary>
            Capture only preview from liveview mode.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GPhoto2_WidgetEnumerate">
            <summary>
            Readonly, returns (const char *).
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GPhoto2_ReloadConfig">
            <summary>
            Trigger, only by set. Reload camera settings.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GPhoto2_ReloadOnChange">
            <summary>
            Reload all settings on set.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GPhoto2_CollectMsgs">
            <summary>
            Collect messages with details.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.GPhoto2_FlushMsgs">
            <summary>
            Readonly, returns (const char *).
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Speed">
            <summary>
            Exposure speed. Can be readonly, depends on camera program.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.Aperture">
            <summary>
            Aperture. Can be readonly, depends on camera program.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.ExposureProgram">
            <summary>
            Camera exposure program.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureProperty.ViewFinder">
            <summary>
            Enter liveview mode.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CaptureType">
            <summary>
            Capture type of CvCapture (Camera or AVI file)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureType.File">
            <summary>
            Captures from an AVI file
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureType.Camera">
            <summary>
            Captures from digital camera
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CaptureType.NotSpecified">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ChessboardFlags">
            <summary>
            Various operation flags for cvFindChessboardCorners
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ChessboardFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ChessboardFlags.AdaptiveThresh">
            <summary>
            Use adaptive thresholding to convert the image to black-n-white, rather than a fixed threshold level (computed from the average image brightness).
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ChessboardFlags.NormalizeImage">
            <summary>
            Normalize the image using cvNormalizeHist before applying fixed or adaptive thresholding.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ChessboardFlags.FilterQuads">
            <summary>
            Use additional criteria (like contour area, perimeter, square-like shape) to filter out false quads that are extracted at the contour retrieval stage.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ChessboardFlags.FastCheck">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ColorConversionCodes">
            <summary>
            Color conversion operation for cv::cvtColor
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ContourApproximationModes">
            <summary>
            Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ContourApproximationModes.ApproxNone">
            <summary>
            CHAIN_APPROX_NONE - translate all the points from the chain code into points; 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ContourApproximationModes.ApproxSimple">
            <summary>
            CHAIN_APPROX_SIMPLE - compress horizontal, vertical, and diagonal segments, that is, the function leaves only their ending points; 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ContourApproximationModes.ApproxTC89L1">
            <summary>
            CHAIN_APPROX_TC89_L1 - apply one of the flavors of Teh-Chin chain approximation algorithm. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ContourApproximationModes.ApproxTC89KCOS">
            <summary>
            CHAIN_APPROX_TC89_KCOS - apply one of the flavors of Teh-Chin chain approximation algorithm. 
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.RetrievalModes">
            <summary>
            mode of the contour retrieval algorithm
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RetrievalModes.External">
            <summary>
            retrieves only the extreme outer contours. 
            It sets `hierarchy[i][2]=hierarchy[i][3]=-1` for all the contours.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RetrievalModes.List">
            <summary>
            retrieves all of the contours without establishing any hierarchical relationships.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RetrievalModes.CComp">
            <summary>
            retrieves all of the contours and organizes them into a two-level hierarchy. 
            At the top level, there are external boundaries of the components. 
            At the second level, there are boundaries of the holes. If there is another 
            contour inside a hole of a connected component, it is still put at the top level.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RetrievalModes.Tree">
            <summary>
            retrieves all of the contours and reconstructs a full hierarchy 
            of nested contours.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RetrievalModes.FloodFill">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CovarFlags">
            <summary>
            Operation flags for Covariation 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CovarFlags.Scrambled">
            <summary>
            scale * [vects[0]-avg,vects[1]-avg,...]^T * [vects[0]-avg,vects[1]-avg,...]   
            that is, the covariation matrix is count×count. Such an unusual covariation matrix is used for fast PCA of a set of very large vectors
            (see, for example, Eigen Faces technique for face recognition). Eigenvalues of this "scrambled" matrix will match to the eigenvalues of
            the true covariation matrix and the "true" eigenvectors can be easily calculated from the eigenvectors of the "scrambled" covariation matrix.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CovarFlags.Normal">
            <summary>
            scale * [vects[0]-avg,vects[1]-avg,...]*[vects[0]-avg,vects[1]-avg,...]^T   
            that is, cov_mat will be a usual covariation matrix with the same linear size as the total number of elements in every input vector. 
            One and only one of CV_COVAR_SCRAMBLED and CV_COVAR_NORMAL must be specified
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CovarFlags.UseAvg">
            <summary>
            If the flag is specified, the function does not calculate avg from the input vectors, 
            but, instead, uses the passed avg vector. This is useful if avg  has been already calculated somehow, 
            or if the covariation matrix is calculated by parts - in this case, avg is not a mean vector of the input sub-set of vectors, 
            but rather the mean vector of the whole set.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CovarFlags.Scale">
            <summary>
            If the flag is specified, the covariation matrix is scaled by the number of input vectors.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CovarFlags.Rows">
            <summary>
            Means that all the input vectors are stored as rows of a single matrix, vects[0].count is ignored in this case, 
            and avg should be a single-row vector of an appropriate size.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CovarFlags.Cols">
            <summary>
            Means that all the input vectors are stored as columns of a single matrix, vects[0].count is ignored in this case, 
            and avg should be a single-column vector of an appropriate size. 
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ErrorCode">
            <summary>
            Error status codes
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsOk">
            <summary>
            everithing is ok [CV_StsOk]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsBackTrace">
            <summary>
            pseudo error for back trace [CV_StsBackTrace]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsError">
            <summary>
            unknown /unspecified error [CV_StsError]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsInternal">
            <summary>
            internal error (bad state)  [CV_StsInternal]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsNoMem">
            <summary>
            insufficient memory [CV_StsNoMem]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsBadArg">
            <summary>
            function arg/param is bad [CV_StsBadArg]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsBadFunc">
            <summary>
            unsupported function [CV_StsBadFunc]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsNoConv">
            <summary>
            iter. didn't converge [CV_StsNoConv]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsAutoTrace">
            <summary>
            tracing [CV_StsAutoTrace]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.HeaderIsNull">
            <summary>
            image header is NULL [CV_HeaderIsNull]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadImageSize">
            <summary>
            image size is invalid [CV_BadImageSize]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadOffset">
            <summary>
            offset is invalid [CV_BadOffset]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadDataPtr">
            <summary>
            [CV_BadOffset]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadStep">
            <summary>
            [CV_BadStep]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadModelOrChSeq">
            <summary>
            [CV_BadModelOrChSeq]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadNumChannels">
            <summary>
            [CV_BadNumChannels]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadNumChannel1U">
            <summary>
            [CV_BadNumChannel1U]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadDepth">
            <summary>
            [CV_BadDepth]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadAlphaChannel">
            <summary>
            [CV_BadAlphaChannel]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadOrder">
            <summary>
            [CV_BadOrder]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadOrigin">
            <summary>
            [CV_BadOrigin]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadAlign">
            <summary>
            [CV_BadAlign]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadCallBack">
            <summary>
            [CV_BadCallBack]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadTileSize">
            <summary>
            [CV_BadTileSize]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadCOI">
            <summary>
            [CV_BadCOI]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.BadROISize">
            <summary>
            [CV_BadROISize]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.MaskIsTiled">
            <summary>
            [CV_MaskIsTiled]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsNullPtr">
            <summary>
            null pointer [CV_StsNullPtr]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsVecLengthErr">
            <summary>
            incorrect vector length [CV_StsVecLengthErr]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsFilterStructContentErr">
            <summary>
            incorr. filter structure content [CV_StsFilterStructContentErr]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsKernelStructContentErr">
            <summary>
            incorr. transform kernel content [CV_StsKernelStructContentErr]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsFilterOffsetErr">
            <summary>
            incorrect filter ofset value [CV_StsFilterOffsetErr]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsBadSize">
            <summary>
            the input/output structure size is incorrect [CV_StsBadSize]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsDivByZero">
            <summary>
            division by zero [CV_StsDivByZero]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsInplaceNotSupported">
            <summary>
            in-place operation is not supported [CV_StsInplaceNotSupported]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsObjectNotFound">
            <summary>
            request can't be completed [CV_StsObjectNotFound]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsUnmatchedFormats">
            <summary>
            formats of input/output arrays differ [CV_StsUnmatchedFormats]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsBadFlag">
            <summary>
            flag is wrong or not supported [CV_StsBadFlag]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsBadPoint">
            <summary>
            bad CvPoint [CV_StsBadPoint]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsBadMask">
            <summary>
            bad format of mask (neither 8uC1 nor 8sC1) [CV_StsBadMask]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsUnmatchedSizes">
            <summary>
            sizes of input/output structures do not match [CV_StsUnmatchedSizes]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsUnsupportedFormat">
            <summary>
            the data format/type is not supported by the function [CV_StsUnsupportedFormat]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsOutOfRange">
            <summary>
            some of parameters are out of range [CV_StsOutOfRange]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsParseError">
            <summary>
            invalid syntax/structure of the parsed file [CV_StsParseError]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsNotImplemented">
            <summary>
            the requested function/feature is not implemented [CV_StsNotImplemented]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsBadMemBlock">
            <summary>
            an allocated block has been corrupted [CV_StsBadMemBlock]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ErrorCode.StsAssert">
            <summary>
            assertion failed
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DctFlags">
            <summary>
            Transformation flags for cv::dct
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DctFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DctFlags.Inverse">
            <summary>
            Do inverse 1D or 2D transform.
            (Forward and Inverse are mutually exclusive, of course.)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DctFlags.Rows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. 
            This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead 
            (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc. 
            [CV_DXT_ROWS]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DftFlags">
            <summary>
            Transformation flags for cvDFT
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DftFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DftFlags.Inverse">
            <summary>
            Do inverse 1D or 2D transform. The result is not scaled. 
            (Forward and Inverse are mutually exclusive, of course.)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DftFlags.Scale">
            <summary>
            Scale the result: divide it by the number of array elements. Usually, it is combined with Inverse.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DftFlags.Rows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. 
            This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead
            (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DftFlags.ComplexOutput">
            <summary>
            performs a forward transformation of 1D or 2D real array; the result, 
            though being a complex array, has complex-conjugate symmetry (*CCS*, 
            see the function description below for details), and such an array can 
            be packed into a real array of the same size as input, which is the fastest 
            option and which is what the function does by default; however, you may 
            wish to get a full complex array (for simpler spectrum analysis, and so on) - 
            pass the flag to enable the function to produce a full-size complex output array.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DftFlags.RealOutput">
            <summary>
            performs an inverse transformation of a 1D or 2D complex array; 
            the result is normally a complex array of the same size, however, 
            if the input array has conjugate-complex symmetry (for example, 
            it is a result of forward transformation with DFT_COMPLEX_OUTPUT flag), 
            the output is a real array; while the function itself does not 
            check whether the input is symmetrical or not, you can pass the flag 
            and then the function will assume the symmetry and produce the real 
            output array (note that when the input is packed into a real array 
            and inverse transformation is executed, the function treats the input 
            as a packed complex-conjugate symmetrical array, and the output 
            will also be a real array).
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DistanceTypes">
            <summary>
            Type of distance for cvDistTransform
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTypes.User">
            <summary>
            User defined distance  [CV_DIST_USER]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTypes.L1">
            <summary>
            distance = |x1-x2| + |y1-y2|  [CV_DIST_L1]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTypes.L2">
            <summary>
            the simple euclidean distance  [CV_DIST_L2]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTypes.C">
            <summary>
            distance = max(|x1-x2|,|y1-y2|)  [CV_DIST_C]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTypes.L12">
            <summary>
            L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1))  [CV_DIST_L12]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTypes.Fair">
            <summary>
            distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998  [CV_DIST_FAIR]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTypes.Welsch">
            <summary>
            distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846  [CV_DIST_WELSCH]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTypes.Huber">
            <summary>
            distance = |x|&lt;c ? x^2/2 : c(|x|-c/2), c=1.345  [CV_DIST_HUBER]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DistributionType">
            <summary>
            Distribution type for cvRandArr, etc.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistributionType.Uniform">
            <summary>
            Uniform distribution
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistributionType.Normal">
            <summary>
            Normal or Gaussian distribution
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DistanceTransformLabelTypes">
            <summary>
            distanceTransform algorithm flags
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTransformLabelTypes.CComp">
            <summary>
            each connected component of zeros in src 
            (as well as all the non-zero pixels closest to the connected component) 
            will be assigned the same label 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceTransformLabelTypes.Pixel">
            <summary>
            each zero pixel (and all the non-zero pixels closest to it) gets its own label.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.MorphShapes">
            <summary>
            Shape of the structuring element
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphShapes.Rect">
            <summary>
            A rectangular element
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphShapes.Cross">
            <summary>
            A cross-shaped element
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphShapes.Ellipse">
            <summary>
            An elliptic element
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.FlipMode">
            <summary>
            Specifies how to flip the array
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FlipMode.X">
            <summary>
            means flipping around x-axis
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FlipMode.Y">
            <summary>
            means flipping around y-axis
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FlipMode.XY">
            <summary>
            means flipping around both axises
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.FloodFillFlags">
            <summary>
            floodFill Operation flags. Lower bits contain a connectivity value, 4 (default) or 8, used within the function. Connectivity determines which neighbors of a pixel are considered. Upper bits can be 0 or a combination of the following flags:
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FloodFillFlags.Link4">
            <summary>
            4-connected line.
            [= 4]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FloodFillFlags.Link8">
            <summary>
            8-connected line.
            [= 8]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FloodFillFlags.FixedRange">
            <summary>
            If set, the difference between the current pixel and seed pixel is considered. Otherwise, the difference between neighbor pixels is considered (that is, the range is floating).
            [CV_FLOODFILL_FIXED_RANGE]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FloodFillFlags.MaskOnly">
            <summary>
            If set, the function does not change the image ( newVal is ignored), but fills the mask. The flag can be used for the second variant only.
            [CV_FLOODFILL_MASK_ONLY]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.HersheyFonts">
            <summary>
            Font name identifier. 
            Only a subset of Hershey fonts (http://sources.isc.org/utils/misc/hershey-font.txt) are supported now.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HersheyFonts.HersheySimplex">
            <summary>
            normal size sans-serif font
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HersheyFonts.HersheyPlain">
            <summary>
            small size sans-serif font
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HersheyFonts.HersheyDuplex">
            <summary>
            normal size sans-serif font (more complex than HERSHEY_SIMPLEX)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HersheyFonts.HersheyComplex">
            <summary>
            normal size serif font
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HersheyFonts.HersheyTriplex">
            <summary>
            normal size serif font (more complex than HERSHEY_COMPLEX)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HersheyFonts.HersheyComplexSmall">
            <summary>
            smaller version of HERSHEY_COMPLEX
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HersheyFonts.HersheyScriptSimplex">
            <summary>
            hand-writing style font
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HersheyFonts.HersheyScriptComplex">
            <summary>
            more complex variant of HERSHEY_SCRIPT_SIMPLEX
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HersheyFonts.Italic">
            <summary>
            flag for italic font
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.FourCC">
            <summary>
            4-character code of codec used to compress the frames.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.FundamentalMatMethod">
            <summary>
            Method for computing the fundamental matrix 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FundamentalMatMethod.Point7">
            <summary>
            for 7-point algorithm. N == 7 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FundamentalMatMethod.Point8">
            <summary>
            for 8-point algorithm. N >= 8 
            [CV_FM_8POINT]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FundamentalMatMethod.LMedS">
            <summary>
            for LMedS algorithm. N > 8 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FundamentalMatMethod.Ransac">
            <summary>
            for RANSAC algorithm. N > 8 
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.GemmFlags">
            <summary>
            The operation flags for cv::GEMM
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GemmFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GemmFlags.A_T">
            <summary>
            Transpose src1
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GemmFlags.B_T">
            <summary>
            Transpose src2
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GemmFlags.C_T">
            <summary>
            Transpose src3
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.HaarDetectionType">
            <summary>
            Modes of operation for cvHaarDetectObjects
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HaarDetectionType.DoCannyPruning">
            <summary>
            If it is set, the function uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. 
            The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing.
            [CV_HAAR_DO_CANNY_PRUNING]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HaarDetectionType.ScaleImage">
            <summary>
            For each scale factor used the function will downscale the image rather than "zoom" the feature coordinates in the classifier cascade. 
            Currently, the option can only be used alone, i.e. the flag can not be set together with the others.
            [CV_HAAR_SCALE_IMAGE]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HaarDetectionType.FindBiggestObject">
            <summary>
            If it is set, the function finds the largest object (if any) in the image. That is, the output sequence will contain one (or zero) element(s).
            [CV_HAAR_FIND_BIGGEST_OBJECT]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HaarDetectionType.DoRoughSearch">
            <summary>
            It should be used only when FindBiggestObject is set and min_neighbors > 0. 
            If the flag is set, the function does not look for candidates of a smaller size 
            as soon as it has found the object (with enough neighbor candidates) at the current scale. 
            Typically, when min_neighbors is fixed, the mode yields less accurate (a bit larger) object rectangle 
            than the regular single-object mode (flags=FindBiggestObject), 
            but it is much faster, up to an order of magnitude. A greater value of min_neighbors may be specified to improve the accuracy.
            [CV_HAAR_DO_ROUGH_SEARCH]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CpuFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.HistCompMethods">
            <summary>
            Comparison methods for cvCompareHist
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HistCompMethods.Correl">
            <summary>
            Correlation [CV_COMP_CORREL]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HistCompMethods.Chisqr">
            <summary>
            Chi-Square [CV_COMP_CHISQR]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HistCompMethods.Intersect">
            <summary>
            Intersection [CV_COMP_INTERSECT]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HistCompMethods.Bhattacharyya">
            <summary>
            Bhattacharyya distance [CV_COMP_BHATTACHARYYA]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HistCompMethods.Hellinger">
            <summary>
            Synonym for HISTCMP_BHATTACHARYYA
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HistCompMethods.ChisqrAlt">
            <summary>
            Alternative Chi-Square
            \f[d(H_1,H_2) =  2 * \sum _I  \frac{\left(H_1(I)-H_2(I)\right)^2}{H_1(I)+H_2(I)}\f] 
            This alternative formula is regularly used for texture comparison. See e.g. @cite Puzicha1997 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HistCompMethods.KLDiv">
            <summary>
            Kullback-Leibler divergence 
            \f[d(H_1,H_2) = \sum _I H_1(I) \log \left(\frac{H_1(I)}{H_2(I)}\right)\f] 
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.HomographyMethods">
            <summary>
            The method used to computed homography matrix
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HomographyMethods.None">
            <summary>
            Regular method using all the point pairs
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HomographyMethods.LMedS">
            <summary>
            Least-Median robust method
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HomographyMethods.Ransac">
            <summary>
            RANSAC-based robust method
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HomographyMethods.Rho">
            <summary>
            RHO algorithm
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.HoughMethods">
            <summary>
            Variants of a Hough transform
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HoughMethods.Standard">
            <summary>
            classical or standard Hough transform. 
            Every line is represented by two floating-point numbers \f$(\rho, \theta)\f$ , 
            where \f$\rho\f$ is a distance between (0,0) point and the line, 
            and \f$\theta\f$ is the angle between x-axis and the normal to the line. 
            Thus, the matrix must be (the created sequence will be) of CV_32FC2 type
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HoughMethods.Probabilistic">
            <summary>
            probabilistic Hough transform (more efficient in case if the picture contains 
            a few long linear segments). It returns line segments rather than the whole line. 
            Each segment is represented by starting and ending points, and the matrix must be 
            (the created sequence will be) of the CV_32SC4 type.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HoughMethods.MultiScale">
            <summary>
            multi-scale variant of the classical Hough transform. 
            The lines are encoded the same way as HOUGH_STANDARD.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HoughMethods.Gradient">
            <summary>
            basically *21HT*, described in @cite Yuen90
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ImwriteFlags">
            <summary>
            The format type IDs for cv::imwrite and cv::inencode
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.JpegQuality">
            <summary>
            For JPEG, it can be a quality from 0 to 100 (the higher is the better). Default value is 95.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.JpegProgressive">
            <summary>
            Enable JPEG features, 0 or 1, default is False.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.JpegOptimize">
            <summary>
            Enable JPEG features, 0 or 1, default is False.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.JpegRstInterval">
            <summary>
            JPEG restart interval, 0 - 65535, default is 0 - no restart.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.JpegLumaQuality">
            <summary>
            Separate luma quality level, 0 - 100, default is 0 - don't use.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.JpegChromaQuality">
            <summary>
            Separate chroma quality level, 0 - 100, default is 0 - don't use.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.PngCompression">
            <summary>
            For PNG, it can be the compression level from 0 to 9. 
            A higher value means a smaller size and longer compression time. Default value is 3.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.PngStrategy">
            <summary>
            One of cv::ImwritePNGFlags, default is IMWRITE_PNG_STRATEGY_DEFAULT.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.PngBilevel">
            <summary>
            Binary level PNG, 0 or 1, default is 0.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.PxmBinary">
            <summary>
            For PPM, PGM, or PBM, it can be a binary format flag, 0 or 1. Default value is 1.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImwriteFlags.WebPQuality">
            <summary>
            For WEBP, it can be a quality from 1 to 100 (the higher is the better). By default (without any parameter) and for quality above 100 the lossless compression is used.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.InpaintMethod">
            <summary>
            The inpainting method
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InpaintMethod.NS">
            <summary>
            Navier-Stokes based method.
            [CV_INPAINT_NS]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InpaintMethod.Telea">
            <summary>
            The method by Alexandru Telea
            [CV_INPAINT_TELEA]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.InterpolationFlags">
            <summary>
            Interpolation algorithm
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InterpolationFlags.Nearest">
            <summary>
            Nearest-neighbor interpolation, 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InterpolationFlags.Linear">
            <summary>
            Bilinear interpolation (used by default) 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InterpolationFlags.Cubic">
            <summary>
            Bicubic interpolation. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InterpolationFlags.Area">
            <summary>
            Resampling using pixel area relation. It is the preferred method for image decimation that gives moire-free results. In case of zooming it is similar to CV_INTER_NN method. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InterpolationFlags.Lanczos4">
            <summary>
            Lanczos interpolation over 8x8 neighborhood
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InterpolationFlags.Max">
            <summary>
            mask for interpolation codes
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InterpolationFlags.WarpFillOutliers">
            <summary>
            Fill all the destination image pixels. If some of them correspond to outliers in the source image, they are set to fillval. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.InterpolationFlags.WarpInverseMap">
            <summary>
            Indicates that matrix is inverse transform from destination image to source and, 
            thus, can be used directly for pixel interpolation. Otherwise, the function finds the inverse transform from map_matrix. 
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DecompTypes">
            <summary>
            Inversion methods
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DecompTypes.LU">
            <summary>
            Gaussian elimination with the optimal pivot element chosen.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DecompTypes.SVD">
            <summary>
            singular value decomposition (SVD) method; 
            the system can be over-defined and/or the matrix src1 can be singular
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DecompTypes.Eig">
            <summary>
            eigenvalue decomposition; the matrix src1 must be symmetrical
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DecompTypes.Cholesky">
            <summary>
            Cholesky \f$LL^T\f$ factorization; the matrix src1 must be symmetrical 
            and positively defined
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DecompTypes.QR">
            <summary>
            QR factorization; the system can be over-defined and/or the matrix 
            src1 can be singular 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DecompTypes.Normal">
            <summary>
            while all the previous flags are mutually exclusive, 
            this flag can be used together with any of the previous
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.KMeansFlags">
            <summary>
            Miscellaneous flags for cv::kmeans
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KMeansFlags.RandomCenters">
            <summary>
            Select random initial centers in each attempt.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KMeansFlags.PpCenters">
            <summary>
            Use kmeans++ center initialization by Arthur and Vassilvitskii [Arthur2007].
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KMeansFlags.UseInitialLabels">
            <summary>
            During the first (and possibly the only) attempt, use the
            user-supplied labels instead of computing them from the initial centers. 
            For the second and further attempts, use the random or semi-random centers. 
            Use one of KMEANS_\*_CENTERS flag to specify the exact method.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.LineTypes">
            <summary>
            Type of the line
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineTypes.Filled">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineTypes.Link8">
            <summary>
            8-connected line.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineTypes.Link4">
            <summary>
            4-connected line.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LineTypes.AntiAlias">
            <summary>
            Antialiased line. 
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ImreadModes">
            <summary>
            Specifies colorness and Depth of the loaded image
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImreadModes.Unchanged">
            <summary>
            If set, return the loaded image as is (with alpha channel, otherwise it gets cropped).
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImreadModes.GrayScale">
            <summary>
            If set, always convert image to the single channel grayscale image.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImreadModes.Color">
            <summary>
            If set, always convert image to the 3 channel BGR color image.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImreadModes.AnyDepth">
            <summary>
            If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImreadModes.AnyColor">
            <summary>
            If set, the image is read in any possible color format.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ImreadModes.LoadGdal">
            <summary>
            If set, use the gdal driver for loading the image.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.MarkerStyle">
            <summary>
            Marker styles for Mat.DrawMarker
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.CircleLine">
            <summary>
            A circle polyline
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.CircleFilled">
            <summary>
            A filled circle
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.Cross">
            <summary>
            A cross
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.TiltedCross">
            <summary>
            A tilted cross
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.CircleAndCross">
            <summary>
            A circle and a cross
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.CircleAndTiltedCross">
            <summary>
            A circle and a tilted cross
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.DiamondLine">
            <summary>
            A diamond polyline
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.DiamondFilled">
            <summary>
            A filled diamond
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.SquareLine">
            <summary>
            A square polyline
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MarkerStyle.SquareFilled">
            <summary>
            A filledsquare
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ShapeMatchModes">
            <summary>
            Comparison methods for cv::matchShapes
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ShapeMatchModes.I1">
            <summary>
            \f[I_1(A,B) =  \sum _{i=1...7}  \left |  \frac{1}{m^A_i} -  \frac{1}{m^B_i} \right |\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ShapeMatchModes.I2">
            <summary>
            \f[I_2(A,B) =  \sum _{i=1...7}  \left | m^A_i - m^B_i  \right |\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ShapeMatchModes.I3">
            <summary>
            \f[I_3(A,B) =  \max _{i=1...7}  \frac{ \left| m^A_i - m^B_i \right| }{ \left| m^A_i \right| }\f]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.TemplateMatchModes">
            <summary>
            Specifies the way the template must be compared with image regions
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.TemplateMatchModes.SqDiff">
            <summary>
            \f[R(x,y)= \sum _{x',y'} (T(x',y')-I(x+x',y+y'))^2\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.TemplateMatchModes.SqDiffNormed">
            <summary>
            \f[R(x,y)= \frac{\sum_{x',y'} (T(x',y')-I(x+x',y+y'))^2}{\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.TemplateMatchModes.CCorr">
            <summary>
            \f[R(x,y)= \sum _{x',y'} (T(x',y')  \cdot I(x+x',y+y'))\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.TemplateMatchModes.CCorrNormed">
            <summary>
            \f[R(x,y)= \frac{\sum_{x',y'} (T(x',y') \cdot I(x+x',y+y'))}{\sqrt{\sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.TemplateMatchModes.CCoeff">
            <summary>
            \f[R(x,y)= \sum _{x',y'} (T'(x',y')  \cdot I'(x+x',y+y'))\f]
            where
            \f[\begin{array}{l} T'(x',y')=T(x',y') - 1/(w  \cdot h)  \cdot \sum _{x'',y''} T(x'',y'') \\ I'(x+x',y+y')=I(x+x',y+y') - 1/(w  \cdot h)  \cdot \sum _{x'',y''} I(x+x'',y+y'') \end{array}\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.TemplateMatchModes.CCoeffNormed">
            <summary>
            \f[R(x,y)= \frac{ \sum_{x',y'} (T'(x',y') \cdot I'(x+x',y+y')) }{ \sqrt{\sum_{x',y'}T'(x',y')^2 \cdot \sum_{x',y'} I'(x+x',y+y')^2} }\f]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.MorphTypes">
            <summary>
            Type of morphological operation
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphTypes.ERODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphTypes.DILATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphTypes.Open">
            <summary>
            Opening 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphTypes.Close">
            <summary>
            Closing
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphTypes.Gradient">
            <summary>
            Morphological gradient
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphTypes.TopHat">
            <summary>
            "Top hat"
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MorphTypes.BlackHat">
            <summary>
            "Black hat"
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.MouseEvent">
            <summary>
            Mouse events
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.MouseMove">
            <summary>
            [EVENT_MOUSEMOVE]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.LButtonDown">
            <summary>
            [EVENT_LBUTTONDOWN]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.RButtonDown">
            <summary>
            [EVENT_RBUTTONDOWN]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.MButtonDown">
            <summary>
            [CV_EVENT_MBUTTONDOWN]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.LButtonUp">
            <summary>
            [EVENT_LBUTTONUP]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.RButtonUp">
            <summary>
            [EVENT_RBUTTONUP]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.MButtonUp">
            <summary>
            [EVENT_MBUTTONUP]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.LButtonDoubleClick">
            <summary>
            [EVENT_LBUTTONDBLCLK]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.RButtonDoubleClick">
            <summary>
            [EVENT_RBUTTONDBLCLK]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.MButtonDoubleClick">
            <summary>
            [EVENT_MBUTTONDBLCLK]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.MouseWheel">
            <summary>
            [EVENT_MOUSEWHEEL]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.MouseHWheel">
            <summary>
            [EVENT_MOUSEHWHEEL]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.FlagLButton">
            <summary>
            [EVENT_FLAG_LBUTTON]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.FlagRButton">
            <summary>
            [EVENT_FLAG_RBUTTON]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.FlagMButton">
            <summary>
            [EVENT_FLAG_MBUTTON]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.FlagCtrlKey">
            <summary>
            [EVENT_FLAG_CTRLKEY]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.FlagShiftKey">
            <summary>
            [EVENT_FLAG_SHIFTKEY]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MouseEvent.FlagAltKey">
            <summary>
            [EVENT_FLAG_ALTKEY]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.NormTypes">
            <summary>
            Type of norm
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NormTypes.INF">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NormTypes.L1">
            <summary>
            The L1-norm (sum of absolute values) of the array is normalized.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NormTypes.L2">
            <summary>
            The (Euclidean) L2-norm of the array is normalized.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NormTypes.L2SQR">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NormTypes.Hamming">
             <summary>
            
             </summary>
        </member>
        <member name="F:OpenCv30Sharp.NormTypes.Hamming2">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NormTypes.Relative">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.NormTypes.MinMax">
            <summary>
            The array values are scaled and shifted to the specified range.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.PixelConnectivity">
            <summary>
            PixelConnectivity for LineIterator
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.PixelConnectivity.Connectivity4">
            <summary>
            Connectivity 4 (N,S,E,W)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.PixelConnectivity.Connectivity8">
            <summary>
            Connectivity 8 (N,S,E,W,NE,SE,SW,NW)
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ReduceDimension">
            <summary>
            The dimension index along which the matrix is reduce.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ReduceDimension.Row">
            <summary>
            The matrix is reduced to a single row.
            [= 0]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ReduceDimension.Column">
            <summary>
            The matrix is reduced to a single column.
            [= 1]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ReduceDimension.Auto">
            <summary>
            The dimension is chosen automatically by analysing the dst size. 
            [= -1]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ReduceTypes">
            <summary>
            The reduction operations for cvReduce
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ReduceTypes.Sum">
            <summary>
            The output is the sum of all the matrix rows/columns.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ReduceTypes.Avg">
            <summary>
            The output is the mean vector of all the matrix rows/columns.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ReduceTypes.Max">
            <summary>
            The output is the maximum (column/row-wise) of all the matrix rows/columns.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ReduceTypes.Min">
            <summary>
            The output is the minimum (column/row-wise) of all the matrix rows/columns.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.SortFlags">
            <summary>
            Signals an error and raises the exception.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SortFlags.EveryRow">
            <summary>
            each matrix row is sorted independently
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SortFlags.EveryColumn">
            <summary>
            each matrix column is sorted independently; 
            this flag and the previous one are mutually exclusive.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SortFlags.Ascending">
            <summary>
            each matrix row is sorted in the ascending order.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SortFlags.Descending">
            <summary>
            each matrix row is sorted in the descending order; 
            this flag and the previous one are also mutually exclusive.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.StereoRectificationFlags">
            <summary>
            The operation flags for cvStereoRectify
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.StereoRectificationFlags.None">
            <summary>
            Default value (=0).
            the function can shift one of the image in horizontal or vertical direction (depending on the orientation of epipolar lines) in order to maximise the useful image area. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.StereoRectificationFlags.ZeroDisparity">
            <summary>
            the function makes the principal points of each camera have the same pixel coordinates in the rectified views. 
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ThresholdTypes">
            <summary>
            Thresholding type
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ThresholdTypes.Binary">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{\texttt{maxval}}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{0}{otherwise}\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ThresholdTypes.BinaryInv">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{0}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{\texttt{maxval}}{otherwise}\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ThresholdTypes.Trunc">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{\texttt{threshold}}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{\texttt{src}(x,y)}{otherwise}\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ThresholdTypes.Tozero">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{\texttt{src}(x,y)}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{0}{otherwise}\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ThresholdTypes.TozeroInv">
            <summary>
            \f[\texttt{dst} (x,y) =  \fork{0}{if \(\texttt{src}(x,y) > \texttt{thresh}\)}{\texttt{src}(x,y)}{otherwise}\f]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ThresholdTypes.Mask">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ThresholdTypes.Otsu">
            <summary>
            flag, use Otsu algorithm to choose the optimal threshold value
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ThresholdTypes.Triangle">
            <summary>
            flag, use Triangle algorithm to choose the optimal threshold value
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.WindowMode">
            <summary>
            Flags for the window
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowMode.Normal">
            <summary>
            the user can resize the window (no constraint) / 
            also use to switch a fullscreen window to a normal size
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowMode.AutoSize">
            <summary>
            the user cannot resize the window, the size is constrainted by the image displayed
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowMode.OpenGL">
            <summary>
            window with opengl support
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowMode.FullScreen">
            <summary>
            change the window to fullscreen
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowMode.FreeRatio">
            <summary>
            the image expends as much as it can (no ratio constraint)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowMode.KeepRatio">
            <summary>
            the ratio of the image is respected
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.WindowProperty">
            <summary>
            Property identifiers for cvGetWindowProperty/cvSetWindowProperty
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowProperty.Fullscreen">
            <summary>
            fullscreen property (can be WINDOW_NORMAL or WINDOW_FULLSCREEN)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowProperty.AutoSize">
            <summary>
            autosize property (can be WINDOW_NORMAL or WINDOW_AUTOSIZE)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowProperty.AspectRatio">
            <summary>
            window's aspect ration (can be set to WINDOW_FREERATIO or WINDOW_KEEPRATIO)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.WindowProperty.OpenGL">
            <summary>
            opengl support
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ICvPtrHolder">
            <summary>
            Represents a OpenCV-based class which has a native pointer. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ICvPtrHolder.CvPtr">
            <summary>
            Unmanaged OpenCV data pointer
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ImageEncodingParam">
            <summary>
            The format-specific save parameters for cv::imwrite and cv::imencode
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ImageEncodingParam.EncodingId">
            <summary>
            format type ID
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ImageEncodingParam.Value">
            <summary>
            value of parameter
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ImageEncodingParam.#ctor(OpenCv30Sharp.ImwriteFlags,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="id">format type ID</param>
            <param name="value">value of parameter</param>
        </member>
        <member name="T:OpenCv30Sharp.FourCCCalcurator">
            <summary>
            Managed wrapper of all OpenCV functions
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FourCCCalcurator.Run(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            4つの文字からFOURCCの整数値を得る
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <param name="c3"></param>
            <param name="c4"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FourCCCalcurator.Run(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            4つの文字からFOURCCの整数値を得る
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <param name="c3"></param>
            <param name="c4"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FourCCCalcurator.Run(System.String)">
            <summary>
            4つの文字からFOURCCの整数値を得る
            </summary>
            <param name="fourcc"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.BackgroundSubtractorGMG">
            <summary>
            Background Subtractor module. Takes a series of images and returns a sequence of mask (8UC1)
             images of the same size, where 255 indicates Foreground and 0 represents Background.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BackgroundSubtractorGMG.objectPtr">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BackgroundSubtractorGMG.disposed">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractorGMG.Create(System.Int32,System.Double)">
            <summary>
            
            </summary>
            <param name="initializationFrames"></param>
            <param name="decisionThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractorGMG.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.MaxFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.DefaultLearningRate">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.NumFrames">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.QuantizationLevels">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.BackgroundPrior">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.SmoothingRadius">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.DecisionThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.UpdateBackgroundModel">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.MinVal">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorGMG.MaxVal">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.BackgroundSubtractorMOG">
            <summary>
            Gaussian Mixture-based Backbround/Foreground Segmentation Algorithm
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BackgroundSubtractorMOG.objectPtr">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BackgroundSubtractorMOG.disposed">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractorMOG.Create(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="history"></param>
            <param name="nMixtures"></param>
            <param name="backgroundRatio"></param>
            <param name="noiseSigma"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractorMOG.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG.History">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG.NMixtures">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG.BackgroundRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG.NoiseSigma">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.StereoMatcher">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.StereoMatcher.#ctor(System.IntPtr)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoMatcher.MinDisparity">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoMatcher.NumDisparities">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoMatcher.BlockSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoMatcher.SpeckleWindowSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoMatcher.SpeckleRange">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoMatcher.Disp12MaxDiff">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.DescriptorFormat">
            <summary>
            TODO
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Gpu.DescriptorFormat.RowByRow">
            <summary>
            
            [HOGDescriptor::DESCR_FORMAT_ROW_BY_ROW]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Gpu.DescriptorFormat.ColByCol">
            <summary>
            
            [HOGDescriptor::DESCR_FORMAT_COL_BY_COL]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.DeviceInfo">
            <summary>
            Gives information about the given GPU
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DeviceInfo.#ctor">
            <summary>
            Creates DeviceInfo object for the current GPU
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DeviceInfo.#ctor(System.Int32)">
            <summary>
            Creates DeviceInfo object for the given GPU
            </summary>
            <param name="deviceId"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DeviceInfo.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.DeviceId">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.MajorVersion">
            <summary>
            Return compute capability versions
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.MinorVersion">
            <summary>
            Return compute capability versions
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.MultiProcessorCount">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.SharedMemPerBlock">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DeviceInfo.QueryMemory(System.Int64@,System.Int64@)">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.FreeMemory">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.TotalMemory">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DeviceInfo.Supports(OpenCv30Sharp.Gpu.FeatureSet)">
            <summary>
            Checks whether device supports the given feature
            </summary>
            <param name="featureSet"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.IsCompatible">
            <summary>
            Checks whether the GPU module can be run on the given device
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DeviceInfo.CanMapHostMemory">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.DisposableGpuObject">
            <summary>
            An abstract class in GPU module that implements DisposableCvObject
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DisposableGpuObject.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DisposableGpuObject.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DisposableGpuObject.#ctor(System.Boolean)">
            <summary>
             
            </summary>
            <param name="isEnabledDispose"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DisposableGpuObject.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
            <param name="isEnabledDispose"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.DisposableGpuObject.ThrowIfNotAvailable">
            <summary>
            Checks whether the opencv_gpu*.dll includes CUDA support.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.DisposableGpuObject.IsGpuCompatible">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.GpuMat">
            <summary>
            Smart pointer for GPU memory with reference counting. Its interface is mostly similar with cv::Mat.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Gpu.GpuMat.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::gpu::GpuMat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor">
            <summary>
            Creates empty GpuMat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) </param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType.CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.MatType,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="size">2D array size: Size(cols, rows) </param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            creates a matrix for other matrix
            </summary>
            <param name="m">Array that (as a whole) is assigned to the constructed matrix.</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            creates a matrix for other matrix
            </summary>
            <param name="m">GpuMat that (as a whole) is assigned to the constructed matrix.</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType,OpenCv30Sharp.Scalar)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.MatType,OpenCv30Sharp.Scalar)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) .</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. </param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.#ctor(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix..</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Release">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.op_Explicit(OpenCv30Sharp.Mat)~OpenCv30Sharp.Gpu.GpuMat">
            <summary>
            converts header to GpuMat
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.op_Implicit(OpenCv30Sharp.Gpu.GpuMat)~OpenCv30Sharp.Mat">
            <summary>
            converts header to Mat
            </summary>
            <param name="gpumat"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Flags">
            <summary>
            includes several bit-fields: 
             1.the magic signature 
             2.continuity flag 
             3.depth 
             4.number of channels
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Rows">
            <summary>
            the number of rows
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Cols">
            <summary>
            the number of columns
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Height">
            <summary>
            the number of rows
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Width">
            <summary>
            the number of columns
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Data">
            <summary>
            pointer to the data
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.RefCount">
            <summary>
            pointer to the reference counter;
            when matrix points to user-allocated data, the pointer is NULL
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.DataStart">
            <summary>
            helper fields used in locateROI and adjustROI
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.DataEnd">
            <summary>
            helper fields used in locateROI and adjustROI
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Bpp">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Item(OpenCv30Sharp.Rect)">
            <summary>
            
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Item(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            
            </summary>
            <param name="rowRange"></param>
            <param name="colRange"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart">Start row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="rowEnd">End row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colStart">Start column of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colEnd">End column of the extracted submatrix. The upper boundary is not included.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.GpuMat.Indexer`1">
            <summary>
            GpuMat Indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Indexer`1.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.GetGenericIndexer``1">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Get``1(System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.At``1(System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Set``1(System.Int32,System.Int32,``0)">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.ColRange(System.Int32,System.Int32)">
            <summary>
            returns a new matrix header for the specified column span
            </summary>
            <param name="startcol"></param>
            <param name="endcol"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.ColRange(OpenCv30Sharp.Range)">
            <summary>
            returns a new matrix header for the specified column span
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.GpuMat.ColIndexer">
            <summary>
            Mat column's indexer object
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.ColIndexer.#ctor(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.ColIndexer.Item(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.ColIndexer.Item(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified column span.
            </summary>
            <param name="startCol">An inclusive 0-based start index of the column span.</param>
            <param name="endCol">An exclusive 0-based ending index of the column span.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Col">
            <summary>
            Indexer to access GpuMat column
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.RowRange(System.Int32,System.Int32)">
            <summary>
            returns a new matrix header for the specified row span
            </summary>
            <param name="startrow"></param>
            <param name="endrow"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.RowRange(OpenCv30Sharp.Range)">
            <summary>
            returns a new matrix header for the specified row span
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.GpuMat.RowIndexer">
            <summary>
            Mat row's indexer object
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.RowIndexer.#ctor(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.RowIndexer.Item(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.RowIndexer.Item(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified column span.
            </summary>
            <param name="startCol">An inclusive 0-based start index of the column span.</param>
            <param name="endCol">An exclusive 0-based ending index of the column span.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMat.Row">
            <summary>
            Indexer to access GpuMat row
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.IsContinuous">
            <summary>
            returns true iff the GpuMatrix data is continuous
            (i.e. when there are no gaps between successive rows).
            similar to CV_IS_GpuMat_CONT(cvGpuMat->type)
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Channels">
            <summary>
            Returns the number of matrix channels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Depth">
            <summary>
            Returns the depth of a matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.ElemSize">
            <summary>
            Returns the matrix element size in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.ElemSize1">
            <summary>
            Returns the size of each matrix element channel in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Size">
            <summary>
            Returns a matrix size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Step">
            <summary>
            a distance between successive rows in bytes; includes the gap if any
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Step1">
            <summary>
            Returns a normalized step.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Type">
            <summary>
            Returns the type of a matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Empty">
            <summary>
            returns true if GpuMatrix data is NULL
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Upload(OpenCv30Sharp.Mat)">
            <summary>
            Pefroms blocking upload data to GpuMat.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Download(OpenCv30Sharp.Mat)">
            <summary>
            Downloads data from device to host memory. Blocking calls.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Clone">
            <summary>
            returns deep copy of the matrix, i.e. the data is copied
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.CopyTo(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            copies those matrix elements to "m"
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.CopyTo(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            copies those matrix elements to "m" that are marked with non-zero mask elements.
            </summary>
            <param name="m"></param>
            <param name="mask"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.ConvertTo(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.MatType,System.Double,System.Double)">
            <summary>
            converts matrix to another datatype with optional scalng. See cvConvertScale.
            </summary>
            <param name="dst"></param>
            <param name="rtype"></param>
            <param name="alpha"></param>
            <param name="beta"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.AssignTo(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.AssignTo(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.MatType)">
            <summary>
            
            </summary>
            <param name="m"></param>
            <param name="type"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.SetTo(OpenCv30Sharp.Scalar,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            sets some of the matrix elements to s, according to the mask
            </summary>
            <param name="s"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Reshape(System.Int32,System.Int32)">
            <summary>
            creates alternative matrix header for the same data, with different
            number of channels and/or different number of rows. see cvReshape.
            </summary>
            <param name="cn"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Create(System.Int32,System.Int32,OpenCv30Sharp.MatType)">
            <summary>
            allocates new matrix data unless the matrix already has specified size and type.
            previous data is unreferenced if needed.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. </param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Create(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            allocates new matrix data unless the matrix already has specified size and type.
            previous data is unreferenced if needed.
            </summary>
            <param name="size">2D array size: Size(cols, rows) </param>
            <param name="type">Array type. </param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Swap(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            swaps with other smart pointer
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.LocateROI(OpenCv30Sharp.Size@,OpenCv30Sharp.Point@)">
            <summary>
            locates matrix header within a parent matrix.
            </summary>
            <param name="wholeSize"></param>
            <param name="ofs"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.AdjustROI(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            moves/resizes the current matrix ROI inside the parent matrix.
            </summary>
            <param name="dtop"></param>
            <param name="dbottom"></param>
            <param name="dleft"></param>
            <param name="dright"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.Ptr(System.Int32)">
            <summary>
            returns pointer to y-th row
            </summary>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMat.ToString">
            <summary>
            Returns a string that represents this Mat.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.GpuMatIndexer`1">
            <summary>
            Abstract definition of Mat indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMatIndexer`1.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="F:OpenCv30Sharp.Gpu.GpuMatIndexer`1.parent">
            <summary>
            Parent matrix object
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Gpu.GpuMatIndexer`1.step">
            <summary>
            Step byte length for each dimension
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Gpu.GpuMatIndexer`1.sizeOfT">
            <summary>
            sizeof(T)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMatIndexer`1.#ctor(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Constructor
            </summary>
            <param name="parent"></param>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.GpuMatRowColIndexer">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.parent">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.#ctor(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.Item(System.Int32)">
            <summary>
            Creates/Sets a matrix header for the specified matrix row/column.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.Item(System.Int32,System.Int32)">
            <summary>
            Creates/Sets a matrix header for the specified row/column span.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.Item(OpenCv30Sharp.Range)">
            <summary>
            Creates/Sets a matrix header for the specified row/column span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.Get(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row/column.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.Get(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.Get(OpenCv30Sharp.Range)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.Set(System.Int32,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Creates/Sets a matrix header for the specified matrix row/column.
            </summary>
            <param name="pos"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.Set(System.Int32,System.Int32,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Creates/Sets a matrix header for the specified row/column span.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.GpuMatRowColIndexer.Set(OpenCv30Sharp.Range,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Creates/Sets a matrix header for the specified row/column span.
            </summary>
            <param name="range"></param>
            <param name="value"></param>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.StreamCallback">
            <summary>
            
            </summary>
            <param name="stream"></param>
            <param name="status"></param>
            <param name="userData"></param>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.Stream">
            <summary>
            Encapculates Cuda Stream. Provides interface for async coping.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Gpu.Stream.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::gpu::Stream* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.#ctor">
            <summary>
            Creates empty Stream
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.#ctor(OpenCv30Sharp.Gpu.Stream)">
            <summary>
            
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.Release">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.Gpu.Stream.Null">
            <summary>
            Empty stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.op_Explicit(OpenCv30Sharp.Gpu.Stream)~System.Boolean">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.QueryIfComplete">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.WaitForCompletion">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.EnqueueDownload(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.Mat)">
            <summary>
            Downloads asynchronously.
            Warning! cv::Mat must point to page locked memory (i.e. to CudaMem data or to its subMat)
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.EnqueueUpload(OpenCv30Sharp.Mat,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Uploads asynchronously.
            Warning! cv::Mat must point to page locked memory (i.e. to CudaMem data or to its ROI)
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.EnqueueCopy(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Copy asynchronously
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.EnqueueMemSet(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.Scalar)">
            <summary>
            Memory set asynchronously
            </summary>
            <param name="src"></param>
            <param name="val"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.EnqueueMemSet(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.Scalar,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Memory set asynchronously
            </summary>
            <param name="src"></param>
            <param name="val"></param>
            <param name="mask"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.EnqueueConvert(OpenCv30Sharp.Gpu.GpuMat,OpenCv30Sharp.Gpu.GpuMat,System.Int32,System.Double,System.Double)">
            <summary>
            converts matrix type, ex from float to uchar depending on type
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="dtype"></param>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Stream.EnqueueHostCallback(OpenCv30Sharp.Gpu.StreamCallback,System.Object)">
            <summary>
            Adds a callback to be called on the host after all currently enqueued items 
            in the stream have completed
            </summary>
            <param name="callback"></param>
            <param name="userData">Not supported</param>
        </member>
        <member name="T:OpenCv30Sharp.Gpu.Cv2Gpu">
            <summary>
            Functions of OpenCV GPU module
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.GetCudaEnabledDeviceCount">
            <summary>
            Returns the number of installed CUDA-enabled devices.
            Use this function before any other GPU functions calls. 
            If OpenCV is compiled without GPU support, this function returns 0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.GetDevice">
            <summary>
            Returns the current device index set by SetDevice() or initialized by default.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.SetDevice(System.Int32)">
            <summary>
            Sets a device and initializes it for the current thread.
            </summary>
            <param name="device">System index of a GPU device starting with 0.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.ResetDevice">
            <summary>
            Explicitly destroys and cleans up all resources associated with the current device in the current process.
            Any subsequent API call to this device will reinitialize the device.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.PrintCudaDeviceInfo(System.Int32)">
            <summary>
            
            </summary>
            <param name="device"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.PrintShortCudaDeviceInfo(System.Int32)">
            <summary>
            
            </summary>
            <param name="device"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.RegisterPageLocked(OpenCv30Sharp.Mat)">
            <summary>
            Page-locks the matrix m memory and maps it for the device(s)
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.UnregisterPageLocked(OpenCv30Sharp.Mat)">
            <summary>
            Unmaps the memory of matrix m, and makes it pageable again.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.CreateContinuous(System.Int32,System.Int32,OpenCv30Sharp.MatType,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Creates continuous GPU matrix
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type.</param>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.CreateContinuous(System.Int32,System.Int32,OpenCv30Sharp.MatType)">
            <summary>
            Creates continuous GPU matrix
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.CreateContinuous(OpenCv30Sharp.Size,OpenCv30Sharp.MatType,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Creates continuous GPU matrix
            </summary>
            <param name="size">Number of rows and columns in a 2D array.</param>
            <param name="type">Array type.</param>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.CreateContinuous(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            Creates continuous GPU matrix
            </summary>
            <param name="size">Number of rows and columns in a 2D array.</param>
            <param name="type">Array type.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.EnsureSizeIsEnough(System.Int32,System.Int32,OpenCv30Sharp.MatType,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Ensures that size of the given matrix is not less than (rows, cols) size
            and matrix type is match specified one too
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type.</param>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.EnsureSizeIsEnough(OpenCv30Sharp.Size,OpenCv30Sharp.MatType,OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Ensures that size of the given matrix is not less than (rows, cols) size
            and matrix type is match specified one too
            </summary>
            <param name="size">Number of rows and columns in a 2D array.</param>
            <param name="type">Array type.</param>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.Gpu.Cv2Gpu.ThrowIfGpuNotAvailable">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Face.FaceRecognizer">
             <summary>
            
             </summary>
        </member>
        <member name="F:OpenCv30Sharp.Face.FaceRecognizer.recognizerPtr">
             <summary>
            
             </summary>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes.
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.CreateEigenFaceRecognizer(System.Int32,System.Double)">
             <summary>
            
             </summary>
             <param name="numComponents"></param>
             <param name="threshold"></param>
             <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.CreateFisherFaceRecognizer(System.Int32,System.Double)">
             <summary>
            
             </summary>
             <param name="numComponents"></param>
             <param name="threshold"></param>
             <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.CreateLBPHFaceRecognizer(System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
             <summary>
            
             </summary>
             <param name="radius"></param>
             <param name="neighbors"></param>
             <param name="gridX"></param>
             <param name="gridY"></param>
             <param name="threshold"></param>
             <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.Train(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Trains a FaceRecognizer.
            </summary>
            <param name="src"></param>
            <param name="labels"></param>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.Update(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Updates a FaceRecognizer.
            </summary>
            <param name="src"></param>
            <param name="labels"></param>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.Predict(OpenCv30Sharp.InputArray)">
            <summary>
            Gets a prediction from a FaceRecognizer.
            </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.Predict(OpenCv30Sharp.InputArray,System.Int32@,System.Double@)">
            <summary>
            Predicts the label and confidence for a given sample.
            </summary>
            <param name="src"></param>
            <param name="label"></param>
            <param name="confidence"></param>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.Save(System.String)">
            <summary>
            Serializes this object to a given filename.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.Load(System.String)">
            <summary>
            Deserializes this object from a given filename.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.Save(OpenCv30Sharp.FileStorage)">
            <summary>
            Serializes this object to a given cv::FileStorage.
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:OpenCv30Sharp.Face.FaceRecognizer.Load(OpenCv30Sharp.FileStorage)">
            <summary>
            Deserializes this object from a given cv::FileStorage.
            </summary>
            <param name="fs"></param>
        </member>
        <member name="T:OpenCv30Sharp.FindCirclesGridFlags">
            <summary>
            Method for solving a PnP problem:
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FindCirclesGridFlags.SymmetricGrid">
            <summary>
            uses symmetric pattern of circles.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FindCirclesGridFlags.AsymmetricGrid">
            <summary>
            uses asymmetric pattern of circles.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FindCirclesGridFlags.Clustering">
            <summary>
            uses a special algorithm for grid detection. It is more robust to perspective distortions but much more sensitive to background clutter.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.FileStorage">
            <summary>
            XML/YAML File Storage Class.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.#ctor">
            <summary>
            Default constructor.
            You should call FileStorage::open() after initialization.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.#ctor(System.String,OpenCv30Sharp.FileStorage.Mode,System.String)">
            <summary>
            The full constructor
            </summary>
            <param name="source">Name of the file to open or the text string to read the data from. 
            Extension of the file (.xml or .yml/.yaml) determines its format 
            (XML or YAML respectively). Also you can append .gz to work with 
            compressed files, for example myHugeMatrix.xml.gz. 
            If both FileStorage::WRITE and FileStorage::MEMORY flags are specified, 
            source is used just to specify the output file format 
            (e.g. mydata.xml, .yml etc.).</param>
            <param name="flags"></param>
            <param name="encoding">Encoding of the file. Note that UTF-16 XML encoding is not supported 
            currently and you should use 8-bit encoding instead of it.</param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:OpenCv30Sharp.FileStorage.Item(System.String)">
            <summary>
            Returns the specified element of the top-level mapping
            </summary>
            <param name="nodeName"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileStorage.ElName">
            <summary>
            the currently written element
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.FileStorage.Structs">
            <summary>
            the stack of written structures
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.FileStorage.State">
            <summary>
            the writer state
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Open(System.String,OpenCv30Sharp.FileStorage.Mode,System.String)">
            <summary>
            operator that performs PCA. The previously stored data, if any, is released
            </summary>
            <param name="fileName"></param>
            <param name="flags"></param>
            <param name="encoding">Encoding of the file. Note that UTF-16 XML encoding is not supported 
            currently and you should use 8-bit encoding instead of it.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.IsOpened">
            <summary>
            Returns true if the object is associated with currently opened file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Release">
            <summary>
            Closes the file and releases all the memory buffers
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.ReleaseAndGetString">
            <summary>
            Closes the file, releases all the memory buffers and returns the text string
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.GetFirstTopLevelNode">
            <summary>
            Returns the first element of the top-level mapping
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Root(System.Int32)">
            <summary>
            Returns the top-level mapping. YAML supports multiple streams
            </summary>
            <param name="streamidx"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.WriteRaw(System.String,System.IntPtr,System.Int64)">
            <summary>
            Writes one or more numbers of the specified format to the currently written structure
            </summary>
            <param name="fmt"></param>
            <param name="vec"></param>
            <param name="len"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.WriteObj(System.String,System.IntPtr)">
            <summary>
            Writes the registered C structure (CvMat, CvMatND, CvSeq). See cvWrite()
            </summary>
            <param name="name"></param>
            <param name="obj"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.GetDefaultObjectName(System.String)">
            <summary>
            Returns the normalized object name for the specified file name
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Write(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Write(System.String,System.Single)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Write(System.String,System.Double)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Write(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Write(System.String,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Write(System.String,OpenCv30Sharp.SparseMat)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Write(System.String,System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint})">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.Write(System.String,System.Collections.Generic.IEnumerable{OpenCv30Sharp.DMatch})">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.WriteScalar(System.Int32)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.WriteScalar(System.Single)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.WriteScalar(System.Double)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileStorage.WriteScalar(System.String)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:OpenCv30Sharp.FileStorage.Mode">
            <summary>
            File storage mode
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FileStorage.Mode.Read">
            <summary>
            The storage is open for reading
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FileStorage.Mode.Write">
            <summary>
            The storage is open for writing
            [CV_STORAGE_WRITE]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FileStorage.Mode.Append">
            <summary>
            The storage is open for appending
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FileStorage.Mode.Memory">
            <summary>
            flag, read data from source or write data to the internal buffer
            (which is returned by FileStorage::release)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FileStorage.Mode.FotmatMask">
            <summary>
            mask for format flags
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FileStorage.Mode.FormatAuto">
            <summary>
            flag, auto format
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FileStorage.Mode.FormatXml">
            <summary>
            flag, XML format
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.FileStorage.Mode.FormatYaml">
            <summary>
            flag, YAML format
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.FileNode">
            <summary>
            File Storage Node class
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.#ctor(System.IntPtr)">
            <summary>
            Initializes from cv::FileNode*
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.op_Explicit(OpenCv30Sharp.FileNode)~System.Int32">
            <summary>
            Returns the node content as an integer. If the node stores floating-point number, it is rounded.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.op_Explicit(OpenCv30Sharp.FileNode)~System.Single">
            <summary>
            Returns the node content as float
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.op_Explicit(OpenCv30Sharp.FileNode)~System.Double">
            <summary>
            Returns the node content as double
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.op_Explicit(OpenCv30Sharp.FileNode)~System.String">
            <summary>
            Returns the node content as text string
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.op_Explicit(OpenCv30Sharp.FileNode)~OpenCv30Sharp.Mat">
            <summary>
            Returns the node content as OpenCV Mat
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.Item(System.String)">
            <summary>
            returns element of a mapping node
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.Item(System.Int32)">
            <summary>
            returns element of a sequence node
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.Empty">
            <summary>
            Returns true if the node is empty
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.IsNone">
            <summary>
            Returns true if the node is a "none" object
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.IsSeq">
            <summary>
            Returns true if the node is a sequence
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.IsMap">
            <summary>
            Returns true if the node is a mapping
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.IsInt">
            <summary>
            Returns true if the node is an integer
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.IsReal">
            <summary>
            Returns true if the node is a floating-point number
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.IsString">
            <summary>
            Returns true if the node is a text string
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.IsNamed">
            <summary>
            Returns true if the node has a name
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.Name">
            <summary>
            Returns the node name or an empty string if the node is nameless
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.FileNode.Size">
            <summary>
            Returns the number of elements in the node, if it is a sequence or mapping, or 1 otherwise.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadRaw(System.String,System.IntPtr,System.Int64)">
            <summary>
            Reads node elements to the buffer with the specified format
            </summary>
            <param name="fmt"></param>
            <param name="vec"></param>
            <param name="len"></param>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadObj">
            <summary>
            Reads the registered object and returns pointer to it
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadInt(System.Int32)">
            <summary>
            
            </summary>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadFloat(System.Single)">
            <summary>
            
            </summary>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadDouble(System.Double)">
            <summary>
            
            </summary>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadString(System.String)">
            <summary>
            
            </summary>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadMat(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="defaultMat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadSparseMat(OpenCv30Sharp.SparseMat)">
            <summary>
            
            </summary>
            <param name="defaultMat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadKeyPoints">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FileNode.ReadDMatches">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.MatExpr">
            <summary>
            Matrix expression
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.Abs">
            <summary>
            Computes absolute value of each matrix element
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Implicit(OpenCv30Sharp.MatExpr)~OpenCv30Sharp.Mat">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.ToMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Implicit(OpenCv30Sharp.Mat)~OpenCv30Sharp.MatExpr">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.FromMat(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_UnaryPlus(OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_UnaryNegation(OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_OnesComplement(OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Addition(OpenCv30Sharp.MatExpr,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Addition(OpenCv30Sharp.Mat,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="m"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Addition(OpenCv30Sharp.MatExpr,OpenCv30Sharp.Scalar)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Addition(OpenCv30Sharp.Scalar,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Addition(OpenCv30Sharp.MatExpr,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="e1"></param>
            <param name="e2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Subtraction(OpenCv30Sharp.MatExpr,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Subtraction(OpenCv30Sharp.Mat,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="m"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Subtraction(OpenCv30Sharp.MatExpr,OpenCv30Sharp.Scalar)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Subtraction(OpenCv30Sharp.Scalar,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Subtraction(OpenCv30Sharp.MatExpr,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="e1"></param>
            <param name="e2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Multiply(OpenCv30Sharp.MatExpr,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Multiply(OpenCv30Sharp.Mat,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="m"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Multiply(OpenCv30Sharp.MatExpr,System.Double)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Multiply(System.Double,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Multiply(OpenCv30Sharp.MatExpr,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="e1"></param>
            <param name="e2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Division(OpenCv30Sharp.MatExpr,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Division(OpenCv30Sharp.Mat,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="m"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Division(OpenCv30Sharp.MatExpr,System.Double)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Division(System.Double,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.op_Division(OpenCv30Sharp.MatExpr,OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="e1"></param>
            <param name="e2"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatExpr.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colStart"></param>
            <param name="colEnd"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatExpr.Item(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            
            </summary>
            <param name="rowRange"></param>
            <param name="colRange"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatExpr.Item(OpenCv30Sharp.Rect)">
            <summary>
            
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.MatExpr.ColIndexer">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.ColIndexer.#ctor(OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.MatExpr.ColIndexer.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatExpr.Col">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.Cross(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.Diag(System.Int32)">
            <summary>
            
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.Dot(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.Inv(OpenCv30Sharp.DecompTypes)">
            <summary>
            
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.Mul(OpenCv30Sharp.MatExpr,System.Double)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.Mul(OpenCv30Sharp.Mat,System.Double)">
            <summary>
            
            </summary>
            <param name="m"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.MatExpr.RowIndexer">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.RowIndexer.#ctor(OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.MatExpr.RowIndexer.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatExpr.Row">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatExpr.Size">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.SubMat(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colStart"></param>
            <param name="colEnd"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.SubMat(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            
            </summary>
            <param name="rowRange"></param>
            <param name="colRange"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.SubMat(OpenCv30Sharp.Rect)">
            <summary>
            
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExpr.T">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatExpr.Type">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.MatOfInt4">
            <summary>
            A matrix whose element is 32SC1 (cv::Mat_&lt;int&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(OpenCv30Sharp.Size,System.Int32)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(OpenCv30Sharp.MatOfInt4,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(OpenCv30Sharp.MatOfInt4,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(OpenCv30Sharp.MatOfInt4,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec4i[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec4i[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec4i[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec4i)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfInt4.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfInt4.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfInt4.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfInt4.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfInt4.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.FromArray(OpenCv30Sharp.Vec4i[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.FromArray(OpenCv30Sharp.Vec4i[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec4i})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt4.Add(OpenCv30Sharp.Vec4i)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.Mat">
            <summary>
            OpenCV C++ n-dimensional dense array class (cv::Mat)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Abs">
            <summary>
            Computes absolute value of each matrix element
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConvertScaleAbs(System.Double,System.Double)">
            <summary>
            Scales, computes absolute values and converts the result to 8-bit.
            </summary>
            <param name="alpha">The optional scale factor. [By default this is 1]</param>
            <param name="beta">The optional delta added to the scaled values. [By default this is 0]</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.LUT(OpenCv30Sharp.InputArray,System.Int32)">
            <summary>
            transforms array of numbers using a lookup table: dst(i)=lut(src(i))
            </summary>
            <param name="lut">Look-up table of 256 elements. 
            In the case of multi-channel source array, the table should either have 
            a single channel (in this case the same table is used for all channels)
             or the same number of channels as in the source array</param>
            <param name="interpolation"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.LUT(System.Byte[],System.Int32)">
            <summary>
            transforms array of numbers using a lookup table: dst(i)=lut(src(i))
            </summary>
            <param name="lut">Look-up table of 256 elements. 
            In the case of multi-channel source array, the table should either have 
            a single channel (in this case the same table is used for all channels)
             or the same number of channels as in the source array</param>
            <param name="interpolation"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Sum">
            <summary>
            computes sum of array elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CountNonZero">
            <summary>
            computes the number of nonzero array elements
            </summary>
            <returns>number of non-zero elements in mtx</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FindNonZero">
            <summary>
            returns the list of locations of non-zero pixels
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Mean(OpenCv30Sharp.InputArray)">
            <summary>
            computes mean value of selected array elements
            </summary>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MeanStdDev(OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.InputArray)">
            <summary>
            computes mean value and standard deviation of all or selected array elements
            </summary>
            <param name="mean">The output parameter: computed mean value</param>
            <param name="stddev">The output parameter: computed standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Norm(OpenCv30Sharp.NormTypes,OpenCv30Sharp.InputArray)">
            <summary>
            computes norm of the selected array part
            </summary>
            <param name="normType">Type of the norm</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Normalize(System.Double,System.Double,OpenCv30Sharp.NormTypes,System.Int32,OpenCv30Sharp.InputArray)">
            <summary>
            scales and shifts array elements so that either the specified norm (alpha) 
            or the minimum (alpha) and maximum (beta) array values get the specified values
            </summary>
            <param name="alpha">The norm value to normalize to or the lower range boundary 
            in the case of range normalization</param>
            <param name="beta">The upper range boundary in the case of range normalization; 
            not used for norm normalization</param>
            <param name="normType">The normalization type</param>
            <param name="dtype">When the parameter is negative, 
            the destination array will have the same type as src, 
            otherwise it will have the same number of channels as src and the depth =CV_MAT_DEPTH(rtype)</param>
            <param name="mask">The optional operation mask</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MinMaxLoc(System.Double@,System.Double@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MinMaxLoc(OpenCv30Sharp.Point@,OpenCv30Sharp.Point@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MinMaxLoc(System.Double@,System.Double@,OpenCv30Sharp.Point@,OpenCv30Sharp.Point@,OpenCv30Sharp.InputArray)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask used to select a sub-array</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MinMaxIdx(System.Double@,System.Double@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MinMaxIdx(System.Int32@,System.Int32@)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minIdx"></param>
            <param name="maxIdx"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MinMaxIdx(System.Double@,System.Double@,System.Int32@,System.Int32@,OpenCv30Sharp.InputArray)">
            <summary>
            finds global minimum and maximum array elements and returns their values and their locations
            </summary>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minIdx"></param>
            <param name="maxIdx"></param>
            <param name="mask"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Reduce(OpenCv30Sharp.ReduceDimension,OpenCv30Sharp.ReduceTypes,System.Int32)">
            <summary>
            transforms 2D matrix to 1D row or column vector by taking sum, minimum, maximum or mean value over all the rows
            </summary>
            <param name="dim">The dimension index along which the matrix is reduced. 
            0 means that the matrix is reduced to a single row and 1 means that the matrix is reduced to a single column</param>
            <param name="rtype"></param>
            <param name="dtype">When it is negative, the destination vector will have 
            the same type as the source matrix, otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), mtx.channels())</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Split">
            <summary>
            Copies each plane of a multi-channel array to a dedicated array
            </summary>
            <returns>The number of arrays must match mtx.channels() . 
            The arrays themselves will be reallocated if needed</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ExtractChannel(System.Int32)">
            <summary>
            extracts a single channel from src (coi is 0-based index)
            </summary>
            <param name="coi"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.InsertChannel(OpenCv30Sharp.InputOutputArray,System.Int32)">
            <summary>
            inserts a single channel to dst (coi is 0-based index)
            </summary>
            <param name="dst"></param>
            <param name="coi"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Flip(OpenCv30Sharp.FlipMode)">
            <summary>
            reverses the order of the rows, columns or both in a matrix
            </summary>
            <param name="flipCode">Specifies how to flip the array: 
            0 means flipping around the x-axis, positive (e.g., 1) means flipping around y-axis, 
            and negative (e.g., -1) means flipping around both axes. See also the discussion below for the formulas.</param>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Repeat(System.Int32,System.Int32)">
            <summary>
            replicates the input matrix the specified number of times in the horizontal and/or vertical direction
            </summary>
            <param name="ny">How many times the src is repeated along the vertical axis</param>
            <param name="nx">How many times the src is repeated along the horizontal axis</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.InRange(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            set mask elements for those array elements which are within the element-specific bounding box (dst = lowerb &lt;= src &amp;&amp; src &lt; upperb)
            </summary>
            <param name="lowerb">The inclusive lower boundary array of the same size and type as src</param>
            <param name="upperb">The exclusive upper boundary array of the same size and type as src</param>
            <returns>The destination array, will have the same size as src and CV_8U type</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.InRange(OpenCv30Sharp.Scalar,OpenCv30Sharp.Scalar)">
            <summary>
            set mask elements for those array elements which are within the element-specific bounding box (dst = lowerb &lt;= src &amp;&amp; src &lt; upperb)
            </summary>
            <param name="lowerb">The inclusive lower boundary array of the same size and type as src</param>
            <param name="upperb">The exclusive upper boundary array of the same size and type as src</param>
            <returns>The destination array, will have the same size as src and CV_8U type</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Sqrt">
            <summary>
            computes square root of each matrix element (dst = src**0.5)
            </summary>
            <returns>The destination array; will have the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Pow(System.Double)">
            <summary>
            raises the input matrix elements to the specified power (b = a**power)
            </summary>
            <param name="power">The exponent of power</param>
            <returns>The destination array; will have the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Exp">
            <summary>
            computes exponent of each matrix element (dst = e**src)
            </summary>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Log">
            <summary>
            computes natural logarithm of absolute value of each matrix element: dst = log(abs(src))
            </summary>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CheckRange(System.Boolean)">
            <summary>
            checks that each matrix element is within the specified range.
            </summary>
            <param name="quiet">The flag indicating whether the functions quietly 
            return false when the array elements are out of range, 
            or they throw an exception.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CheckRange(System.Boolean,OpenCv30Sharp.Point@,System.Double,System.Double)">
            <summary>
            checks that each matrix element is within the specified range.
            </summary>
            <param name="quiet">The flag indicating whether the functions quietly 
            return false when the array elements are out of range, 
            or they throw an exception.</param>
            <param name="pos">The optional output parameter, where the position of 
            the first outlier is stored.</param>
            <param name="minVal">The inclusive lower boundary of valid values range</param>
            <param name="maxVal">The exclusive upper boundary of valid values range</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PatchNaNs(System.Double)">
            <summary>
            converts NaN's to the given number
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MulTransposed(System.Boolean,OpenCv30Sharp.InputArray,System.Double,System.Int32)">
            <summary>
            multiplies matrix by its transposition from the left or from the right
            </summary>
            <param name="aTa">Specifies the multiplication ordering; see the description below</param>
            <param name="delta">The optional delta matrix, subtracted from src before the 
            multiplication. When the matrix is empty ( delta=Mat() ), it’s assumed to be 
            zero, i.e. nothing is subtracted, otherwise if it has the same size as src, 
            then it’s simply subtracted, otherwise it is "repeated" to cover the full src 
            and then subtracted. Type of the delta matrix, when it's not empty, must be the 
            same as the type of created destination matrix, see the rtype description</param>
            <param name="scale">The optional scale factor for the matrix product</param>
            <param name="dtype">When it’s negative, the destination matrix will have the 
            same type as src . Otherwise, it will have type=CV_MAT_DEPTH(rtype), 
            which should be either CV_32F or CV_64F</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Transpose">
            <summary>
            transposes the matrix
            </summary>
            <returns>The destination array of the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Transform(OpenCv30Sharp.InputArray)">
            <summary>
            performs affine transformation of each element of multi-channel input matrix
            </summary>
            <param name="m">The transformation matrix</param>
            <returns>The destination array; will have the same size and depth as src and as many channels as mtx.rows</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PerspectiveTransform(OpenCv30Sharp.InputArray)">
            <summary>
            performs perspective transformation of each element of multi-channel input matrix
            </summary>
            <param name="m">3x3 or 4x4 transformation matrix</param>
            <returns>The destination array; it will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CompleteSymm(System.Boolean)">
            <summary>
            extends the symmetrical matrix from the lower half or from the upper half
            </summary>
            <param name="lowerToUpper">If true, the lower half is copied to the upper half, 
            otherwise the upper half is copied to the lower half</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetIdentity(System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            initializes scaled identity matrix (not necessarily square). 
            </summary>
            <param name="s">The value to assign to the diagonal elements</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Determinant">
            <summary>
            computes determinant of a square matrix.
            The input matrix must have CV_32FC1 or CV_64FC1 type and square size.
            </summary>
            <returns>determinant of the specified matrix.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Trace">
            <summary>
            computes trace of a matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Sort(OpenCv30Sharp.SortFlags)">
            <summary>
            sorts independently each matrix row or each matrix column
            </summary>
            <param name="flags">The operation flags, a combination of the SortFlag values</param>
            <returns>The destination array of the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SortIdx(OpenCv30Sharp.SortFlags)">
            <summary>
            sorts independently each matrix row or each matrix column
            </summary>
            <param name="flags">The operation flags, a combination of SortFlag values</param>
            <returns>The destination integer array of the same size as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Dft(OpenCv30Sharp.DftFlags,System.Int32)">
            <summary>
            Performs a forward Discrete Fourier transform of 1D or 2D floating-point array.
            </summary>
            <param name="flags">Transformation flags, a combination of the DftFlag2 values</param>
            <param name="nonzeroRows">When the parameter != 0, the function assumes that 
            only the first nonzeroRows rows of the input array ( DFT_INVERSE is not set) 
            or only the first nonzeroRows of the output array ( DFT_INVERSE is set) contain non-zeros, 
            thus the function can handle the rest of the rows more efficiently and 
            thus save some time. This technique is very useful for computing array cross-correlation 
            or convolution using DFT</param>
            <returns>The destination array, which size and type depends on the flags</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Idft(OpenCv30Sharp.DftFlags,System.Int32)">
            <summary>
            Performs an inverse Discrete Fourier transform of 1D or 2D floating-point array.
            </summary>
            <param name="flags">Transformation flags, a combination of the DftFlag2 values</param>
            <param name="nonzeroRows">When the parameter != 0, the function assumes that 
            only the first nonzeroRows rows of the input array ( DFT_INVERSE is not set) 
            or only the first nonzeroRows of the output array ( DFT_INVERSE is set) contain non-zeros, 
            thus the function can handle the rest of the rows more efficiently and 
            thus save some time. This technique is very useful for computing array cross-correlation 
            or convolution using DFT</param>
            <returns>The destination array, which size and type depends on the flags</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Dct(OpenCv30Sharp.DctFlags)">
            <summary>
            performs forward or inverse 1D or 2D Discrete Cosine Transformation
            </summary>
            <param name="flags">Transformation flags, a combination of DctFlag2 values</param>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Idct(OpenCv30Sharp.DctFlags)">
            <summary>
            performs inverse 1D or 2D Discrete Cosine Transformation
            </summary>
            <param name="flags">Transformation flags, a combination of DctFlag2 values</param>
            <returns>The destination array; will have the same size and same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Randu(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            fills array with uniformly-distributed random numbers from the range [low, high)
            </summary>
            <param name="low">The inclusive lower boundary of the generated random numbers</param>
            <param name="high">The exclusive upper boundary of the generated random numbers</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Randu(OpenCv30Sharp.Scalar,OpenCv30Sharp.Scalar)">
            <summary>
            fills array with uniformly-distributed random numbers from the range [low, high)
            </summary>
            <param name="low">The inclusive lower boundary of the generated random numbers</param>
            <param name="high">The exclusive upper boundary of the generated random numbers</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Randn(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            fills array with normally-distributed random numbers with the specified mean and the standard deviation
            </summary>
            <param name="mean">The mean value (expectation) of the generated random numbers</param>
            <param name="stddev">The standard deviation of the generated random numbers</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Randn(OpenCv30Sharp.Scalar,OpenCv30Sharp.Scalar)">
            <summary>
            fills array with normally-distributed random numbers with the specified mean and the standard deviation
            </summary>
            <param name="mean">The mean value (expectation) of the generated random numbers</param>
            <param name="stddev">The standard deviation of the generated random numbers</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.RandShuffle(System.Double,OpenCv30Sharp.RNG)">
            <summary>
            shuffles the input array elements
            </summary>
            <param name="iterFactor">The scale factor that determines the number of random swap operations.</param>
            <param name="rng">The optional random number generator used for shuffling. 
            If it is null, theRng() is used instead.</param>
            <returns>The input/output numerical 1D array</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Line(System.Int32,System.Int32,System.Int32,System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws a line segment connecting two points
            </summary>
            <param name="pt1X">First point's x-coordinate of the line segment. </param>
            <param name="pt1Y">First point's y-coordinate of the line segment. </param>
            <param name="pt2X">Second point's x-coordinate of the line segment. </param>
            <param name="pt2Y">Second point's y-coordinate of the line segment. </param>
            <param name="color">Line color. </param>
            <param name="thickness">Line thickness. [By default this is 1]</param>
            <param name="lineType">Type of the line. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Line(OpenCv30Sharp.Point,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws a line segment connecting two points
            </summary>
            <param name="pt1">First point of the line segment. </param>
            <param name="pt2">Second point of the line segment. </param>
            <param name="color">Line color. </param>
            <param name="thickness">Line thickness. [By default this is 1]</param>
            <param name="lineType">Type of the line. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Rectangle(OpenCv30Sharp.Point,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="pt1">One of the rectangle vertices. </param>
            <param name="pt2">Opposite rectangle vertex. </param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Rectangle(OpenCv30Sharp.Rect,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws simple, thick or filled rectangle
            </summary>
            <param name="rect">Rectangle.</param>
            <param name="color">Line color (RGB) or brightness (grayscale image). </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle. [By default this is 1]</param>
            <param name="lineType">Type of the line, see cvLine description. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the point coordinates. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Circle(System.Int32,System.Int32,System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws a circle
            </summary>
            <param name="centerX">X-coordinate of the center of the circle. </param>
            <param name="centerY">Y-coordinate of the center of the circle. </param>
            <param name="radius">Radius of the circle. </param>
            <param name="color">Circle color. </param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn. [By default this is 1]</param>
            <param name="lineType">Type of the circle boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Circle(OpenCv30Sharp.Point,System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws a circle
            </summary>
            <param name="center">Center of the circle. </param>
            <param name="radius">Radius of the circle. </param>
            <param name="color">Circle color. </param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn. [By default this is 1]</param>
            <param name="lineType">Type of the circle boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Ellipse(OpenCv30Sharp.Point,OpenCv30Sharp.Size,System.Double,System.Double,System.Double,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Draws simple or thick elliptic arc or fills ellipse sector
            </summary>
            <param name="center">Center of the ellipse. </param>
            <param name="axes">Length of the ellipse axes. </param>
            <param name="angle">Rotation angle. </param>
            <param name="startAngle">Starting angle of the elliptic arc. </param>
            <param name="endAngle">Ending angle of the elliptic arc. </param>
            <param name="color">Ellipse color. </param>
            <param name="thickness">Thickness of the ellipse arc. [By default this is 1]</param>
            <param name="lineType">Type of the ellipse boundary. [By default this is LineType.Link8]</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values. [By default this is 0]</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Ellipse(OpenCv30Sharp.RotatedRect,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes)">
            <summary>
            Draws simple or thick elliptic arc or fills ellipse sector
            </summary>
            <param name="box">The enclosing box of the ellipse drawn </param>
            <param name="color">Ellipse color. </param>
            <param name="thickness">Thickness of the ellipse boundary. [By default this is 1]</param>
            <param name="lineType">Type of the ellipse boundary. [By default this is LineType.Link8]</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FillConvexPoly(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},OpenCv30Sharp.Scalar,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            Fills a convex polygon.
            </summary>
            <param name="pts">The polygon vertices</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FillPoly(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point}},OpenCv30Sharp.Scalar,OpenCv30Sharp.LineTypes,System.Int32,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Fills the area bounded by one or more polygons
            </summary>
            <param name="pts">Array of polygons, each represented as an array of points</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">The number of fractional bits in the vertex coordinates</param>
            <param name="offset"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Polylines(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point}},System.Boolean,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Int32)">
            <summary>
            draws one or more polygonal curves
            </summary>
            <param name="pts"></param>
            <param name="isClosed"></param>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="lineType"></param>
            <param name="shift"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PutText(System.String,OpenCv30Sharp.Point,OpenCv30Sharp.HersheyFonts,System.Double,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Boolean)">
            <summary>
            renders text string in the image
            </summary>
            <param name="text"></param>
            <param name="org"></param>
            <param name="fontFace"></param>
            <param name="fontScale"></param>
            <param name="color"></param>
            <param name="thickness"></param>
            <param name="lineType"></param>
            <param name="bottomLeftOrigin"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ImEncode(System.String,System.Int32[])">
            <summary>
            Encodes an image into a memory buffer.
            </summary>
            <param name="ext">Encodes an image into a memory buffer.</param>
            <param name="prms">Format-specific parameters.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ImEncode(System.String,OpenCv30Sharp.ImageEncodingParam[])">
            <summary>
            Encodes an image into a memory buffer.
            </summary>
            <param name="ext">Encodes an image into a memory buffer.</param>
            <param name="prms">Format-specific parameters.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ImWrite(System.String,System.Int32[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ImWrite(System.String,OpenCv30Sharp.ImageEncodingParam[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SaveImage(System.String,System.Int32[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SaveImage(System.String,OpenCv30Sharp.ImageEncodingParam[])">
            <summary>
            Saves an image to a specified file.
            </summary>
            <param name="fileName"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CopyMakeBorder(System.Int32,System.Int32,System.Int32,System.Int32,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Forms a border around the image
            </summary>
            <param name="top">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="bottom">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="left">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="right">Specify how much pixels in each direction from the source image rectangle one needs to extrapolate</param>
            <param name="borderType">The border type</param>
            <param name="value">The border value if borderType == Constant</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MedianBlur(System.Int32)">
            <summary>
            Smoothes image using median filter.
            The source image must have 1-, 3- or 4-channel and 
            its depth should be CV_8U , CV_16U or CV_32F. 
            </summary>
            <param name="ksize">The aperture linear size. It must be odd and more than 1, i.e. 3, 5, 7 ...</param>
            <returns>The destination array; will have the same size and the same type as src.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GaussianBlur(OpenCv30Sharp.Size,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Blurs an image using a Gaussian filter.
            The input image can have any number of channels, which are processed independently, 
            but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
            </summary>
            <param name="ksize">Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. 
            Or, they can be zero’s and then they are computed from sigma* .</param>
            <param name="sigmaX">Gaussian kernel standard deviation in X direction.</param>
            <param name="sigmaY">Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, 
            if both sigmas are zeros, they are computed from ksize.width and ksize.height, 
            respectively (see getGaussianKernel() for details); to fully control the result 
            regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</param>
            <param name="borderType">pixel extrapolation method</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.BilateralFilter(System.Int32,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Applies bilateral filter to the image
            The source image must be a 8-bit or floating-point, 1-channel or 3-channel image.
            </summary>
            <param name="d">The diameter of each pixel neighborhood, that is used during filtering. 
            If it is non-positive, it's computed from sigmaSpace</param>
            <param name="sigmaColor">Filter sigma in the color space. 
            Larger value of the parameter means that farther colors within the pixel neighborhood 
            will be mixed together, resulting in larger areas of semi-equal color</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. 
            Larger value of the parameter means that farther pixels will influence each other 
            (as long as their colors are close enough; see sigmaColor). Then d>0 , it specifies 
            the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace</param>
            <param name="borderType"></param>
            <returns>The destination image; will have the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.BoxFilter(OpenCv30Sharp.MatType,OpenCv30Sharp.Size,System.Nullable{OpenCv30Sharp.Point},System.Boolean,OpenCv30Sharp.BorderTypes)">
            <summary>
            Smoothes image using box filter
            </summary>
            <param name="ddepth"></param>
            <param name="ksize">The smoothing kernel size</param>
            <param name="anchor">The anchor point. The default value Point(-1,-1) means that the anchor is at the kernel center</param>
            <param name="normalize">Indicates, whether the kernel is normalized by its area or not</param>
            <param name="borderType">The border mode used to extrapolate pixels outside of the image</param>
            <returns>The destination image; will have the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Blur(OpenCv30Sharp.Size,System.Nullable{OpenCv30Sharp.Point},OpenCv30Sharp.BorderTypes)">
            <summary>
            Smoothes image using normalized box filter
            </summary>
            <param name="ksize">The smoothing kernel size</param>
            <param name="anchor">The anchor point. The default value Point(-1,-1) means that the anchor is at the kernel center</param>
            <param name="borderType">The border mode used to extrapolate pixels outside of the image</param>
            <returns>The destination image; will have the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Filter2D(OpenCv30Sharp.MatType,OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Convolves an image with the kernel
            </summary>
            <param name="ddepth">The desired depth of the destination image. If it is negative, it will be the same as src.depth()</param>
            <param name="kernel">Convolution kernel (or rather a correlation kernel), 
            a single-channel floating point matrix. If you want to apply different kernels to 
            different channels, split the image into separate color planes using split() and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of 
            a filtered point within the kernel. The anchor should lie within the kernel. 
            The special default value (-1,-1) means that the anchor is at the kernel center</param>
            <param name="delta">The optional value added to the filtered pixels before storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>The destination image. It will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SepFilter2D(OpenCv30Sharp.MatType,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Applies separable linear filter to an image
            </summary>
            <param name="ddepth">The destination image depth</param>
            <param name="kernelX">The coefficients for filtering each row</param>
            <param name="kernelY">The coefficients for filtering each column</param>
            <param name="anchor">The anchor position within the kernel; The default value (-1, 1) means that the anchor is at the kernel center</param>
            <param name="delta">The value added to the filtered results before storing them</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>The destination image; will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Sobel(OpenCv30Sharp.MatType,System.Int32,System.Int32,System.Int32,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Calculates the first, second, third or mixed image derivatives using an extended Sobel operator
            </summary>
            <param name="ddepth">The destination image depth</param>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="ksize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7</param>
            <param name="scale">The optional scale factor for the computed derivative values (by default, no scaling is applied</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>The destination image; will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Scharr(OpenCv30Sharp.MatType,System.Int32,System.Int32,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Calculates the first x- or y- image derivative using Scharr operator
            </summary>
            <param name="ddepth">The destination image depth</param>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="scale">The optional scale factor for the computed derivative values (by default, no scaling is applie</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>The destination image; will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Laplacian(OpenCv30Sharp.MatType,System.Int32,System.Double,System.Double,OpenCv30Sharp.BorderTypes)">
            <summary>
            Calculates the Laplacian of an image
            </summary>
            <param name="ddepth">The desired depth of the destination image</param>
            <param name="ksize">The aperture size used to compute the second-derivative filters</param>
            <param name="scale">The optional scale factor for the computed Laplacian values (by default, no scaling is applied</param>
            <param name="delta">The optional delta value, added to the results prior to storing them in dst</param>
            <param name="borderType">The pixel extrapolation method</param>
            <returns>Destination image; will have the same size and the same number of channels as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Canny(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Finds edges in an image using Canny algorithm.
            </summary>
            <param name="threshold1">The first threshold for the hysteresis procedure</param>
            <param name="threshold2">The second threshold for the hysteresis procedure</param>
            <param name="apertureSize">Aperture size for the Sobel operator [By default this is ApertureSize.Size3]</param>
            <param name="L2gradient">Indicates, whether the more accurate L2 norm should be used to compute the image gradient magnitude (true), or a faster default L1 norm is enough (false). [By default this is false]</param>
            <returns>The output edge map. It will have the same size and the same type as image</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CornerEigenValsAndVecs(System.Int32,System.Int32,OpenCv30Sharp.BorderTypes)">
            <summary>
            computes both eigenvalues and the eigenvectors of 2x2 derivative covariation matrix  at each pixel. The output is stored as 6-channel matrix.
            </summary>
            <param name="blockSize"></param>
            <param name="ksize"></param>
            <param name="borderType"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PreCornerDetect(System.Int32,OpenCv30Sharp.BorderTypes)">
            <summary>
            computes another complex cornerness criteria at each pixel
            </summary>
            <param name="ksize"></param>
            <param name="borderType"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CornerSubPix(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},OpenCv30Sharp.Size,OpenCv30Sharp.Size,OpenCv30Sharp.TermCriteria)">
            <summary>
            adjusts the corner locations with sub-pixel accuracy to maximize the certain cornerness criteria
            </summary>
            <param name="inputCorners">Initial coordinates of the input corners and refined coordinates provided for output.</param>
            <param name="winSize">Half of the side length of the search window.</param>
            <param name="zeroZone">Half of the size of the dead region in the middle of the search zone 
            over which the summation in the formula below is not done. It is used sometimes to avoid possible singularities 
            of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such a size.</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. 
            That is, the process of corner position refinement stops either after criteria.maxCount iterations 
            or when the corner position moves by less than criteria.epsilon on some iteration.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GoodFeaturesToTrack(System.Int32,System.Double,System.Double,OpenCv30Sharp.InputArray,System.Int32,System.Boolean,System.Double)">
            <summary>
            Finds the strong enough corners where the cornerMinEigenVal() or cornerHarris() report the local maxima.
            Input matrix must be 8-bit or floating-point 32-bit, single-channel image.
            </summary>
            <param name="maxCorners">Maximum number of corners to return. If there are more corners than are found, 
            the strongest of them is returned.</param>
            <param name="qualityLevel">Parameter characterizing the minimal accepted quality of image corners. 
            The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue 
            or the Harris function response (see cornerHarris() ). The corners with the quality measure less than 
            the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01, 
            then all the corners with the quality measure less than 15 are rejected.</param>
            <param name="minDistance">Minimum possible Euclidean distance between the returned corners.</param>
            <param name="mask">Optional region of interest. If the image is not empty
             (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region 
            in which the corners are detected.</param>
            <param name="blockSize">Size of an average block for computing a derivative covariation matrix over each pixel neighborhood.</param>
            <param name="useHarrisDetector">Parameter indicating whether to use a Harris detector</param>
            <param name="k">Free parameter of the Harris detector.</param>
            <returns>Output vector of detected corners.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.HoughLines(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines in a binary image using standard Hough transform.
            The input matrix must be 8-bit, single-channel, binary source image. 
            This image may be modified by the function.
            </summary>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">The accumulator threshold parameter. Only those lines are returned that get enough votes ( &gt; threshold )</param>
            <param name="srn">For the multi-scale Hough transform it is the divisor for the distance resolution rho. [By default this is 0]</param>
            <param name="stn">For the multi-scale Hough transform it is the divisor for the distance resolution theta. [By default this is 0]</param>
            <returns>The output vector of lines. Each line is represented by a two-element vector (rho, theta) . 
            rho is the distance from the coordinate origin (0,0) (top-left corner of the image) and theta is the line rotation angle in radians</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.HoughLinesP(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines segments in a binary image using probabilistic Hough transform.
            </summary>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">The accumulator threshold parameter. Only those lines are returned that get enough votes ( &gt; threshold )</param>
            <param name="minLineLength">The minimum line length. Line segments shorter than that will be rejected. [By default this is 0]</param>
            <param name="maxLineGap">The maximum allowed gap between points on the same line to link them. [By default this is 0]</param>
            <returns>The output lines. Each line is represented by a 4-element vector (x1, y1, x2, y2)</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.HoughCircles(OpenCv30Sharp.HoughMethods,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in a grayscale image using a Hough transform.
            The input matrix must be 8-bit, single-channel and grayscale.
            </summary>
            <param name="method">Currently, the only implemented method is HoughCirclesMethod.Gradient</param>
            <param name="dp">The inverse ratio of the accumulator resolution to the image resolution. </param>
            <param name="minDist">Minimum distance between the centers of the detected circles. </param>
            <param name="param1">The first method-specific parameter. [By default this is 100]</param>
            <param name="param2">The second method-specific parameter. [By default this is 100]</param>
            <param name="minRadius">Minimum circle radius. [By default this is 0]</param>
            <param name="maxRadius">Maximum circle radius. [By default this is 0] </param>
            <returns>The output vector found circles. Each vector is encoded as 3-element floating-point vector (x, y, radius)</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Dilate(OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Int32,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Dilates an image by using a specific structuring element.
            </summary>
            <param name="element">The structuring element used for dilation. If element=new Mat() , a 3x3 rectangular structuring element is used</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">The number of times dilation is applied. [By default this is 1]</param>
            <param name="borderType">The pixel extrapolation method. [By default this is BorderTypes.Constant]</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
            <returns>The destination image. It will have the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Erode(OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Int32,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Erodes an image by using a specific structuring element.
            </summary>
            <param name="element">The structuring element used for dilation. If element=new Mat(), a 3x3 rectangular structuring element is used</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">The number of times erosion is applied</param>
            <param name="borderType">The pixel extrapolation method</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
            <returns>The destination image. It will have the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MorphologyEx(OpenCv30Sharp.MorphTypes,OpenCv30Sharp.InputArray,System.Nullable{OpenCv30Sharp.Point},System.Int32,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Performs advanced morphological transformations
            </summary>
            <param name="op">Type of morphological operation</param>
            <param name="element">Structuring element</param>
            <param name="anchor">Position of the anchor within the element. The default value (-1, -1) means that the anchor is at the element center</param>
            <param name="iterations">Number of times erosion and dilation are applied. [By default this is 1]</param>
            <param name="borderType">The pixel extrapolation method. [By default this is BorderTypes.Constant]</param>
            <param name="borderValue">The border value in case of a constant border. The default value has a special meaning. [By default this is CvCpp.MorphologyDefaultBorderValue()]</param>
            <returns>Destination image. It will have the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Resize(OpenCv30Sharp.Size,System.Double,System.Double,OpenCv30Sharp.InterpolationFlags)">
            <summary>
            Resizes an image.
            </summary>
            <param name="dsize">output image size; if it equals zero, it is computed as: 
            dsize = Size(round(fx*src.cols), round(fy*src.rows))
            Either dsize or both fx and fy must be non-zero.</param>
            <param name="fx">scale factor along the horizontal axis; when it equals 0, 
            it is computed as: (double)dsize.width/src.cols</param>
            <param name="fy">scale factor along the vertical axis; when it equals 0, 
            it is computed as: (double)dsize.height/src.rows</param>
            <param name="interpolation">interpolation method</param>
            <returns>output image; it has the size dsize (when it is non-zero) or the size computed 
            from src.size(), fx, and fy; the type of dst is the same as of src.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.WarpAffine(OpenCv30Sharp.InputArray,OpenCv30Sharp.Size,OpenCv30Sharp.InterpolationFlags,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Applies an affine transformation to an image.
            </summary>
            <returns>output image that has the size dsize and the same type as src.</returns>
            <param name="m">2x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods and the optional flag 
            WARP_INVERSE_MAP that means that M is the inverse transformation (dst -> src) .</param>
            <param name="borderMode">pixel extrapolation method; when borderMode=BORDER_TRANSPARENT, 
            it means that the pixels in the destination image corresponding to the "outliers" 
            in the source image are not modified by the function.</param>
            <param name="borderValue">value used in case of a constant border; by default, it is 0.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.WarpPerspective(OpenCv30Sharp.Mat,OpenCv30Sharp.Size,OpenCv30Sharp.InterpolationFlags,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Applies a perspective transformation to an image.
            </summary>
            <param name="m">3x3 transformation matrix.</param>
            <param name="dsize">size of the output image.</param>
            <param name="flags">combination of interpolation methods (INTER_LINEAR or INTER_NEAREST) 
            and the optional flag WARP_INVERSE_MAP, that sets M as the inverse transformation (dst -> src).</param>
            <param name="borderMode">pixel extrapolation method (BORDER_CONSTANT or BORDER_REPLICATE).</param>
            <param name="borderValue">value used in case of a constant border; by default, it equals 0.</param>
            <returns>output image that has the size dsize and the same type as src.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Remap(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InterpolationFlags,OpenCv30Sharp.BorderTypes,System.Nullable{OpenCv30Sharp.Scalar})">
            <summary>
            Applies a generic geometrical transformation to an image.
            </summary>
            <param name="map1">The first map of either (x,y) points or just x values having the type CV_16SC2, CV_32FC1, or CV_32FC2.</param>
            <param name="map2">The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively.</param>
            <param name="interpolation">Interpolation method. The method INTER_AREA is not supported by this function.</param>
            <param name="borderMode">Pixel extrapolation method. When borderMode=BORDER_TRANSPARENT, 
            it means that the pixels in the destination image that corresponds to the "outliers" in 
            the source image are not modified by the function.</param>
            <param name="borderValue">Value used in case of a constant border. By default, it is 0.</param>
            <returns>Destination image. It has the same size as map1 and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.InvertAffineTransform">
            <summary>
            Inverts an affine transformation.
            </summary>
            <returns>Output reverse affine transformation.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetRectSubPix(OpenCv30Sharp.Size,OpenCv30Sharp.Point2f,System.Int32)">
            <summary>
            Retrieves a pixel rectangle from an image with sub-pixel accuracy.
            </summary>
            <param name="patchSize">Size of the extracted patch.</param>
            <param name="center">Floating point coordinates of the center of the extracted rectangle 
            within the source image. The center must be inside the image.</param>
            <param name="patchType">Depth of the extracted pixels. By default, they have the same depth as src.</param>
            <returns>Extracted patch that has the size patchSize and the same number of channels as src .</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Accumulate(OpenCv30Sharp.InputArray)">
            <summary>
            Adds an image to the accumulator.
            </summary>
            <param name="mask">Optional operation mask.</param>
            <returns>Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.AccumulateSquare(OpenCv30Sharp.InputArray)">
            <summary>
            Adds the square of a source image to the accumulator.
            </summary>
            <param name="mask">Optional operation mask.</param>
            <returns>Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CreateHanningWindow(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            Computes a Hanning window coefficients in two dimensions.
            </summary>
            <param name="winSize">The window size specifications</param>
            <param name="type">Created array type</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Threshold(System.Double,System.Double,OpenCv30Sharp.ThresholdTypes)">
            <summary>
            Applies a fixed-level threshold to each array element.
            The input matrix must be single-channel, 8-bit or 32-bit floating point.
            </summary>
            <param name="thresh">threshold value.</param>
            <param name="maxval">maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding types.</param>
            <param name="type">thresholding type (see the details below).</param>
            <returns>output array of the same size and type as src.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.AdaptiveThreshold(System.Double,OpenCv30Sharp.AdaptiveThresholdTypes,OpenCv30Sharp.ThresholdTypes,System.Int32,System.Double)">
            <summary>
            Applies an adaptive threshold to an array.
            Source matrix must be 8-bit single-channel image.
            </summary>
            <param name="maxValue">Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.</param>
            <param name="adaptiveMethod">Adaptive thresholding algorithm to use, ADAPTIVE_THRESH_MEAN_C or ADAPTIVE_THRESH_GAUSSIAN_C .</param>
            <param name="thresholdType">Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV .</param>
            <param name="blockSize">Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.</param>
            <param name="c">Constant subtracted from the mean or weighted mean (see the details below). 
            Normally, it is positive but may be zero or negative as well.</param>
            <returns>Destination image of the same size and the same type as src.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PyrDown(System.Nullable{OpenCv30Sharp.Size},OpenCv30Sharp.BorderTypes)">
            <summary>
            Blurs an image and downsamples it.
            </summary>
            <param name="dstSize">size of the output image; by default, it is computed as Size((src.cols+1)/2</param>
            <param name="borderType"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PyrUp(System.Nullable{OpenCv30Sharp.Size},OpenCv30Sharp.BorderTypes)">
            <summary>
            Upsamples an image and then blurs it.
            </summary>
            <param name="dstSize">size of the output image; by default, it is computed as Size(src.cols*2, (src.rows*2)</param>
            <param name="borderType"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Undistort(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            corrects lens distortion for the given camera matrix and distortion coefficients
            </summary>
            <param name="cameraMatrix"> Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, 
            or 8 elements. If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="newCameraMatrix">Camera matrix of the distorted image. 
            By default, it is the same as cameraMatrix but you may additionally scale 
            and shift the result by using a different matrix.</param>
            <returns>Output (corrected) image that has the same size and type as src .</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetDefaultNewCameraMatrix(System.Nullable{OpenCv30Sharp.Size},System.Boolean)">
            <summary>
            returns the default new camera matrix (by default it is the same as cameraMatrix unless centerPricipalPoint=true)
            </summary>
            <param name="imgSize">Camera view image size in pixels.</param>
            <param name="centerPrincipalPoint">Location of the principal point in the new camera matrix. 
            The parameter indicates whether this location should be at the image center or not.</param>
            <returns>the camera matrix that is either an exact copy of the input cameraMatrix 
            (when centerPrinicipalPoint=false), or the modified one (when centerPrincipalPoint=true).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.UndistortPoints(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            Computes the ideal point coordinates from the observed point coordinates.
            Input matrix is an observed point coordinates, 1xN or Nx1 2-channel (CV_32FC2 or CV_64FC2).
            </summary>
            <param name="cameraMatrix">Camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]]) of 4, 5, or 8 elements. 
            If the vector is null, the zero distortion coefficients are assumed.</param>
            <param name="r">Rectification transformation in the object space (3x3 matrix). 
            R1 or R2 computed by stereoRectify() can be passed here. 
            If the matrix is empty, the identity transformation is used.</param>
            <param name="p">New camera matrix (3x3) or new projection matrix (3x4). 
            P1 or P2 computed by stereoRectify() can be passed here. If the matrix is empty, 
            the identity new camera matrix is used.</param>
            <returns>Output ideal point coordinates after undistortion and reverse perspective transformation. 
            If matrix P is identity or omitted, dst will contain normalized point coordinates.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.EqualizeHist">
            <summary>
            Normalizes the grayscale image brightness and contrast by normalizing its histogram.
            The source matrix is 8-bit single channel image.
            </summary>
            <returns>The destination image; will have the same size and the same type as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Watershed(OpenCv30Sharp.InputOutputArray)">
            <summary>
            Performs a marker-based image segmentation using the watershed algorithm.
            Input matrix is 8-bit 3-channel image.
            </summary>
            <param name="markers">Input/output 32-bit single-channel image (map) of markers. 
            It should have the same size as image.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PyrMeanShiftFiltering(System.Double,System.Double,System.Int32,System.Nullable{OpenCv30Sharp.TermCriteria})">
            <summary>
            Performs initial step of meanshift segmentation of an image.
            The source matrix is 8-bit, 3-channel image.
            </summary>
            <param name="sp">The spatial window radius.</param>
            <param name="sr">The color window radius.</param>
            <param name="maxLevel">Maximum level of the pyramid for the segmentation.</param>
            <param name="termcrit">Termination criteria: when to stop meanshift iterations.</param>
            <returns>The destination image of the same format and the same size as the source.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GrabCut(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Rect,OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.InputOutputArray,System.Int32,OpenCv30Sharp.GrabCutModes)">
            <summary>
            Segments the image using GrabCut algorithm.
            The input is 8-bit 3-channel image.
            </summary>
            <param name="mask">Input/output 8-bit single-channel mask. 
            The mask is initialized by the function when mode is set to GC_INIT_WITH_RECT. 
            Its elements may have Cv2.GC_BGD / Cv2.GC_FGD / Cv2.GC_PR_BGD / Cv2.GC_PR_FGD</param>
            <param name="rect">ROI containing a segmented object. The pixels outside of the ROI are 
            marked as "obvious background". The parameter is only used when mode==GC_INIT_WITH_RECT.</param>
            <param name="bgdModel">Temporary array for the background model. Do not modify it while you are processing the same image.</param>
            <param name="fgdModel">Temporary arrays for the foreground model. Do not modify it while you are processing the same image.</param>
            <param name="iterCount">Number of iterations the algorithm should make before returning the result. 
            Note that the result can be refined with further calls with mode==GC_INIT_WITH_MASK or mode==GC_EVAL .</param>
            <param name="mode">Operation mode that could be one of GrabCutFlag value.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FloodFill(OpenCv30Sharp.Point,OpenCv30Sharp.Scalar)">
            <summary>
            Fills a connected component with the given color.
            Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.
            </summary>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FloodFill(OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,OpenCv30Sharp.Rect@,System.Nullable{OpenCv30Sharp.Scalar},System.Nullable{OpenCv30Sharp.Scalar},OpenCv30Sharp.FloodFillFlags)">
            <summary>
            Fills a connected component with the given color.
            Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.
            </summary>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <param name="rect">Optional output parameter set by the function to the 
            minimum bounding rectangle of the repainted domain.</param>
            <param name="loDiff">Maximal lower brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="upDiff">Maximal upper brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="flags">Operation flags. Lower bits contain a connectivity value, 
            4 (default) or 8, used within the function. Connectivity determines which 
            neighbors of a pixel are considered. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FloodFill(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar)">
            <summary>
            Fills a connected component with the given color.
            Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.
            </summary>
            <param name="mask">(For the second function only) Operation mask that should be a single-channel 8-bit image, 
            2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of 
            initializing the mask content. Flood-filling cannot go across non-zero pixels in the mask. For example, 
            an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask 
            in multiple calls to the function to make sure the filled area does not overlap.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FloodFill(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.Point,OpenCv30Sharp.Scalar,OpenCv30Sharp.Rect@,System.Nullable{OpenCv30Sharp.Scalar},System.Nullable{OpenCv30Sharp.Scalar},OpenCv30Sharp.FloodFillFlags)">
            <summary>
            Fills a connected component with the given color.
            Input/output 1- or 3-channel, 8-bit, or floating-point image. 
            It is modified by the function unless the FLOODFILL_MASK_ONLY flag is set in the 
            second variant of the function. See the details below.
            </summary>
            <param name="mask">(For the second function only) Operation mask that should be a single-channel 8-bit image, 
            2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of 
            initializing the mask content. Flood-filling cannot go across non-zero pixels in the mask. For example, 
            an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask 
            in multiple calls to the function to make sure the filled area does not overlap.</param>
            <param name="seedPoint">Starting point.</param>
            <param name="newVal">New value of the repainted domain pixels.</param>
            <param name="rect">Optional output parameter set by the function to the 
            minimum bounding rectangle of the repainted domain.</param>
            <param name="loDiff">Maximal lower brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="upDiff">Maximal upper brightness/color difference between the currently 
            observed pixel and one of its neighbors belonging to the component, or a seed pixel 
            being added to the component.</param>
            <param name="flags">Operation flags. Lower bits contain a connectivity value, 
            4 (default) or 8, used within the function. Connectivity determines which 
            neighbors of a pixel are considered. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CvtColor(OpenCv30Sharp.ColorConversionCodes,System.Int32)">
            <summary>
            Converts image from one color space to another
            </summary>
            <param name="code">The color space conversion code</param>
            <param name="dstCn">The number of channels in the destination image; if the parameter is 0, the number of the channels will be derived automatically from src and the code</param>
            <returns>The destination image; will have the same size and the same depth as src</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Moments(System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            The input is a raster image (single-channel, 8-bit or floating-point 2D array).
            </summary>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MatchTemplate(OpenCv30Sharp.InputArray,OpenCv30Sharp.TemplateMatchModes)">
            <summary>
            Computes the proximity map for the raster template and the image where the template is searched for
            The input is Image where the search is running; should be 8-bit or 32-bit floating-point.
            </summary>
            <param name="templ">Searched template; must be not greater than the source image and have the same data type</param>
            <param name="method">Specifies the comparison method</param>
            <returns>A map of comparison results; will be single-channel 32-bit floating-point. 
            If image is WxH and templ is wxh then result will be (W-w+1) x (H-h+1).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConnectedComponents(OpenCv30Sharp.OutputArray,OpenCv30Sharp.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled image</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConnectedComponents(OpenCv30Sharp.OutputArray,OpenCv30Sharp.PixelConnectivity,OpenCv30Sharp.MatType)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled image</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConnectedComponents(System.Int32[0:,0:]@,OpenCv30Sharp.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled rectangular array</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns>The number of labels</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConnectedComponentsWithStats(OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled image</param>
            <param name="stats">statistics output for each label, including the background label, 
            see below for available statistics. Statistics are accessed via stats(label, COLUMN) 
            where COLUMN is one of cv::ConnectedComponentsTypes</param>
            <param name="centroids">floating point centroid (x,y) output for each label, 
            including the background label</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConnectedComponentsWithStats(OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.PixelConnectivity,OpenCv30Sharp.MatType)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="labels">destination labeled image</param>
            <param name="stats">statistics output for each label, including the background label, 
            see below for available statistics. Statistics are accessed via stats(label, COLUMN) 
            where COLUMN is one of cv::ConnectedComponentsTypes</param>
            <param name="centroids">floating point centroid (x,y) output for each label, 
            including the background label</param>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <param name="ltype">output image label type. Currently CV_32S and CV_16U are supported.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConnectedComponentsEx(OpenCv30Sharp.PixelConnectivity)">
            <summary>
            computes the connected components labeled image of boolean image. 
            image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0 
            represents the background label. ltype specifies the output label image type, an important 
            consideration based on the total number of labels or alternatively the total number of 
            pixels in the source image.
            </summary>
            <param name="connectivity">8 or 4 for 8-way or 4-way connectivity respectively</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FindContours(OpenCv30Sharp.Point[][]@,OpenCv30Sharp.HierarchyIndex[]@,OpenCv30Sharp.RetrievalModes,OpenCv30Sharp.ContourApproximationModes,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Finds contours in a binary image.
            The source is an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary. The function modifies this image while extracting the contours.
            </summary>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology. 
            It has as many elements as the number of contours. For each i-th contour contours[i], 
            the members of the elements hierarchy[i] are set to 0-based indices in contours of the next 
            and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. 
            If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.</param>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FindContours(OpenCv30Sharp.Mat[]@,OpenCv30Sharp.OutputArray,OpenCv30Sharp.RetrievalModes,OpenCv30Sharp.ContourApproximationModes,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Finds contours in a binary image.
            The source is an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary. The function modifies this image while extracting the contours.
            </summary>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology. 
            It has as many elements as the number of contours. For each i-th contour contours[i], 
            the members of the elements hierarchy[i] are set to 0-based indices in contours of the next 
            and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. 
            If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.</param>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FindContoursAsArray(OpenCv30Sharp.RetrievalModes,OpenCv30Sharp.ContourApproximationModes,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Finds contours in a binary image.
            The source is an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary. The function modifies this image while extracting the contours.
            </summary>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
            <returns>Detected contours. Each contour is stored as a vector of points.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FindContoursAsMat(OpenCv30Sharp.RetrievalModes,OpenCv30Sharp.ContourApproximationModes,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Finds contours in a binary image.
            The source is an 8-bit single-channel image. Non-zero pixels are treated as 1’s. 
            Zero pixels remain 0’s, so the image is treated as binary. The function modifies this image while extracting the contours.
            </summary>
            <param name="mode">Contour retrieval mode</param>
            <param name="method">Contour approximation method</param>
            <param name="offset"> Optional offset by which every contour point is shifted. 
            This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</param>
            <returns>Detected contours. Each contour is stored as a vector of points.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.DrawContours(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point}},System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,System.Collections.Generic.IEnumerable{OpenCv30Sharp.HierarchyIndex},System.Int32,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Draws contours in the image
            </summary>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours.</param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative (for example, thickness=CV_FILLED ), 
            the contour interiors are drawn.</param>
            <param name="lineType">Line connectivity. </param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="maxLevel">Maximal level for drawn contours. If it is 0, only the specified contour is drawn. 
            If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, 
            all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account 
            when there is hierarchy available.</param>
            <param name="offset">Optional contour shift parameter. Shift all the drawn contours by the specified offset = (dx, dy)</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.DrawContours(OpenCv30Sharp.InputOutputArray,System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},System.Int32,OpenCv30Sharp.Scalar,System.Int32,OpenCv30Sharp.LineTypes,OpenCv30Sharp.Mat,System.Int32,System.Nullable{OpenCv30Sharp.Point})">
            <summary>
            Draws contours in the image
            </summary>
            <param name="image">Destination image.</param>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours.</param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative (for example, thickness=CV_FILLED ), 
            the contour interiors are drawn.</param>
            <param name="lineType">Line connectivity. </param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="maxLevel">Maximal level for drawn contours. If it is 0, only the specified contour is drawn. 
            If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, 
            all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account 
            when there is hierarchy available.</param>
            <param name="offset">Optional contour shift parameter. Shift all the drawn contours by the specified offset = (dx, dy)</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ApproxPolyDP(System.Double,System.Boolean)">
            <summary>
            Approximates contour or a curve using Douglas-Peucker algorithm.
            The input is the polygon or curve to approximate and 
            it must be 1 x N or N x 1 matrix of type CV_32SC2 or CV_32FC2.
            </summary>
            <param name="epsilon">Specifies the approximation accuracy. 
            This is the maximum distance between the original curve and its approximation.</param>
            <param name="closed">The result of the approximation; 
            The type should match the type of the input curve</param>
            <returns>The result of the approximation; 
            The type should match the type of the input curve</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ArcLength(System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <param name="closed">Indicates, whether the curve is closed or not</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.BoundingRect">
            <summary>
            Calculates the up-right bounding rectangle of a point set.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <returns>Minimal up-right bounding rectangle for the specified point set.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ContourArea(System.Boolean)">
            <summary>
            Calculates the contour area.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <param name="oriented"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MinAreaRect">
            <summary>
            Finds the minimum area rotated rectangle enclosing a 2D point set.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MinEnclosingCircle(OpenCv30Sharp.Point2f@,System.Single@)">
            <summary>
            Finds the minimum area circle enclosing a 2D point set.
            The input is 2D point set, represented by CV_32SC2 or CV_32FC2 matrix.
            </summary>
            <param name="center">The output center of the circle</param>
            <param name="radius">The output radius of the circle</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConvexHull(OpenCv30Sharp.InputArray,System.Boolean,System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <param name="returnPoints"></param>
            <returns>The output convex hull. It is either a vector of points that form the 
            hull (must have the same type as the input points), or a vector of 0-based point 
            indices of the hull points in the original array (since the set of convex hull 
            points is a subset of the original point set).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConvexHullPoints(OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of points that form the 
            hull (must have the same type as the input points).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConvexHullFloatPoints(OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of points that form the 
            hull (must have the same type as the input points).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConvexHullIndices(OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Computes convex hull for a set of 2D points.
            </summary>
            <param name="points">The input 2D point set, represented by CV_32SC2 or CV_32FC2 matrix</param>
            <param name="clockwise">If true, the output convex hull will be oriented clockwise, 
            otherwise it will be oriented counter-clockwise. Here, the usual screen coordinate 
            system is assumed - the origin is at the top-left corner, x axis is oriented to the right, 
            and y axis is oriented downwards.</param>
            <returns>The output convex hull. It is a vector of 0-based point 
            indices of the hull points in the original array (since the set of convex hull 
            points is a subset of the original point set).</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConvexityDefects(OpenCv30Sharp.InputArray)">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <returns>The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConvexityDefectsAsVec(OpenCv30Sharp.InputArray)">
            <summary>
            Computes the contour convexity defects
            </summary>
            <param name="convexHull">Convex hull obtained using convexHull() that 
            should contain indices of the contour points that make the hull.</param>
            <returns>The output vector of convexity defects. 
            Each convexity defect is represented as 4-element integer vector 
            (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), 
            where indices are 0-based indices in the original contour of the convexity defect beginning, 
            end and the farthest point, and fixpt_depth is fixed-point approximation 
            (with 8 fractional bits) of the distance between the farthest contour point and the hull. 
            That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.IsContourConvex">
            <summary>
            Returns true if the contour is convex. 
            Does not support contours with self-intersection
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FitEllipse">
            <summary>
            Fits ellipse to the set of 2D points.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FitLine2D(OpenCv30Sharp.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 2D points using M-estimator algorithm.
            The input is vector of 2D points.
            </summary>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FitLine3D(OpenCv30Sharp.DistanceTypes,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to the set of 3D points using M-estimator algorithm.
            The input is vector of 3D points.
            </summary>
            <param name="distType">Distance used by the M-estimator</param>
            <param name="param">Numerical parameter ( C ) for some types of distances. 
            If it is 0, an optimal value is chosen.</param>
            <param name="reps">Sufficient accuracy for the radius 
            (distance between the coordinate origin and the line).</param>
            <param name="aeps">Sufficient accuracy for the angle. 
            0.01 would be a good default value for reps and aeps.</param>
            <returns>Output line parameters.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PointPolygonTest(OpenCv30Sharp.Point2f,System.Boolean)">
            <summary>
            Checks if the point is inside the contour. 
            Optionally computes the signed distance from the point to the contour boundary.
            </summary>
            <param name="pt">Point tested against the contour.</param>
            <param name="measureDist">If true, the function estimates the signed distance 
            from the point to the nearest contour edge. Otherwise, the function only checks 
            if the point is inside a contour or not.</param>
            <returns>Positive (inside), negative (outside), or zero (on an edge) value.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.DistanceTransform(OpenCv30Sharp.DistanceTypes,OpenCv30Sharp.DistanceMaskSize)">
            <summary>
            Computes the distance transform map
            </summary>
            <param name="distanceType"></param>
            <param name="maskSize"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.String,OpenCv30Sharp.ImreadModes)">
            <summary>
            Loads an image from a file. (cv::imread)
            </summary>
            <param name="fileName">Name of file to be loaded.</param>
            <param name="flags">Specifies color type of the loaded image</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType.CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType,OpenCv30Sharp.Scalar)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.MatType,OpenCv30Sharp.Scalar)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(OpenCv30Sharp.Mat,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(OpenCv30Sharp.Mat,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(OpenCv30Sharp.Mat,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType,System.Array,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.MatType,System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.MatType,System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.MatType)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.MatType,OpenCv30Sharp.Scalar)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Release">
            <summary>
            Releases the resources
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FromStream(System.IO.Stream,OpenCv30Sharp.ImreadModes)">
            <summary>
            Creates the Mat instance from System.IO.Stream
            </summary>
            <param name="stream"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ImDecode(System.Byte[],OpenCv30Sharp.ImreadModes)">
            <summary>
            Creates the Mat instance from image data (using cv::decode) 
            </summary>
            <param name="imageBytes"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.FromImageData(System.Byte[],OpenCv30Sharp.ImreadModes)">
            <summary>
            Creates the Mat instance from image data (using cv::decode) 
            </summary>
            <param name="imageBytes"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="F:OpenCv30Sharp.Mat.SizeOf">
            <summary>
            sizeof(cv::Mat)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Diag(OpenCv30Sharp.Mat)">
            <summary>
            Extracts a diagonal from a matrix, or creates a diagonal matrix.
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Eye(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            Returns an identity matrix of the specified size and type.
            </summary>
            <param name="size">Alternative to the matrix size specification Size(cols, rows) .</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Eye(System.Int32,System.Int32,OpenCv30Sharp.MatType)">
            <summary>
            Returns an identity matrix of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Ones(System.Int32,System.Int32,OpenCv30Sharp.MatType)">
            <summary>
            Returns an array of all 1’s of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Ones(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            Returns an array of all 1’s of the specified size and type.
            </summary>
            <param name="size">Alternative to the matrix size specification Size(cols, rows) .</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Ones(OpenCv30Sharp.MatType,System.Int32[])">
            <summary>
            Returns an array of all 1’s of the specified size and type.
            </summary>
            <param name="type">Created matrix type.</param>
            <param name="sizes">Array of integers specifying the array shape.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Zeros(System.Int32,System.Int32,OpenCv30Sharp.MatType)">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Zeros(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="size">Alternative to the matrix size specification Size(cols, rows) .</param>
            <param name="type">Created matrix type.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Zeros(OpenCv30Sharp.MatType,System.Int32[])">
            <summary>
            Returns a zero array of the specified size and type.
            </summary>
            <param name="type">Created matrix type.</param>
            <param name="sizes"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_UnaryNegation(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_UnaryPlus(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Addition(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Addition(OpenCv30Sharp.Mat,OpenCv30Sharp.Scalar)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Addition(OpenCv30Sharp.Scalar,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Subtraction(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Subtraction(OpenCv30Sharp.Mat,OpenCv30Sharp.Scalar)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Subtraction(OpenCv30Sharp.Scalar,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Multiply(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Multiply(OpenCv30Sharp.Mat,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Multiply(System.Double,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Division(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Division(OpenCv30Sharp.Mat,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_Division(System.Double,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_BitwiseAnd(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_BitwiseAnd(OpenCv30Sharp.Mat,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_BitwiseAnd(System.Double,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_BitwiseOr(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_BitwiseOr(OpenCv30Sharp.Mat,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_BitwiseOr(System.Double,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_ExclusiveOr(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_ExclusiveOr(OpenCv30Sharp.Mat,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_ExclusiveOr(System.Double,OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.op_OnesComplement(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.LessThan(OpenCv30Sharp.Mat)">
            <summary>
            operator &lt;
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.LessThan(System.Double)">
            <summary>
            operator &lt;
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.LessThanOrEqual(OpenCv30Sharp.Mat)">
            <summary>
            operator &lt;=
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.LessThanOrEqual(System.Double)">
            <summary>
            operator &lt;=
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Equals(OpenCv30Sharp.Mat)">
            <summary>
            operator ==
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Equals(System.Double)">
            <summary>
            operator ==
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.NotEquals(OpenCv30Sharp.Mat)">
            <summary>
            operator !=
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.NotEquals(System.Double)">
            <summary>
            operator !=
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GreaterThan(OpenCv30Sharp.Mat)">
            <summary>
            operator &gt;
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GreaterThan(System.Double)">
            <summary>
            operator &gt;
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GreaterThanOrEqual(OpenCv30Sharp.Mat)">
            <summary>
            operator &gt;=
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GreaterThanOrEqual(System.Double)">
            <summary>
            operator &gt;=
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart">Start row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="rowEnd">End row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colStart">Start column of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colEnd">End column of the extracted submatrix. The upper boundary is not included.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Item(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included. 
            To select all the rows, use Range.All().</param>
            <param name="colRange">Start and end column of the extracted submatrix. 
            The upper boundary is not included. To select all the columns, use Range.All().</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Item(OpenCv30Sharp.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Item(OpenCv30Sharp.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Mat.MatExprIndexer">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.MatExprIndexer.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.Mat.MatExprIndexer.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart">Start row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="rowEnd">End row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colStart">Start column of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colEnd">End column of the extracted submatrix. The upper boundary is not included.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.MatExprIndexer.Item(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included. 
            To select all the rows, use Range.All().</param>
            <param name="colRange">Start and end column of the extracted submatrix. 
            The upper boundary is not included. To select all the columns, use Range.All().</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.MatExprIndexer.Item(OpenCv30Sharp.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.MatExprIndexer.Item(OpenCv30Sharp.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Expr">
            <summary>
            Indexer to access partial Mat as MatExpr
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Mat.ColExprIndexer">
            <summary>
            Mat column's indexer object
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ColExprIndexer.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.Mat.ColExprIndexer.Item(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.ColExprIndexer.Item(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified column span.
            </summary>
            <param name="startCol">An inclusive 0-based start index of the column span.</param>
            <param name="endCol">An exclusive 0-based ending index of the column span.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.ColExpr">
            <summary>
            Indexer to access Mat column as MatExpr
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Mat.RowExprIndexer">
            <summary>
            Mat row's indexer object
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.RowExprIndexer.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.Mat.RowExprIndexer.Item(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row. [Mat::row]
            </summary>
            <param name="y">A 0-based row index.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.RowExprIndexer.Item(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified row span. (Mat::rowRange)
            </summary>
            <param name="startRow">An inclusive 0-based start index of the row span.</param>
            <param name="endRow">An exclusive 0-based ending index of the row span.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.RowExpr">
            <summary>
            Indexer to access Mat row as MatExpr
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.AdjustROI(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adjusts a submatrix size and position within the parent matrix.
            </summary>
            <param name="dtop">Shift of the top submatrix boundary upwards.</param>
            <param name="dbottom">Shift of the bottom submatrix boundary downwards.</param>
            <param name="dleft">Shift of the left submatrix boundary to the left.</param>
            <param name="dright">Shift of the right submatrix boundary to the right.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.AssignTo(OpenCv30Sharp.Mat,OpenCv30Sharp.MatType)">
            <summary>
            Provides a functional form of convertTo.
            </summary>
            <param name="m">Destination array.</param>
            <param name="type">Desired destination array depth (or -1 if it should be the same as the source type).</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.AssignTo(OpenCv30Sharp.Mat)">
            <summary>
            Provides a functional form of convertTo.
            </summary>
            <param name="m">Destination array.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Channels">
            <summary>
            Returns the number of matrix channels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CheckVector(System.Int32)">
            <summary>
            
            </summary>
            <param name="elemChannels"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CheckVector(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="elemChannels"></param>
            <param name="depth"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CheckVector(System.Int32,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="elemChannels"></param>
            <param name="depth"></param>
            <param name="requireContinuous"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Clone">
            <summary>
            Creates a full copy of the matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Clone(OpenCv30Sharp.Rect)">
            <summary>
            Returns the partial Mat of the specified Mat
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Cols">
            <summary>
            the number of columns or -1 when the array has more than 2 dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Width">
            <summary>
            the number of columns or -1 when the array has more than 2 dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Dims">
            <summary>
            the array dimensionality, >= 2
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ConvertTo(OpenCv30Sharp.Mat,OpenCv30Sharp.MatType,System.Double,System.Double)">
            <summary>
            Converts an array to another data type with optional scaling.
            </summary>
            <param name="m">output matrix; if it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="rtype">desired output matrix type or, rather, the depth since the number of channels are the same as the input has; 
            if rtype is negative, the output matrix will have the same type as the input.</param>
            <param name="alpha">optional scale factor.</param>
            <param name="beta">optional delta added to the scaled values.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CopyTo(OpenCv30Sharp.Mat)">
            <summary>
            Copies the matrix to another one.
            </summary>
            <param name="m">Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.CopyTo(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            Copies the matrix to another one.
            </summary>
            <param name="m">Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Create(System.Int32,System.Int32,OpenCv30Sharp.MatType)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="rows">New number of rows.</param>
            <param name="cols">New number of columns.</param>
            <param name="type">New matrix type.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Create(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="size">Alternative new matrix size specification: Size(cols, rows)</param>
            <param name="type">New matrix type.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Create(OpenCv30Sharp.MatType,System.Int32[])">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="sizes">Array of integers specifying a new array shape.</param>
            <param name="type">New matrix type.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Cross(OpenCv30Sharp.Mat)">
            <summary>
            Computes a cross-product of two 3-element vectors.
            </summary>
            <param name="m">Another cross-product operand.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Data">
            <summary>
            pointer to the data
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Mat.DataPointer">
            <summary>
            unsafe pointer to the data
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Mat.DataStart">
            <summary>
            The pointer that is possible to compute a relative sub-array position in the main container array using locateROI()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Mat.DataEnd">
            <summary>
            The pointer that is possible to compute a relative sub-array position in the main container array using locateROI()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Mat.DataLimit">
            <summary>
            The pointer that is possible to compute a relative sub-array position in the main container array using locateROI()
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Depth">
            <summary>
            Returns the depth of a matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Diag(OpenCv30Sharp.MatDiagType)">
            <summary>
            Single-column matrix that forms a diagonal matrix or index of the diagonal, with the following values:
            </summary>
            <param name="d">Single-column matrix that forms a diagonal matrix or index of the diagonal, with the following values:</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Dot(OpenCv30Sharp.Mat)">
            <summary>
            Computes a dot-product of two vectors.
            </summary>
            <param name="m">another dot-product operand.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ElemSize">
            <summary>
            Returns the matrix element size in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ElemSize1">
            <summary>
            Returns the size of each matrix element channel in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Empty">
            <summary>
            Returns true if the array has no elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Inv(OpenCv30Sharp.DecompTypes)">
            <summary>
            Inverses a matrix.
            </summary>
            <param name="method">Matrix inversion method</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.IsContinuous">
            <summary>
            Reports whether the matrix is continuous or not.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.IsSubmatrix">
            <summary>
            Returns whether this matrix is a part of other matrix or not.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.LocateROI(OpenCv30Sharp.Size@,OpenCv30Sharp.Point@)">
            <summary>
            Locates the matrix header within a parent matrix.
            </summary>
            <param name="wholeSize">Output parameter that contains the size of the whole matrix containing *this as a part.</param>
            <param name="ofs">Output parameter that contains an offset of *this inside the whole matrix.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Mul(OpenCv30Sharp.Mat,System.Double)">
            <summary>
            Performs an element-wise multiplication or division of the two matrices.
            </summary>
            <param name="m"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Reshape(System.Int32,System.Int32[])">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="newDims">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Rows">
            <summary>
            the number of rows or -1 when the array has more than 2 dimensions
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Height">
            <summary>
            the number of rows or -1 when the array has more than 2 dimensions
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetTo(OpenCv30Sharp.Scalar,OpenCv30Sharp.InputArray)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetTo(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Size">
            <summary>
            Returns a matrix size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Size(System.Int32)">
            <summary>
            Returns a matrix size.
            </summary>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Step">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Step(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Step1">
            <summary>
            Returns a normalized step.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Step1(System.Int32)">
            <summary>
            Returns a normalized step.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.T">
            <summary>
            Transposes a matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Total">
            <summary>
            Returns the total number of array elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Type">
            <summary>
            Returns the type of a matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ToString">
            <summary>
            Returns a string that represents this Mat.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Dump(OpenCv30Sharp.DumpFormat)">
            <summary>
            Returns a string that represents each element value of Mat.
            This method corresponds to std::ostream &lt;&lt; Mat
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.EmptyClone">
            <summary>
            Makes a Mat that have the same size, depth and channels as this image
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Ptr(System.Int32)">
            <summary>
            Returns a pointer to the specified matrix row.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Ptr(System.Int32,System.Int32)">
            <summary>
            Returns a pointer to the specified matrix element.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Ptr(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a pointer to the specified matrix element.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Ptr(System.Int32[])">
            <summary>
            Returns a pointer to the specified matrix element.
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Mat.Indexer`1">
            <summary>
            Mat Indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Indexer`1.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Indexer`1.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Indexer`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Indexer`1.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetGenericIndexer``1">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Get``1(System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Get``1(System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Get``1(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Get``1(System.Int32[])">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.At``1(System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.At``1(System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.At``1(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.At``1(System.Int32[])">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Set``1(System.Int32,``0)">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Set``1(System.Int32,System.Int32,``0)">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Set``1(System.Int32,System.Int32,System.Int32,``0)">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Set``1(System.Int32[],``0)">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ColRange(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="startCol"></param>
            <param name="endCol"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ColRange(OpenCv30Sharp.Range)">
            <summary>
            
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Mat.ColIndexer">
            <summary>
            Mat column's indexer object
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ColIndexer.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.Mat.ColIndexer.Item(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.ColIndexer.Item(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified column span.
            </summary>
            <param name="startCol">An inclusive 0-based start index of the column span.</param>
            <param name="endCol">An exclusive 0-based ending index of the column span.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Col">
            <summary>
            Indexer to access Mat column as Mat
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.RowRange(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="startRow"></param>
            <param name="endRow"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.RowRange(OpenCv30Sharp.Range)">
            <summary>
            
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Mat.RowIndexer">
            <summary>
            Mat row's indexer object
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat.RowIndexer.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.Mat.RowIndexer.Item(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.RowIndexer.Item(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified column span.
            </summary>
            <param name="startCol">An inclusive 0-based start index of the column span.</param>
            <param name="endCol">An exclusive 0-based ending index of the column span.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat.Row">
            <summary>
            Indexer to access Mat row as Mat
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SubMat(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colStart"></param>
            <param name="colEnd"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SubMat(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            
            </summary>
            <param name="rowRange"></param>
            <param name="colRange"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SubMat(OpenCv30Sharp.Rect)">
            <summary>
            
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SubMat(OpenCv30Sharp.Range[])">
            <summary>
            
            </summary>
            <param name="ranges"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Byte[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Byte[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Int16[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Int16[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.UInt16[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.UInt16[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Int32[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Single[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Single[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Double[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,System.Double[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32)">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec3b[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec3b[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec3d[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec3d[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec4f[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec4f[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec6f[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec6f[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec4i[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec4i[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point2f[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point2f[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point2d[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point2d[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3i[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3i[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3f[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3f[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3d[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3d[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Rect[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.Rect[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.DMatch[])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.GetArray(System.Int32,System.Int32,OpenCv30Sharp.DMatch[0:,0:])">
            <summary>
            Get the data of this matrix as array
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Byte[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Byte[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Int16[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Int16[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.UInt16[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.UInt16[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Int32[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Single[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Single[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Double[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,System.Double[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec3b[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec3b[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec3d[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec3d[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec4f[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec4f[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec6f[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec6f[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec4i[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Vec4i[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point2f[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point2f[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point2d[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point2d[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3i[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3i[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3f[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3f[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3d[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Point3d[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Rect[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.Rect[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.DMatch[])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.SetArray(System.Int32,System.Int32,OpenCv30Sharp.DMatch[0:,0:])">
            <summary>
            Set the specified array data to this matrix
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Reserve(System.Int64)">
            <summary>
            reserves enough space to fit sz hyper-planes
            </summary>
            <param name="sz"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Resize(System.Int64)">
            <summary>
            resizes matrix to the specified number of hyper-planes
            </summary>
            <param name="sz"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Resize(System.Int64,OpenCv30Sharp.Scalar)">
            <summary>
            resizes matrix to the specified number of hyper-planes; initializes the newly added elements
            </summary>
            <param name="sz"></param>
            <param name="s"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Add(OpenCv30Sharp.Mat)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat.push_back)
            </summary>
            <param name="m">Added line(s)</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PushBack(OpenCv30Sharp.Mat)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat.push_back)
            </summary>
            <param name="m">Added line(s)</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.PopBack(System.Int64)">
            <summary>
            removes several hyper-planes from bottom of the matrix (Mat.pop_back)
            </summary>
            <param name="nElems"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ToBytes(System.String,System.Int32[])">
            <summary>
            Encodes an image into a memory buffer.
            </summary>
            <param name="ext">Encodes an image into a memory buffer.</param>
            <param name="prms">Format-specific parameters.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ToBytes(System.String,OpenCv30Sharp.ImageEncodingParam[])">
            <summary>
            Encodes an image into a memory buffer.
            </summary>
            <param name="ext">Encodes an image into a memory buffer.</param>
            <param name="prms">Format-specific parameters.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ToMemoryStream(System.String,OpenCv30Sharp.ImageEncodingParam[])">
            <summary>
            Converts Mat to System.IO.MemoryStream
            </summary>
            <param name="ext"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.WriteToStream(System.IO.Stream,System.String,OpenCv30Sharp.ImageEncodingParam[])">
            <summary>
            Writes image data encoded from this Mat to System.IO.Stream
            </summary>
            <param name="stream"></param>
            <param name="ext"></param>
            <param name="prms"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Alignment(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.Cast``1">
            <summary>
            Creates type-specific Mat instance from this.
            </summary>
            <typeparam name="TMat"></typeparam>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsByte(OpenCv30Sharp.MatForeachFunctionByte)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec2b(OpenCv30Sharp.MatForeachFunctionVec2b)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec3b(OpenCv30Sharp.MatForeachFunctionVec3b)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec4b(OpenCv30Sharp.MatForeachFunctionVec4b)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec6b(OpenCv30Sharp.MatForeachFunctionVec6b)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsInt16(OpenCv30Sharp.MatForeachFunctionInt16)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec2s(OpenCv30Sharp.MatForeachFunctionVec2s)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec3s(OpenCv30Sharp.MatForeachFunctionVec3s)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec4s(OpenCv30Sharp.MatForeachFunctionVec4s)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec6s(OpenCv30Sharp.MatForeachFunctionVec6s)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsInt32(OpenCv30Sharp.MatForeachFunctionInt32)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec2i(OpenCv30Sharp.MatForeachFunctionVec2i)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec3i(OpenCv30Sharp.MatForeachFunctionVec3i)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec4i(OpenCv30Sharp.MatForeachFunctionVec4i)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec6i(OpenCv30Sharp.MatForeachFunctionVec6i)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsFloat(OpenCv30Sharp.MatForeachFunctionFloat)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec2f(OpenCv30Sharp.MatForeachFunctionVec2f)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec3f(OpenCv30Sharp.MatForeachFunctionVec3f)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec4f(OpenCv30Sharp.MatForeachFunctionVec4f)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec6f(OpenCv30Sharp.MatForeachFunctionVec6f)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsDouble(OpenCv30Sharp.MatForeachFunctionDouble)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec2d(OpenCv30Sharp.MatForeachFunctionVec2d)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec3d(OpenCv30Sharp.MatForeachFunctionVec3d)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec4d(OpenCv30Sharp.MatForeachFunctionVec4d)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat.ForEachAsVec6d(OpenCv30Sharp.MatForeachFunctionVec6d)">
            <summary>
            
            </summary>
            <param name="operation"></param>
        </member>
        <member name="T:OpenCv30Sharp.Rectf">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rectf.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rectf.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rectf.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rectf.Height">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rectf.SizeOf">
            <summary>
            sizeof(Rect)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rectf.Empty">
            <summary>
            Represents a CvRect structure with its properties left uninitialized. 
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.#ctor(OpenCv30Sharp.Point2f,OpenCv30Sharp.Size2f)">
            <summary>
            
            </summary>
            <param name="location"></param>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.FromLTRB(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Equals(OpenCv30Sharp.Rectf)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.op_Equality(OpenCv30Sharp.Rectf,OpenCv30Sharp.Rectf)">
            <summary>
            Compares two Rectf objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.op_Inequality(OpenCv30Sharp.Rectf,OpenCv30Sharp.Rectf)">
            <summary>
            Compares two Rectf objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.op_Addition(OpenCv30Sharp.Rectf,OpenCv30Sharp.Point2f)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.op_Subtraction(OpenCv30Sharp.Rectf,OpenCv30Sharp.Point2f)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.op_Addition(OpenCv30Sharp.Rectf,OpenCv30Sharp.Size2f)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.op_Subtraction(OpenCv30Sharp.Rectf,OpenCv30Sharp.Size2f)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.op_BitwiseAnd(OpenCv30Sharp.Rectf,OpenCv30Sharp.Rectf)">
            <summary>
            Determines the CvRect structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.op_BitwiseOr(OpenCv30Sharp.Rectf,OpenCv30Sharp.Rectf)">
            <summary>
            Gets a CvRect structure that contains the union of two CvRect structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Rectf.Top">
            <summary>
            Gets the y-coordinate of the top edge of this CvRect structure. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rectf.Bottom">
            <summary>
            Gets the y-coordinate that is the sum of the Y and Height property values of this CvRect structure.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rectf.Left">
            <summary>
            Gets the x-coordinate of the left edge of this CvRect structure. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rectf.Right">
            <summary>
            Gets the x-coordinate that is the sum of X and Width property values of this CvRect structure. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rectf.Location">
            <summary>
            Coordinate of the left-most rectangle corner [Point2f(X, Y)]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rectf.Size">
            <summary>
            Size of the rectangle [CvSize(Width, Height)]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rectf.TopLeft">
            <summary>
            Coordinate of the left-most rectangle corner [Point2f(X, Y)]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rectf.BottomRight">
            <summary>
            Coordinate of the right-most rectangle corner [Point2f(X+Width, Y+Height)]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Contains(System.Single,System.Single)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="x">x-coordinate of the point</param>
            <param name="y">y-coordinate of the point</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Contains(OpenCv30Sharp.Point2f)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="pt">point</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Contains(OpenCv30Sharp.Rectf)">
            <summary>
            Determines if the specified rectangle is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="rect">rectangle</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Inflate(System.Single,System.Single)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="width">The amount to inflate this Rectangle horizontally. </param>
            <param name="height">The amount to inflate this Rectangle vertically. </param>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Inflate(OpenCv30Sharp.Size2f)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="size">The amount to inflate this rectangle. </param>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Inflate(OpenCv30Sharp.Rect,System.Int32,System.Int32)">
            <summary>
            Creates and returns an inflated copy of the specified CvRect structure.
            </summary>
            <param name="rect">The Rectangle with which to start. This rectangle is not modified. </param>
            <param name="x">The amount to inflate this Rectangle horizontally. </param>
            <param name="y">The amount to inflate this Rectangle vertically. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Intersect(OpenCv30Sharp.Rectf,OpenCv30Sharp.Rectf)">
            <summary>
            Determines the CvRect structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Intersect(OpenCv30Sharp.Rectf)">
            <summary>
            Determines the CvRect structure that represents the intersection of two rectangles. 
            </summary>
            <param name="rect">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.IntersectsWith(OpenCv30Sharp.Rectf)">
            <summary>
            Determines if this rectangle intersects with rect. 
            </summary>
            <param name="rect">Rectangle</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Union(OpenCv30Sharp.Rectf)">
            <summary>
            Gets a CvRect structure that contains the union of two CvRect structures. 
            </summary>
            <param name="rect">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Union(OpenCv30Sharp.Rectf,OpenCv30Sharp.Rectf)">
            <summary>
            Gets a CvRect structure that contains the union of two CvRect structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rectf.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:OpenCv30Sharp.FlannBasedMatcher">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FlannBasedMatcher.#ctor(OpenCv30Sharp.Flann.IndexParams,OpenCv30Sharp.Flann.SearchParams)">
            <summary>
            
            </summary>
            <param name="indexParams"></param>
            <param name="searchParams"></param>
        </member>
        <member name="M:OpenCv30Sharp.FlannBasedMatcher.#ctor(OpenCv30Sharp.Ptr{OpenCv30Sharp.FlannBasedMatcher})">
            <summary>
            Creates instance by cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FlannBasedMatcher.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer T*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FlannBasedMatcher.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.FlannBasedMatcher.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.FlannBasedMatcher.IsMaskSupported">
            <summary>
            Return true if the matcher supports mask in match methods.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FlannBasedMatcher.Add(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat})">
            <summary>
            Add descriptors to train descriptor collection.
            </summary>
            <param name="descriptors">Descriptors to add. Each descriptors[i] is a descriptors set from one image.</param>
        </member>
        <member name="M:OpenCv30Sharp.FlannBasedMatcher.Clear">
            <summary>
            Clear train descriptors collection.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FlannBasedMatcher.Train">
            <summary>
            Train matcher (e.g. train flann index).
            In all methods to match the method train() is run every time before matching.
            Some descriptor matchers (e.g. BruteForceMatcher) have empty implementation
            of this method, other matchers really train their inner structures
            (e.g. FlannBasedMatcher trains flann::Index). So nonempty implementation
            of train() should check the class object state and do traing/retraining
            only if the state requires that (e.g. FlannBasedMatcher trains flann::Index
            if it has not trained yet or if new descriptors have been added to the train collection).
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.CvTrackbar">
            <summary>
            Trackbar that is shown on CvWindow
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CvTrackbar.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CvTrackbar.#ctor(System.String,System.String,OpenCv30Sharp.CvTrackbarCallback2)">
            <summary>
            Constructor (value=0, max=100)
            </summary>
            <param name="name">Trackbar name</param>
            <param name="window">Window name</param>
            <param name="callback">Callback handler</param>
        </member>
        <member name="M:OpenCv30Sharp.CvTrackbar.#ctor(System.String,System.String,System.Int32,System.Int32,OpenCv30Sharp.CvTrackbarCallback2)">
            <summary>
            Constructor
            </summary>
            <param name="name">Trackbar name</param>
            <param name="window">Window name</param>
            <param name="value">Initial slider position</param>
            <param name="max">The upper limit of the range this trackbar is working with. </param>
            <param name="callback">Callback handler</param>
        </member>
        <member name="M:OpenCv30Sharp.CvTrackbar.#ctor(System.String,System.String,System.Int32,System.Int32,OpenCv30Sharp.CvTrackbarCallback2,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="name">Trackbar name</param>
            <param name="window">Window name</param>
            <param name="value">Initial slider position</param>
            <param name="max">The upper limit of the range this trackbar is working with. </param>
            <param name="callback">Callback handler</param>
            <param name="userdata"></param>
        </member>
        <member name="M:OpenCv30Sharp.CvTrackbar.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.CvTrackbar.TrackbarName">
            <summary>
            Name of this trackbar
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.CvTrackbar.WindowName">
            <summary>
            Name of parent window
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.CvTrackbar.Pos">
            <summary>
            Gets or sets a numeric value that represents the current position of the scroll box on the track bar. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.CvTrackbar.Max">
            <summary>
            Gets the upper limit of the range this trackbar is working with. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.CvTrackbar.Callback">
            <summary>
            Gets the callback delegate which occurs when the Value property of a track bar changes, either by movement of the scroll box or by manipulation in code. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.CvTrackbar.Userdata">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.CvTrackbar.Result">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ColormapTypes">
            <summary>
            GNU Octave/MATLAB equivalent colormaps
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.BackgroundSubtractorKNN">
            <summary>
            K nearest neigbours algorithm
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BackgroundSubtractorKNN.objectPtr">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BackgroundSubtractorKNN.disposed">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractorKNN.Create(System.Int32,System.Double,System.Boolean)">
            <summary>
            
            </summary>
            <param name="history"></param>
            <param name="dist2Threshold"></param>
            <param name="detectShadows"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractorKNN.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorKNN.History">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorKNN.NSamples">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorKNN.Dist2Threshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorKNN.KNNSamples">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorKNN.DetectShadows">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorKNN.ShadowValue">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorKNN.ShadowThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.XFeatures2D.BriefDescriptorExtractor">
            <summary>
            BRIEF Descriptor
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.XFeatures2D.BriefDescriptorExtractor.ptrObj">
            <summary>
            cv::Ptr&lt;BriefDescriptorExtractor&gt;
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.BriefDescriptorExtractor.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.BriefDescriptorExtractor.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.BriefDescriptorExtractor.Create(System.Int32)">
            <summary>
            bytes is a length of descriptor in bytes. It can be equal 16, 32 or 64 bytes.
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.BriefDescriptorExtractor.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.XFeatures2D.FREAK">
            <summary>
            FREAK implementation
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.FREAK.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.FREAK.Create(System.Boolean,System.Boolean,System.Single,System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="orientationNormalized">enable orientation normalization</param>
            <param name="scaleNormalized">enable scale normalization</param>
            <param name="patternScale">scaling of the description pattern</param>
            <param name="nOctaves">number of octaves covered by the detected keypoints</param>
            <param name="selectedPairs">(optional) user defined selected pairs</param>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.FREAK.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.XFeatures2D.SIFT">
            <summary>
            SIFT implementation.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.SIFT.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::SURF*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.SIFT.Create(System.Int32,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            The SIFT constructor.
            </summary>
            <param name="nFeatures">The number of best features to retain. 
            The features are ranked by their scores (measured in SIFT algorithm as the local contrast)</param>
            <param name="nOctaveLayers">The number of layers in each octave. 3 is the value used in D. Lowe paper. 
            The number of octaves is computed automatically from the image resolution.</param>
            <param name="contrastThreshold">The contrast threshold used to filter out weak features in semi-uniform 
            (low-contrast) regions. The larger the threshold, the less features are produced by the detector.</param>
            <param name="edgeThreshold">The threshold used to filter out edge-like features. Note that the its meaning is 
            different from the contrastThreshold, i.e. the larger the edgeThreshold, the less features are filtered out (more features are retained).</param>
            <param name="sigma">The sigma of the Gaussian applied to the input image at the octave #0. 
            If your image is captured with a weak camera with soft lenses, you might want to reduce the number.</param>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.SIFT.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.XFeatures2D.SURF">
            <summary>
            Class for extracting Speeded Up Robust Features from an image.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.SURF.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::SURF*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.SURF.Create(System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            The SURF constructor.
            </summary>
            <param name="hessianThreshold">Only features with keypoint.hessian larger than that are extracted. </param>
            <param name="nOctaves">The number of a gaussian pyramid octaves that the detector uses. It is set to 4 by default. 
            If you want to get very large features, use the larger value. If you want just small features, decrease it.</param>
            <param name="nOctaveLayers">The number of images within each octave of a gaussian pyramid. It is set to 2 by default.</param>
            <param name="extended">false means basic descriptors (64 elements each), true means extended descriptors (128 elements each) </param>
            <param name="upright">false means that detector computes orientation of each feature.
            true means that the orientation is not computed (which is much, much faster).</param>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.SURF.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.XFeatures2D.SURF.HessianThreshold">
            <summary>
            Threshold for the keypoint detector. Only features, whose hessian is larger than hessianThreshold 
            are retained by the detector. Therefore, the larger the value, the less keypoints you will get. 
            A good default value could be from 300 to 500, depending from the image contrast.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.XFeatures2D.SURF.NOctaves">
            <summary>
            The number of a gaussian pyramid octaves that the detector uses. It is set to 4 by default. 
            If you want to get very large features, use the larger value. If you want just small features, decrease it.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.XFeatures2D.SURF.NOctaveLayers">
            <summary>
            The number of images within each octave of a gaussian pyramid. It is set to 2 by default.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.XFeatures2D.SURF.Extended">
            <summary>
            false means that the basic descriptors (64 elements each) shall be computed. 
            true means that the extended descriptors (128 elements each) shall be computed
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.XFeatures2D.SURF.Upright">
            <summary>
            false means that detector computes orientation of each feature.
            true means that the orientation is not computed (which is much, much faster). 
            For example, if you match images from a stereo pair, or do image stitching, the matched features 
            likely have very similar angles, and you can speed up feature extraction by setting upright=true.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.XFeatures2D.StarDetector">
            <summary>
            The "Star" Detector
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.StarDetector.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.StarDetector.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="maxSize"></param>
            <param name="responseThreshold"></param>
            <param name="lineThresholdProjected"></param>
            <param name="lineThresholdBinarized"></param>
            <param name="suppressNonmaxSize"></param>
        </member>
        <member name="M:OpenCv30Sharp.XFeatures2D.StarDetector.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.Flann.FlannDistance">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Flann.FlannCentersInit">
            <summary>
            The algorithm to use for selecting the initial centers when performing a k-means clustering step. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Flann.FlannCentersInit.Random">
            <summary>
            picks the initial cluster centers randomly
            [flann_centers_init_t::CENTERS_RANDOM]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Flann.FlannCentersInit.Gonzales">
            <summary>
            picks the initial centers using Gonzales’ algorithm
            [flann_centers_init_t::CENTERS_GONZALES]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Flann.FlannCentersInit.KMeansPP">
            <summary>
            picks the initial centers using the algorithm suggested in [arthur_kmeanspp_2007]
            [flann_centers_init_t::CENTERS_KMEANSPP]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Flann.Index">
            <summary>
            The FLANN nearest neighbor index class. 
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.Index.#ctor(OpenCv30Sharp.InputArray,OpenCv30Sharp.Flann.IndexParams,OpenCv30Sharp.Flann.FlannDistance)">
            <summary>
            Constructs a nearest neighbor search index for a given dataset.
            </summary>
            <param name="features">features – Matrix of type CV _ 32F containing the features(points) to index. The size of the matrix is num _ features x feature _ dimensionality.</param>
            <param name="params">Structure containing the index parameters. The type of index that will be constructed depends on the type of this parameter. </param>
            <param name="distType"></param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.Index.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.Index.KnnSearch(System.Single[],System.Int32[]@,System.Single[]@,System.Int32,OpenCv30Sharp.Flann.SearchParams)">
            <summary>
            Performs a K-nearest neighbor search for multiple query points.
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.Index.KnnSearch(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Int32,OpenCv30Sharp.Flann.SearchParams)">
            <summary>
            Performs a K-nearest neighbor search for multiple query points.
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.Index.KnnSearch(OpenCv30Sharp.Mat,System.Int32[]@,System.Single[]@,System.Int32,OpenCv30Sharp.Flann.SearchParams)">
            <summary>
            Performs a K-nearest neighbor search for multiple query points.
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.Index.RadiusSearch(System.Single[],System.Int32[],System.Single[],System.Single,System.Int32,OpenCv30Sharp.Flann.SearchParams)">
            <summary>
            Performs a radius nearest neighbor search for a given query point.
            </summary>
            <param name="queries">The query point</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="radius">Number of nearest neighbors to search for</param>
            <param name="maxResults"></param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.Index.RadiusSearch(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Single,System.Int32,OpenCv30Sharp.Flann.SearchParams)">
            <summary>
            Performs a radius nearest neighbor search for a given query point.
            </summary>
            <param name="queries">The query point</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="radius">Number of nearest neighbors to search for</param>
            <param name="maxResults"></param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.Index.RadiusSearch(OpenCv30Sharp.Mat,System.Int32[],System.Single[],System.Single,System.Int32,OpenCv30Sharp.Flann.SearchParams)">
            <summary>
            Performs a radius nearest neighbor search for a given query point.
            </summary>
            <param name="queries">The query point</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="dists">Distances to the nearest neighbors found</param>
            <param name="radius">Number of nearest neighbors to search for</param>
            <param name="maxResults"></param>
            <param name="params">Search parameters</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.Index.Save(System.String)">
            <summary>
            Saves the index to a file.
            </summary>
            <param name="filename">The file to save the index to</param>
        </member>
        <member name="T:OpenCv30Sharp.Flann.AutotunedIndexParams">
            <summary>
            hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.AutotunedIndexParams.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="targetPrecision">Is a number between 0 and 1 specifying the percentage of the approximate nearest-neighbor searches that return the exact nearest-neighbor. 
            Using a higher value for this parameter gives more accurate results, but the search takes longer. The optimum value usually depends on the application.</param>
            <param name="buildWeight">Specifies the importance of the index build time raported to the nearest-neighbor search time. 
            In some applications it’s acceptable for the index build step to take a long time if the subsequent searches in the index can be performed very fast. 
            In other applications it’s required that the index be build as fast as possible even if that leads to slightly longer search times.</param>
            <param name="memoryWeight">Is used to specify the tradeoff between time (index build time and search time) and memory used by the index. 
            A value less than 1 gives more importance to the time spent and a value greater than 1 gives more importance to the memory usage.</param>
            <param name="sampleFraction">Is a number between 0 and 1 indicating what fraction of the dataset to use in the automatic parameter configuration algorithm. 
            Running the algorithm on the full dataset gives the most accurate results, but for very large datasets can take longer than desired. 
            In such case using just a fraction of the data helps speeding up this algorithm while still giving good approximations of the optimum parameters.</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.AutotunedIndexParams.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.Flann.CompositeIndexParams">
            <summary>
            When using a parameters object of this type the index created combines the randomized kd-trees and the hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.CompositeIndexParams.#ctor(System.Int32,System.Int32,System.Int32,OpenCv30Sharp.Flann.FlannCentersInit,System.Single)">
            <summary>
            
            </summary>
            <param name="trees">The number of parallel kd-trees to use. Good values are in the range [1..16]</param>
            <param name="branching">The branching factor to use for the hierarchical k-means tree</param>
            <param name="iterations">The maximum number of iterations to use in the k-means clustering stage when building the k-means tree. A value of -1 used here means that the k-means clustering should be iterated until convergence</param>
            <param name="centersInit">The algorithm to use for selecting the initial centers when performing a k-means clustering step. </param>
            <param name="cbIndex">This parameter (cluster boundary index) influences the way exploration is performed in the hierarchical kmeans tree. When cb_index is zero the next kmeans domain to be explored is choosen to be the one with the closest center. A value greater then zero also takes into account the size of the domain.</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.CompositeIndexParams.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.Flann.IndexParams">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.GetString(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.GetString(System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.GetInt(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.GetInt(System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.GetDouble(System.String,System.Double)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.GetDouble(System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.SetString(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.SetInt(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.SetDouble(System.String,System.Double)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.SetFloat(System.String,System.Single)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.SetBool(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.IndexParams.SetAlgorithm(System.Int32)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:OpenCv30Sharp.Flann.KDTreeIndexParams">
            <summary>
            When passing an object of this type the index constructed will consist of a set
            of randomized kd-trees which will be searched in parallel.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.KDTreeIndexParams.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="trees">The number of parallel kd-trees to use. Good values are in the range [1..16]</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.KDTreeIndexParams.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.Flann.KMeansIndexParams">
            <summary>
            When passing an object of this type the index constructed will be a hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.KMeansIndexParams.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Flann.FlannCentersInit,System.Single)">
            <summary>
            
            </summary>
            <param name="branching">The branching factor to use for the hierarchical k-means tree</param>
            <param name="iterations">The maximum number of iterations to use in the k-means clustering stage when building the k-means tree. A value of -1 used here means that the k-means clustering should be iterated until convergence</param>
            <param name="centersInit">The algorithm to use for selecting the initial centers when performing a k-means clustering step. </param>
            <param name="cbIndex">This parameter (cluster boundary index) influences the way exploration is performed in the hierarchical kmeans tree. When cb_index is zero the next kmeans domain to be explored is choosen to be the one with the closest center. A value greater then zero also takes into account the size of the domain.</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.KMeansIndexParams.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.Flann.LinearIndexParams">
            <summary>
            the index will perform a linear, brute-force search.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.LinearIndexParams.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.LinearIndexParams.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.Flann.SavedIndexParams">
            <summary>
            This object type is used for loading a previously saved index from the disk.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.SavedIndexParams.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="filename">インデックスが保存されたファイル名</param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.SavedIndexParams.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.Flann.SearchParams">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.SearchParams.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Flann.SearchParams.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="checks"></param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.SearchParams.#ctor(System.Int32,System.Single)">
            <summary>
            
            </summary>
            <param name="checks"></param>
            <param name="eps"></param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.SearchParams.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            
            </summary>
            <param name="checks"></param>
            <param name="eps"></param>
            <param name="sorted"></param>
        </member>
        <member name="M:OpenCv30Sharp.Flann.SearchParams.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.LineIterator">
            <summary>
            Contrast Limited Adaptive Histogram Equalization
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LineIterator.#ctor(OpenCv30Sharp.Mat,OpenCv30Sharp.Point,OpenCv30Sharp.Point,OpenCv30Sharp.PixelConnectivity,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="img"></param>
            <param name="pt1"></param>
            <param name="pt2"></param>
            <param name="connectivity"></param>
            <param name="leftToRight"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineIterator.Initialize">
            <summary>
            Intializes the iterator
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineIterator.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.LineIterator.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.Ptr">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.Ptr0">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.Step">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.ElemSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.Err">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.MinusDelta">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.PlusDelta">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.MinusStep">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.PlusStep">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.LineIterator.Pixel">
            <summary>
            LineIterator pixel data
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.Pixel.ValuePointer">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.Pixel.Pos">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LineIterator.Pixel.Value">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LineIterator.Pixel.GetValue``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineIterator.Pixel.SetValue``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LineIterator.Pixel.#ctor(OpenCv30Sharp.Point,System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="pos"></param>
            <param name="value"></param>
        </member>
        <member name="T:OpenCv30Sharp.EM">
            <summary>
            The class implements the Expectation Maximization algorithm.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.EM.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.EM.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::ml::EM*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.EM.Create">
            <summary>
            Creates empty EM model. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.EM.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.EM.ClustersNumber">
            <summary>
            The number of mixture components in the Gaussian mixture model.
            Default value of the parameter is EM::DEFAULT_NCLUSTERS=5. 
            Some of EM implementation could determine the optimal number of mixtures 
            within a specified value range, but that is not the case in ML yet.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.EM.CovarianceMatrixType">
            <summary>
            Constraint on covariance matrices which defines type of matrices.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.EM.TermCriteria">
            <summary>
            The termination criteria of the %EM algorithm.
            The EM algorithm can be terminated by the number of iterations 
            termCrit.maxCount (number of M-steps) or when relative change of likelihood 
            logarithm is less than termCrit.epsilon. 
            Default maximum number of iterations is EM::DEFAULT_MAX_ITERS=100.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.EM.GetWeights">
            <summary>
            Returns weights of the mixtures.
            Returns vector with the number of elements equal to the number of mixtures.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.EM.GetMeans">
            <summary>
            Returns the cluster centers (means of the Gaussian mixture).
            Returns matrix with the number of rows equal to the number of mixtures and 
            number of columns equal to the space dimensionality.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.EM.GetCovs">
            <summary>
            Returns covariation matrices.
            Returns vector of covariation matrices. Number of matrices is the number of 
            gaussian mixtures, each matrix is a square floating-point matrix NxN, where N is the space dimensionality.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.EM.TrainE(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Estimates Gaussian mixture parameters from the sample set
            </summary>
            <param name="samples"></param>
            <param name="means0"></param>
            <param name="covs0"></param>
            <param name="weights0"></param>
            <param name="logLikelihoods"></param>
            <param name="labels"></param>
            <param name="probs"></param>
        </member>
        <member name="M:OpenCv30Sharp.EM.TrainM(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Estimates Gaussian mixture parameters from the sample set
            </summary>
            <param name="samples"></param>
            <param name="probs0"></param>
            <param name="logLikelihoods"></param>
            <param name="labels"></param>
            <param name="probs"></param>
        </member>
        <member name="M:OpenCv30Sharp.EM.Predict2(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Predicts the response for sample
            </summary>
            <param name="sample"></param>
            <param name="probs"></param>
        </member>
        <member name="T:OpenCv30Sharp.EM.Types">
            <summary>
            Type of covariation matrices
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.EM.Types.CovMatSpherical">
            <summary>
            A scaled identity matrix \f$\mu_k * I\f$. 
            There is the only parameter \f$\mu_k\f$ to be estimated for each matrix. 
            The option may be used in special cases, when the constraint is relevant, 
            or as a first step in the optimization (for example in case when the data is 
            preprocessed with PCA). The results of such preliminary estimation may be 
            passed again to the optimization procedure, this time with covMatType=EM::COV_MAT_DIAGONAL.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.EM.Types.CovMatDiagonal">
            <summary>
            A diagonal matrix with positive diagonal elements. 
            The number of free parameters is d for each matrix. 
            This is most commonly used option yielding good estimation results. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.EM.Types.CovMatGeneric">
            <summary>
            A symmetric positively defined matrix. The number of free parameters in each 
            matrix is about \f$d^2/2\f$. It is not recommended to use this option, unless 
            there is pretty accurate initial estimation of the parameters and/or a huge number 
            of training samples.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.EM.Types.CovMatDefault">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.EM.StartStep">
            <summary>
            The initial step the algorithm starts from
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.EM.StartStep.E">
            <summary>
            The algorithm starts with E-step. 
            At least, the initial values of mean vectors, CvEMParams.Means must be passed. 
            Optionally, the user may also provide initial values for weights (CvEMParams.Weights) 
            and/or covariation matrices (CvEMParams.Covs).
            [CvEM::START_E_STEP]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.EM.StartStep.M">
            <summary>
            The algorithm starts with M-step. The initial probabilities p_i,k must be provided.
            [CvEM::START_M_STEP]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.EM.StartStep.Auto">
            <summary>
            No values are required from the user, k-means algorithm is used to estimate initial mixtures parameters. 
            [CvEM::START_AUTO_STEP]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Stitcher">
            <summary>
            High level image stitcher. 
            It's possible to use this class without being aware of the entire stitching 
            pipeline. However, to be able to achieve higher stitching stability and 
            quality of the final images at least being familiar with the theory is recommended
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Stitcher.Status">
            <summary>
            Status code
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Stitcher.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ptr">cv::Stitcher*</param>
        </member>
        <member name="M:OpenCv30Sharp.Stitcher.Create(System.Boolean)">
            <summary>
            Creates a stitcher with the default parameters.
            </summary>
            <param name="tryUseGpu">Flag indicating whether GPU should be used 
            whenever it's possible.</param>
        </member>
        <member name="M:OpenCv30Sharp.Stitcher.Dispose(System.Boolean)">
            <summary>
            Deletes all resources 
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:OpenCv30Sharp.Stitcher.Stitch(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            Try to stitch the given images.
            </summary>
            <param name="images">Input images.</param>
            <param name="pano">Final pano.</param>
            <returns>Status code.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Stitcher.Stitch(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},OpenCv30Sharp.OutputArray)">
            <summary>
            Try to stitch the given images.
            </summary>
            <param name="images">Input images.</param>
            <param name="pano">Final pano.</param>
            <returns>Status code.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Stitcher.Stitch(OpenCv30Sharp.InputArray,OpenCv30Sharp.Rect[][],OpenCv30Sharp.OutputArray)">
            <summary>
            Try to stitch the given images.
            </summary>
            <param name="images">Input images.</param>
            <param name="rois">Region of interest rectangles.</param>
            <param name="pano">Final pano.</param>
            <returns>Status code.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Stitcher.Stitch(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},OpenCv30Sharp.Rect[][],OpenCv30Sharp.OutputArray)">
            <summary>
            Try to stitch the given images.
            </summary>
            <param name="images">Input images.</param>
            <param name="rois">Region of interest rectangles.</param>
            <param name="pano">Final pano.</param>
            <returns>Status code.</returns>
        </member>
        <member name="T:OpenCv30Sharp.OpticalFlowFlags">
            <summary>
            cv::calcOpticalFlowPyrLK flags
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.OpticalFlowFlags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.OpticalFlowFlags.PyrAReady">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.OpticalFlowFlags.PyrBReady">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.OpticalFlowFlags.UseInitialFlow">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.OpticalFlowFlags.LkGetMinEigenvals">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.OpticalFlowFlags.FarnebackGaussian">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.SolvePnPFlags">
            <summary>
            Method for solving a PnP problem:
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SolvePnPFlags.Iterative">
            <summary>
            Iterative method is based on Levenberg-Marquardt optimization. 
            In this case the function finds such a pose that minimizes reprojection error, 
            that is the sum of squared distances between the observed projections imagePoints and the projected (using projectPoints() ) objectPoints .
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SolvePnPFlags.EPNP">
            <summary>
            Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the paper “EPnP: Efficient Perspective-n-Point Camera Pose Estimation”.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SolvePnPFlags.P3P">
            <summary>
            Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang“Complete Solution Classification for 
            the Perspective-Three-Point Problem”. In this case the function requires exactly four object and image points.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SolvePnPFlags.DLS">
            <summary>
            Joel A. Hesch and Stergios I. Roumeliotis. "A Direct Least-Squares (DLS) Method for PnP"
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SolvePnPFlags.UPNP">
            <summary>
            A.Penate-Sanchez, J.Andrade-Cetto, F.Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length Estimation"
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DrawMatchesFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DrawMatchesFlags.Default">
            <summary>
            Output image matrix will be created (Mat::create),
            i.e. existing memory of output image may be reused.
            Two source image, matches and single keypoints will be drawn.
            For each keypoint only the center point will be drawn (without
            the circle around keypoint with keypoint size and orientation).
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DrawMatchesFlags.DrawOverOutImg">
            <summary>
            Output image matrix will not be created (Mat::create).
            Matches will be drawn on existing content of output image.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DrawMatchesFlags.NotDrawSinglePoints">
            <summary>
            Single keypoints will not be drawn.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DrawMatchesFlags.DrawRichKeypoints">
            <summary>
            For each keypoint the circle around keypoint with keypoint size and
            orientation will be drawn.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ORBScore">
            <summary>
            cv::ORB score flags
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ORBScore.Fast">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ORBScore.Harris">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.ProjectionType">
            <summary>
            cv::initWideAngleProjMap flags
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ProjectionType.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ProjectionType.SphericalOrtho">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.ProjectionType.SphericalEqRect">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.GrabCutModes">
            <summary>
            GrabCut algorithm flags
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GrabCutModes.InitWithRect">
            <summary>
             The function initializes the state and the mask using the provided rectangle. 
            After that it runs iterCount iterations of the algorithm.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GrabCutModes.InitWithMask">
            <summary>
             The function initializes the state using the provided mask. 
            Note that GC_INIT_WITH_RECT and GC_INIT_WITH_MASK can be combined. 
            Then, all the pixels outside of the ROI are automatically initialized with GC_BGD .
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.GrabCutModes.Eval">
            <summary>
             The value means that the algorithm should just resume.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DistanceMaskSize">
            <summary>
            Mask size for distance transform
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceMaskSize.Mask3">
            <summary>
            3
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceMaskSize.Mask5">
            <summary>
            5
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DistanceMaskSize.Precise">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.AlgorithmParamType">
            <summary>
            cv::Algorithm parameter type
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.SparseMatIndexer`1">
            <summary>
            Abstract definition of Mat indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OpenCv30Sharp.SparseMatIndexer`1.Item(System.Int32,System.Nullable{System.Int64})">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.SparseMatIndexer`1.Item(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.SparseMatIndexer`1.Item(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.SparseMatIndexer`1.Item(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="F:OpenCv30Sharp.SparseMatIndexer`1.parent">
            <summary>
            Parent matrix object
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SparseMatIndexer`1.#ctor(OpenCv30Sharp.SparseMat)">
            <summary>
            Constructor
            </summary>
            <param name="parent"></param>
        </member>
        <member name="T:OpenCv30Sharp.SparseMat">
            <summary>
            Sparse matrix class.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::SparseMat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.#ctor">
            <summary>
            Creates empty SparseMat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.MatType)">
            <summary>
            constructs n-dimensional sparse matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            converts old-style CvMat to the new matrix; the data is not copied by default
            </summary>
            <param name="m">cv::Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Release">
            <summary>
            Releases the resources
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.FromMat(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="F:OpenCv30Sharp.SparseMat.SizeOf">
            <summary>
            sizeof(cv::Mat)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.AssignFrom(OpenCv30Sharp.SparseMat)">
            <summary>
            Assignment operator. This is O(1) operation, i.e. no data is copied
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.AssignFrom(OpenCv30Sharp.Mat)">
            <summary>
            Assignment operator. equivalent to the corresponding constructor.
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Clone">
            <summary>
            creates full copy of the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.CopyTo(OpenCv30Sharp.SparseMat)">
            <summary>
            copies all the data to the destination matrix. All the previous content of m is erased.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.CopyTo(OpenCv30Sharp.Mat)">
            <summary>
            converts sparse matrix to dense matrix.
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.ConvertTo(OpenCv30Sharp.SparseMat,System.Int32,System.Double)">
            <summary>
            multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type
            </summary>
            <param name="m"></param>
            <param name="rtype"></param>
            <param name="alpha"></param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.ConvertTo(OpenCv30Sharp.Mat,System.Int32,System.Double,System.Double)">
            <summary>
            converts sparse matrix to dense n-dim matrix with optional type conversion and scaling.
            </summary>
            <param name="m"></param>
            <param name="rtype">The output matrix data type. When it is =-1, the output array will have the same data type as (*this)</param>
            <param name="alpha">The scale factor</param>
            <param name="beta">The optional delta added to the scaled values before the conversion</param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.AssignTo(OpenCv30Sharp.SparseMat,System.Int32)">
            <summary>
            not used now
            </summary>
            <param name="m"></param>
            <param name="type"></param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Create(OpenCv30Sharp.MatType,System.Int32[])">
            <summary>
            Reallocates sparse matrix.
            If the matrix already had the proper size and type,
            it is simply cleared with clear(), otherwise,
            the old matrix is released (using release()) and the new one is allocated.
            </summary>
            <param name="type"></param>
            <param name="sizes"></param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Clear">
            <summary>
            sets all the sparse matrix elements to 0, which means clearing the hash table.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Addref">
            <summary>
            manually increments the reference counter to the header.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.ElemSize">
            <summary>
            returns the size of each element in bytes (not including the overhead - the space occupied by SparseMat::Node elements)
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.ElemSize1">
            <summary>
            returns elemSize()/channels()
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Type">
            <summary>
            Returns the type of sparse matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Depth">
            <summary>
            Returns the depth of sparse matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Dims">
            <summary>
            Returns the matrix dimensionality
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Channels">
            <summary>
            Returns the number of sparse matrix channels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Size">
            <summary>
            Returns the array of sizes, or null if the matrix is not allocated
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Size(System.Int32)">
            <summary>
            Returns the size of i-th matrix dimension (or 0)
            </summary>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Hash(System.Int32)">
            <summary>
            Computes the element hash value (1D case)
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Hash(System.Int32,System.Int32)">
            <summary>
            Computes the element hash value (2D case)
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Hash(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the element hash value (3D case)
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Hash(System.Int32[])">
            <summary>
            Computes the element hash value (nD case)
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Ptr(System.Int32,System.Boolean,System.Nullable{System.Int64})">
            <summary>
            Low-level element-access function.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="createMissing">Create new element with 0 value if it does not exist in SparseMat.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Ptr(System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int64})">
            <summary>
            Low-level element-access function.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="createMissing">Create new element with 0 value if it does not exist in SparseMat.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Ptr(System.Int32,System.Int32,System.Int32,System.Boolean,System.Nullable{System.Int64})">
            <summary>
            Low-level element-access function.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="createMissing">Create new element with 0 value if it does not exist in SparseMat.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Ptr(System.Int32[],System.Boolean,System.Nullable{System.Int64})">
            <summary>
            Low-level element-access function.
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="createMissing">Create new element with 0 value if it does not exist in SparseMat.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Find``1(System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, null.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Find``1(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, null.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Find``1(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, null.
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Find``1(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, null.
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Value``1(System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, default(T).
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Value``1(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, default(T).
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Value``1(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, default(T).
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Value``1(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            Return pthe specified sparse matrix element if it exists; otherwise, default(T).
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.SparseMat.Indexer`1">
            <summary>
            Mat Indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OpenCv30Sharp.SparseMat.Indexer`1.Item(System.Int32,System.Nullable{System.Int64})">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.SparseMat.Indexer`1.Item(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.SparseMat.Indexer`1.Item(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.SparseMat.Indexer`1.Item(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Ref``1">
            <summary>
            Gets a type-specific indexer. 
            The indexer has getters/setters to access each matrix element.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.GetIndexer``1">
            <summary>
            Gets a type-specific indexer. 
            The indexer has getters/setters to access each matrix element.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Get``1(System.Int32,System.Nullable{System.Int64})">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Get``1(System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Get``1(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int64})">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Get``1(System.Int32[],System.Nullable{System.Int64})">
            <summary>
            Returns a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Set``1(System.Int32,``0,System.Nullable{System.Int64})">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="value"></param>
            <param name="hashVal"></param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Set``1(System.Int32,System.Int32,``0,System.Nullable{System.Int64})">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="value"></param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Set``1(System.Int32,System.Int32,System.Int32,``0,System.Nullable{System.Int64})">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2">Index along the dimension 2</param>
            <param name="value"></param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.Set``1(System.Int32[],``0,System.Nullable{System.Int64})">
            <summary>
            Set a value to the specified array element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="idx">Array of Mat::dims indices.</param>
            <param name="value"></param>
            <param name="hashVal">If hashVal is not null, the element hash value is not computed but hashval is taken instead.</param>
        </member>
        <member name="M:OpenCv30Sharp.SparseMat.ToString">
            <summary>
            Returns a string that represents this Mat.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.CascadeClassifier">
            <summary>
            Cascade classifier class for object detection.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.CascadeClassifier.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.#ctor(System.String)">
            <summary>
            Loads a classifier from a file.
            </summary>
            <param name="fileName">Name of the file from which the classifier is loaded.</param>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.Empty">
            <summary>
            Checks whether the classifier has been loaded.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.Load(System.String)">
            <summary>
            Loads a classifier from a file.
            </summary>
            <param name="fileName">Name of the file from which the classifier is loaded. 
            The file may contain an old HAAR classifier trained by the haartraining application 
            or a new cascade classifier trained by the traincascade application.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.DetectMultiScale(OpenCv30Sharp.Mat,System.Double,System.Int32,OpenCv30Sharp.HaarDetectionType,System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size})">
            <summary>
            Detects objects of different sizes in the input image. The detected objects are returned as a list of rectangles.
            </summary>
            <param name="image">Matrix of the type CV_8U containing an image where objects are detected.</param>
            <param name="scaleFactor">Parameter specifying how much the image size is reduced at each image scale.</param>
            <param name="minNeighbors">Parameter specifying how many neighbors each candidate rectangle should have to retain it.</param>
            <param name="flags">Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. 
            It is not used for a new cascade.</param>
            <param name="minSize">Minimum possible object size. Objects smaller than that are ignored.</param>
            <param name="maxSize">Maximum possible object size. Objects larger than that are ignored.</param>
            <returns>Vector of rectangles where each rectangle contains the detected object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.DetectMultiScale(OpenCv30Sharp.Mat,System.Int32[]@,System.Double[]@,System.Double,System.Int32,OpenCv30Sharp.HaarDetectionType,System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size},System.Boolean)">
            <summary>
            Detects objects of different sizes in the input image. The detected objects are returned as a list of rectangles.
            </summary>
            <param name="image">Matrix of the type CV_8U containing an image where objects are detected.</param>
            <param name="rejectLevels"></param>
            <param name="levelWeights"></param>
            <param name="scaleFactor">Parameter specifying how much the image size is reduced at each image scale.</param>
            <param name="minNeighbors">Parameter specifying how many neighbors each candidate rectangle should have to retain it.</param>
            <param name="flags">Parameter with the same meaning for an old cascade as in the function cvHaarDetectObjects. 
            It is not used for a new cascade.</param>
            <param name="minSize">Minimum possible object size. Objects smaller than that are ignored.</param>
            <param name="maxSize">Maximum possible object size. Objects larger than that are ignored.</param>
            <param name="outputRejectLevels"></param>
            <returns>Vector of rectangles where each rectangle contains the detected object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.IsOldFormatCascade">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.GetOriginalWindowSize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.CascadeClassifier.GetFeatureType">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.SimilarRects">
            <summary>
            Class for grouping object candidates, detected by Cascade Classifier, HOG etc.
            instance of the class is to be passed to cv::partition (see cxoperations.hpp)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SimilarRects.Compare(System.Double,OpenCv30Sharp.Rect,OpenCv30Sharp.Rect)">
            <summary>
            
            </summary>
            <param name="eps"></param>
            <param name="r1"></param>
            <param name="r2"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.LatentSvmDetector">
            <summary>
            Find rectangular regions in the given image that are likely
            to contain objects and corresponding confidence levels
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.LatentSvmDetector.ObjectDetection">
            <summary>
            Structure contains the detection information.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.ObjectDetection.#ctor(System.Nullable{OpenCv30Sharp.Rect},System.Single,System.Int32)">
            <summary>
            
            </summary>
            <param name="rect"></param>
            <param name="score"></param>
            <param name="classId"></param>
        </member>
        <member name="P:OpenCv30Sharp.LatentSvmDetector.ObjectDetection.Rect">
            <summary>
            bounding box for a detected object
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LatentSvmDetector.ObjectDetection.Score">
            <summary>
            confidence level
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.LatentSvmDetector.ObjectDetection.ClassId">
            <summary>
            class (model or detector) ID that detect an object
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.LatentSvmDetector.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates the HOG descriptor and detector.
            </summary>
            <param name="fileNames">A set of filenames storing the trained detectors (models). Each file contains one model. 
            See examples of such files here /opencv_extra/testdata/cv/latentsvmdetector/models_VOC2007/.</param>
            <param name="classNames">A set of trained models names. If it’s empty then the name of each model will be 
            constructed from the name of file containing the model. E.g. the model stored in "/home/user/cat.xml" will get the name "cat".</param>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.Clear">
            <summary>
            Clear all trained models and their names stored in an class object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.Empty">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.Load(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            
            </summary>
            <param name="fileNames">A set of filenames storing the trained detectors (models). Each file contains one model. 
            See examples of such files here /opencv_extra/testdata/cv/latentsvmdetector/models_VOC2007/.</param>
            <param name="classNames">A set of trained models names. If it’s empty then the name of each model will be 
            constructed from the name of file containing the model. E.g. the model stored in "/home/user/cat.xml" will get the name "cat".</param>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.Detect(OpenCv30Sharp.Mat,System.Single,System.Int32)">
            <summary>
            Find rectangular regions in the given image that are likely to contain objects of 
            loaded classes (models) and corresponding confidence levels.
            </summary>
            <param name="image">An image.</param>
            <param name="overlapThreshold">Threshold for the non-maximum suppression algorithm.</param>
            <param name="numThreads">Number of threads used in parallel version of the algorithm.</param>
            <returns>The detections: rectangulars, scores and class IDs.</returns>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.GetClassNames">
            <summary>
            Return the class (model) names that were passed in constructor or method load or extracted from models filenames in those methods.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.LatentSvmDetector.GetClassCount">
            <summary>
            Return a count of loaded models (classes).
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.FrameSource">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FrameSource.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FrameSource.CreateEmptySource">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FrameSource.CreateVideoSource(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FrameSource.CreateVideoSourceCuda(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FrameSource.CreateCameraSource(System.Int32)">
            <summary>
            
            </summary>
            <param name="deviceId"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.FrameSource.NextFrame(OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:OpenCv30Sharp.FrameSource.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DenseOpticalFlowExt">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreateFarneback">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreateFarneback_CUDA">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreateFarneback_OCL">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreateSimple">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreateDualTVL1">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreateDualTVL1_CUDA">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreateDualTVL1_OCL">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreateBrox_CUDA">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreatePyrLK_CUDA">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CreatePyrLK_OCL">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.CollectGarbage">
            <summary>
            Clear all inner buffers.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExt.Calc(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="frame0"></param>
            <param name="frame1"></param>
            <param name="flow1"></param>
            <param name="flow2"></param>
        </member>
        <member name="T:OpenCv30Sharp.SuperResolution">
            <summary>
            Base class for Super Resolution algorithms.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SuperResolution.frameSource">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SuperResolution.firstCall">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.CreateBTVL1">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.CreateBTVL1_CUDA">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.CreateBTVL1_OCL">
            <summary>
            Create Bilateral TV-L1 Super Resolution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.SetInput(OpenCv30Sharp.FrameSource)">
            <summary>
            Set input frame source for Super Resolution algorithm.
            </summary>
            <param name="fs">Input frame source</param>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.NextFrame(OpenCv30Sharp.OutputArray)">
            <summary>
            Process next frame from input and return output result.
            </summary>
            <param name="frame">Output result</param>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.CollectGarbage">
            <summary>
            Clear all inner buffers.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.InitImpl(OpenCv30Sharp.FrameSource)">
            <summary>
            
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolution.ProcessImpl(OpenCv30Sharp.FrameSource,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="output"></param>
        </member>
        <member name="T:OpenCv30Sharp.DenseOpticalFlowExtImpl">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DenseOpticalFlowExtImpl.detectorPtr">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExtImpl.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExtImpl.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExtImpl.FromRawPtr(System.IntPtr)">
            <summary>
            Creates instance from raw pointer T*
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExtImpl.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExtImpl.Calc(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="frame0"></param>
            <param name="frame1"></param>
            <param name="flow1"></param>
            <param name="flow2"></param>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowExtImpl.CollectGarbage">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.SuperResolutionImpl">
            <summary>
            class for defined Super Resolution algorithm.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SuperResolutionImpl.detectorPtr">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.FromRawPtr(System.IntPtr)">
            <summary>
            Creates instance from raw pointer T*
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.SetInput(OpenCv30Sharp.FrameSource)">
            <summary>
            
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.NextFrame(OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.CollectGarbage">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.InitImpl(OpenCv30Sharp.FrameSource)">
            <summary>
            
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:OpenCv30Sharp.SuperResolutionImpl.ProcessImpl(OpenCv30Sharp.FrameSource,OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="fs"></param>
            <param name="output"></param>
        </member>
        <member name="T:OpenCv30Sharp.FrameSourceImpl">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FrameSourceImpl.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FrameSourceImpl.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.FrameSourceImpl.FromRawPtr(System.IntPtr)">
            <summary>
            Creates instance from raw pointer T*
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.FrameSourceImpl.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.FrameSourceImpl.NextFrame(OpenCv30Sharp.OutputArray)">
            <summary>
            
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:OpenCv30Sharp.FrameSourceImpl.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.BackgroundSubtractorMOG2">
            <summary>
            The Base Class for Background/Foreground Segmentation.
            The class is only used to define the common interface for
            the whole family of background/foreground segmentation algorithms.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BackgroundSubtractorMOG2.objectPtr">
            <summary>
            cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.BackgroundSubtractorMOG2.disposed">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractorMOG2.Create(System.Int32,System.Double,System.Boolean)">
            <summary>
            
            </summary>
            <param name="history"></param>
            <param name="varThreshold"></param>
            <param name="detectShadows"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractorMOG2.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.History">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.NMixtures">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.BackgroundRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.VarThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.VarThresholdGen">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.VarInit">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.VarMin">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.VarMax">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.ComplexityReductionThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.DetectShadows">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.ShadowValue">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.BackgroundSubtractorMOG2.ShadowThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.DenseOpticalFlow">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlow.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlow.CreateOptFlow_DualTVL1">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlow.CollectGarbage">
            <summary>
            Clear all inner buffers.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlow.Calc(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray)">
            <summary>
            
            </summary>
            <param name="frame0"></param>
            <param name="frame1"></param>
            <param name="flow"></param>
        </member>
        <member name="T:OpenCv30Sharp.DenseOpticalFlowImpl">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DenseOpticalFlowImpl.detectorPtr">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowImpl.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowImpl.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowImpl.FromRawPtr(System.IntPtr)">
            <summary>
            Creates instance from raw pointer T*
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowImpl.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowImpl.Calc(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputOutputArray)">
            <summary>
            
            </summary>
            <param name="frame0"></param>
            <param name="frame1"></param>
            <param name="flow"></param>
        </member>
        <member name="M:OpenCv30Sharp.DenseOpticalFlowImpl.CollectGarbage">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.KalmanFilter">
            <summary>
            Kalman filter.
            The class implements standard Kalman filter \url{http://en.wikipedia.org/wiki/Kalman_filter}.
            However, you can modify KalmanFilter::transitionMatrix, KalmanFilter::controlMatrix and
            KalmanFilter::measurementMatrix to get the extended Kalman filter functionality.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.KalmanFilter.#ctor">
            <summary>
            the default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.KalmanFilter.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            the full constructor taking the dimensionality of the state, of the measurement and of the control vector
            </summary>
            <param name="dynamParams"></param>
            <param name="measureParams"></param>
            <param name="controlParams"></param>
            <param name="type"></param>
        </member>
        <member name="M:OpenCv30Sharp.KalmanFilter.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.StatePre">
            <summary>
            predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.StatePost">
            <summary>
            corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.TransitionMatrix">
            <summary>
            state transition matrix (A)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.ControlMatrix">
            <summary>
            control matrix (B) (not used if there is no control)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.MeasurementMatrix">
            <summary>
            measurement matrix (H)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.ProcessNoiseCov">
            <summary>
            process noise covariance matrix (Q)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.MeasurementNoiseCov">
            <summary>
            measurement noise covariance matrix (R)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.ErrorCovPre">
            <summary>
            priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*/
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.Gain">
            <summary>
            Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.KalmanFilter.ErrorCovPost">
            <summary>
            posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.KalmanFilter.Init(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            re-initializes Kalman filter. The previous content is destroyed.
            </summary>
            <param name="dynamParams"></param>
            <param name="measureParams"></param>
            <param name="controlParams"></param>
            <param name="type"></param>
        </member>
        <member name="M:OpenCv30Sharp.KalmanFilter.Predict(OpenCv30Sharp.Mat)">
            <summary>
            computes predicted state
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.KalmanFilter.Correct(OpenCv30Sharp.Mat)">
            <summary>
            updates the predicted state from the measurement
            </summary>
            <param name="measurement"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.OpenCVException">
            <summary>
            The default exception to be thrown by OpenCV 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.OpenCVException.Status">
            <summary>
            The numeric code for error status
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.OpenCVException.FuncName">
            <summary>
            The source file name where error is encountered
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.OpenCVException.ErrMsg">
            <summary>
            A description of the error
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.OpenCVException.FileName">
            <summary>
            The source file name where error is encountered
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.OpenCVException.Line">
            <summary>
            The line number in the souce where error is encountered
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OpenCVException.#ctor(OpenCv30Sharp.ErrorCode,System.String,System.String,System.String,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
        </member>
        <member name="T:OpenCv30Sharp.OpenCvSharpException">
            <summary>
            The exception that is thrown by OpenCvSharp. 
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OpenCvSharpException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OpenCvSharpException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:OpenCv30Sharp.OpenCvSharpException.#ctor(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="messageFormat"></param>
            <param name="args"></param>
        </member>
        <member name="M:OpenCv30Sharp.OpenCvSharpException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:OpenCv30Sharp.StereoBM">
            <summary>
            Semi-Global Stereo Matching
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.StereoBM.#ctor(System.IntPtr)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.StereoBM.Create(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="numDisparities"></param>
            <param name="blockSize"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.StereoBM.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.StereoBM.PreFilterType">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoBM.PreFilterSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoBM.PreFilterCap">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoBM.TextureThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoBM.UniquenessRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoBM.SmallerBlockSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoBM.ROI1">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoBM.ROI2">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.MatIndexer`1">
            <summary>
            Abstract definition of Mat indexer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OpenCv30Sharp.MatIndexer`1.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatIndexer`1.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatIndexer`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatIndexer`1.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="F:OpenCv30Sharp.MatIndexer`1.parent">
            <summary>
            Parent matrix object
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatIndexer`1.steps">
            <summary>
            Step byte length for each dimension
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatIndexer`1.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Constructor
            </summary>
            <param name="parent"></param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfDouble">
            <summary>
            A matrix whose element is 64FC1 (cv::Mat_&lt;double&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(OpenCv30Sharp.Size,System.Double)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(OpenCv30Sharp.MatOfDouble,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(OpenCv30Sharp.MatOfDouble,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(OpenCv30Sharp.MatOfDouble,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Int32,System.Int32,System.Double[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Int32,System.Int32,System.Double[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Double[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Double)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfDouble.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDouble.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDouble.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDouble.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDouble.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.FromArray(System.Double[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.FromArray(System.Double[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.FromArray(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble.Add(System.Double)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfFloat6">
            <summary>
            A matrix whose element is 32FC6 (cv::Mat_&lt;cv::Vec6f&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec6f)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Vec6f)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(OpenCv30Sharp.MatOfFloat6,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(OpenCv30Sharp.MatOfFloat6,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(OpenCv30Sharp.MatOfFloat6,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec6f[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec6f[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec6f[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec6f)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfFloat6.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat6.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat6.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat6.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat6.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.FromArray(OpenCv30Sharp.Vec6f[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.FromArray(OpenCv30Sharp.Vec6f[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec6f})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.ToPrimitiveArray">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat6.Add(OpenCv30Sharp.Vec6f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfFloat4">
            <summary>
            A matrix whose element is 32FC4 (cv::Mat_&lt;cv::Vec4f&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec4f)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Vec4f)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(OpenCv30Sharp.MatOfFloat4,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(OpenCv30Sharp.MatOfFloat4,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(OpenCv30Sharp.MatOfFloat4,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec4f[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec4f[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec4f[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec4f)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfFloat4.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat4.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat4.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat4.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat4.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.FromArray(OpenCv30Sharp.Vec4f[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.FromArray(OpenCv30Sharp.Vec4f[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec4f})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.ToPrimitiveArray">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat4.Add(OpenCv30Sharp.Vec4f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfDMatch">
            <summary>
            A matrix whose element is cv::DMatch (cv::Mat_&lt;cv::Vec4f&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(System.Int32,System.Int32,OpenCv30Sharp.DMatch)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.DMatch)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(OpenCv30Sharp.MatOfDMatch,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(OpenCv30Sharp.MatOfDMatch,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(OpenCv30Sharp.MatOfDMatch,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.DMatch)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfDMatch.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDMatch.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDMatch.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDMatch.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDMatch.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.FromArray(OpenCv30Sharp.DMatch[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.FromArray(OpenCv30Sharp.DMatch[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.DMatch})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDMatch.Add(OpenCv30Sharp.DMatch)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfDouble3">
            <summary>
            A matrix whose element is cv::Vec3d [CV_64FC3] (cv::Mat_&lt;cv::Vec3d&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec3d)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Vec3d)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(OpenCv30Sharp.MatOfDouble3,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(OpenCv30Sharp.MatOfDouble3,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(OpenCv30Sharp.MatOfDouble3,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec3d[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec3d[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec3d[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec3d)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfDouble3.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDouble3.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDouble3.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDouble3.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfDouble3.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.FromArray(OpenCv30Sharp.Vec3d[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.FromArray(OpenCv30Sharp.Vec3d[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec3d})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.ToPrimitiveArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfDouble3.Add(OpenCv30Sharp.Vec3d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint2d">
            <summary>
            A matrix whose element is cv::Point [CV_64FC2] (cv::Mat_&lt;cv::Point2d&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point2d)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Point2d)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(OpenCv30Sharp.MatOfPoint2d,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(OpenCv30Sharp.MatOfPoint2d,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(OpenCv30Sharp.MatOfPoint2d,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point2d[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point2d[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point2d[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point2d)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint2d.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint2d.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint2d.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint2d.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint2d.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.FromArray(OpenCv30Sharp.Point2d[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.FromArray(OpenCv30Sharp.Point2d[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2d})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.ToPrimitiveArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2d.Add(OpenCv30Sharp.Point2d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint2f">
            <summary>
            A matrix whose element is cv::Point [CV_32FC2] (cv::Mat_&lt;cv::Point2f&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point2f)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Point2f)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(OpenCv30Sharp.MatOfPoint2f,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(OpenCv30Sharp.MatOfPoint2f,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(OpenCv30Sharp.MatOfPoint2f,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point2f[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point2f[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point2f[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point2f)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint2f.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint2f.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint2f.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint2f.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint2f.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.FromArray(OpenCv30Sharp.Point2f[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.FromArray(OpenCv30Sharp.Point2f[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.ToPrimitiveArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint2f.Add(OpenCv30Sharp.Point2f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfUShort">
            <summary>
            A matrix whose element is 16UC1 (cv::Mat_&lt;ushort&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Int32,System.Int32,System.UInt16)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(OpenCv30Sharp.Size,System.UInt16)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(OpenCv30Sharp.MatOfUShort,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(OpenCv30Sharp.MatOfUShort,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(OpenCv30Sharp.MatOfUShort,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Int32,System.Int32,System.UInt16[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Int32,System.Int32,System.UInt16[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.UInt16[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.UInt16)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfUShort.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfUShort.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfUShort.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfUShort.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfUShort.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.FromArray(System.UInt16[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.FromArray(System.UInt16[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.FromArray(System.Collections.Generic.IEnumerable{System.UInt16})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfUShort.Add(System.UInt16)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfShort">
            <summary>
            A matrix whose element is 16SC1 (cv::Mat_&lt;short&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Int32,System.Int32,System.Int16)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(OpenCv30Sharp.Size,System.Int16)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(OpenCv30Sharp.MatOfShort,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(OpenCv30Sharp.MatOfShort,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(OpenCv30Sharp.MatOfShort,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Int32,System.Int32,System.Int16[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Int32,System.Int32,System.Int16[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Int16[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Int16)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfShort.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfShort.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfShort.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfShort.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfShort.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.FromArray(System.Int16[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.FromArray(System.Int16[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.FromArray(System.Collections.Generic.IEnumerable{System.Int16})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfShort.Add(System.Int16)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfInt">
            <summary>
            A matrix whose element is 32SC1 (cv::Mat_&lt;int&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(OpenCv30Sharp.Size,System.Int32)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(OpenCv30Sharp.MatOfInt,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(OpenCv30Sharp.MatOfInt,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(OpenCv30Sharp.MatOfInt,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Int32,System.Int32,System.Int32[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Int32,System.Int32,System.Int32[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Int32[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfInt.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfInt.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfInt.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfInt.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfInt.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.FromArray(System.Int32[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.FromArray(System.Int32[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.FromArray(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfInt.Add(System.Int32)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfFloat">
            <summary>
            A matrix whose element is 32FC1 (cv::Mat_&lt;float&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(OpenCv30Sharp.Size,System.Single)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(OpenCv30Sharp.MatOfFloat,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(OpenCv30Sharp.MatOfFloat,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(OpenCv30Sharp.MatOfFloat,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Int32,System.Int32,System.Single[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Int32,System.Int32,System.Single[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Single[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Single)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfFloat.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfFloat.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.FromArray(System.Single[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.FromArray(System.Single[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.FromArray(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfFloat.Add(System.Single)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint">
            <summary>
            A matrix whose element is cv::Point [CV_32SC2] (cv::Mat_&lt;cv::Point&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Point)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(OpenCv30Sharp.MatOfPoint,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(OpenCv30Sharp.MatOfPoint,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(OpenCv30Sharp.MatOfPoint,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint.Indexer">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.FromArray(OpenCv30Sharp.Point[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.FromArray(OpenCv30Sharp.Point[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.ToPrimitiveArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint.Add(OpenCv30Sharp.Point)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatRowColExprIndexer">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatRowColExprIndexer.parent">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColExprIndexer.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.MatRowColExprIndexer.Item(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row/column.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatRowColExprIndexer.Item(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatRowColExprIndexer.Item(OpenCv30Sharp.Range)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColExprIndexer.Get(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row/column.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColExprIndexer.Get(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColExprIndexer.Get(OpenCv30Sharp.Range)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColExprIndexer.Set(System.Int32,OpenCv30Sharp.MatExpr)">
            <summary>
            Sets a matrix header for the specified matrix row/column.
            </summary>
            <param name="pos"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColExprIndexer.Set(System.Int32,System.Int32,OpenCv30Sharp.MatExpr)">
            <summary>
            Sets a matrix header for the specified matrix row/column span.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColExprIndexer.Set(OpenCv30Sharp.Range,OpenCv30Sharp.MatExpr)">
            <summary>
            Sets a matrix header for the specified matrix row/column span.
            </summary>
            <param name="range"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.MatExprRangeIndexer">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatExprRangeIndexer.parent">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatExprRangeIndexer.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.MatExprRangeIndexer.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row/column.
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colStart"></param>
            <param name="colEnd"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatExprRangeIndexer.Item(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="rowRange"></param>
            <param name="colRange"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatExprRangeIndexer.Item(OpenCv30Sharp.Rect)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatExprRangeIndexer.Item(OpenCv30Sharp.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExprRangeIndexer.Get(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row/column.
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colStart"></param>
            <param name="colEnd"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExprRangeIndexer.Get(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="rowRange"></param>
            <param name="colRange"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExprRangeIndexer.Get(OpenCv30Sharp.Rect)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="roi"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExprRangeIndexer.Set(System.Int32,System.Int32,System.Int32,System.Int32,OpenCv30Sharp.MatExpr)">
            <summary>
            Sets a matrix header for the specified matrix row/column.
            </summary>
            <param name="rowStart"></param>
            <param name="rowEnd"></param>
            <param name="colEnd"></param>
            <param name="colStart"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExprRangeIndexer.Set(OpenCv30Sharp.Range,OpenCv30Sharp.Range,OpenCv30Sharp.MatExpr)">
            <summary>
            Sets a matrix header for the specified matrix row/column span.
            </summary>
            <param name="rowRange"></param>
            <param name="colRange"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExprRangeIndexer.Set(OpenCv30Sharp.Rect,OpenCv30Sharp.MatExpr)">
            <summary>
            Sets a matrix header for the specified matrix row/column span.
            </summary>
            <param name="roi"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Mat`2">
            <summary>
            Type-specific abstract matrix 
            </summary>
            <typeparam name="TElem">Element Type</typeparam>
            <typeparam name="TInherit">For return value type of re-defined Mat methods</typeparam>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.MatType)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType.CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType,OpenCv30Sharp.Scalar)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.MatType,OpenCv30Sharp.Scalar)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(OpenCv30Sharp.Mat{`0,`1},OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(OpenCv30Sharp.Mat{`0,`1},OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(OpenCv30Sharp.Mat{`0,`1},OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(System.Int32,System.Int32,OpenCv30Sharp.MatType,System.Array,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.MatType,System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.MatType,System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.MatType)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.MatType,OpenCv30Sharp.Scalar)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="type">Array type. Use MatType.CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, 
            or MatType. CV_8UC(n), ..., CV_64FC(n) to create multi-channel matrices.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.GetIndexer">
            <summary>
            Gets type-specific indexer for accessing each element
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.GetEnumerator">
            <summary>
            Gets read-only enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            For non-generic IEnumerable
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.Wrap(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.Clone">
            <summary>
            Creates a full copy of the matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.Reshape(System.Int32)">
            <summary>
            Changes the shape of channels of a 2D matrix without copying the data.
            </summary>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.Reshape(System.Int32[])">
            <summary>
            Changes the shape of a 2D matrix without copying the data.
            </summary>
            <param name="newDims">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.T">
            <summary>
            Transposes a matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.SubMat(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart">Start row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="rowEnd">End row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colStart">Start column of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colEnd">End column of the extracted submatrix. The upper boundary is not included.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.SubMat(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included. 
            To select all the rows, use Range.All().</param>
            <param name="colRange">Start and end column of the extracted submatrix. 
            The upper boundary is not included. To select all the columns, use Range.All().</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.SubMat(OpenCv30Sharp.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.SubMat(OpenCv30Sharp.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat`2.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowStart">Start row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="rowEnd">End row of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colStart">Start column of the extracted submatrix. The upper boundary is not included.</param>
            <param name="colEnd">End column of the extracted submatrix. The upper boundary is not included.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat`2.Item(OpenCv30Sharp.Range,OpenCv30Sharp.Range)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="rowRange">Start and end row of the extracted submatrix. The upper boundary is not included. 
            To select all the rows, use Range.All().</param>
            <param name="colRange">Start and end column of the extracted submatrix. 
            The upper boundary is not included. To select all the columns, use Range.All().</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat`2.Item(OpenCv30Sharp.Rect)">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="roi">Extracted submatrix specified as a rectangle.</param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat`2.Item(OpenCv30Sharp.Range[])">
            <summary>
            Extracts a rectangular submatrix.
            </summary>
            <param name="ranges">Array of selected ranges along each array dimension.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.Add(`0)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the ICollection&lt;T&gt;.
            </summary>
            <param name="item">The object to remove from the ICollection&lt;T&gt;.</param>
            <returns> true if item was successfully removed from the ICollection&lt;T&gt; otherwise, false. 
            This method also returns false if item is not found in the original ICollection&lt;T&gt;. </returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.Contains(`0)">
            <summary>
            Determines whether the ICollection&lt;T&gt; contains a specific value.
            </summary>
            <param name="item">The object to locate in the ICollection&lt;T&gt;.</param>
            <returns> true if item is found in the ICollection&lt;T&gt; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the list.
            </summary>
            <param name="item">The object to locate in the list. </param>
            <returns>The index of value if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.Clear">
            <summary>
            Removes all items from the ICollection&lt;T&gt;.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Mat`2.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the ICollection&lt;T&gt; to an Array, starting at a particular Array index.
            </summary>
            <param name="array">The one-dimensional Array that is the destination of the elements copied from ICollection&lt;T&gt;. 
            The Array must have zero-based indexing. </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        </member>
        <member name="P:OpenCv30Sharp.Mat`2.Count">
            <summary>
            Returns the total number of matrix elements (Mat.total)
            </summary>
            <returns>Total number of list(Mat) elements</returns>
        </member>
        <member name="P:OpenCv30Sharp.Mat`2.IsReadOnly">
            <summary>
            Gets a value indicating whether the IList is read-only.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.MatOfRect">
            <summary>
            A matrix whose element is cv::Rect [CV_32SC4] (cv::Mat_&lt;cv::Rect&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Rect)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Rect)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(OpenCv30Sharp.MatOfRect,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(OpenCv30Sharp.MatOfRect,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(OpenCv30Sharp.MatOfRect,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Rect[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Rect[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Rect[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Rect)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfRect.Indexer">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfRect.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfRect.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfRect.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfRect.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.FromArray(OpenCv30Sharp.Rect[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.FromArray(OpenCv30Sharp.Rect[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Rect})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.ToPrimitiveArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfRect.Add(OpenCv30Sharp.Rect)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint3i">
            <summary>
            A matrix whose element is cv::Point3i [CV_32SC3] (cv::Mat_&lt;cv::Point3i&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point3i)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Point3i)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(OpenCv30Sharp.MatOfPoint3i,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(OpenCv30Sharp.MatOfPoint3i,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(OpenCv30Sharp.MatOfPoint3i,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point3i[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point3i[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point3i[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point3i)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint3i.Indexer">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3i.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3i.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3i.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3i.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.FromArray(OpenCv30Sharp.Point3i[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.FromArray(OpenCv30Sharp.Point3i[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3i})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.ToPrimitiveArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3i.Add(OpenCv30Sharp.Point3i)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint3f">
            <summary>
            A matrix whose element is cv::Point3f [CV_32FC3] (cv::Mat_&lt;cv::Point3f&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point3f)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Point3f)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(OpenCv30Sharp.MatOfPoint3f,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(OpenCv30Sharp.MatOfPoint3f,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(OpenCv30Sharp.MatOfPoint3f,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point3f[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point3f[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point3f[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point3f)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint3f.Indexer">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3f.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3f.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3f.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3f.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.FromArray(OpenCv30Sharp.Point3f[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.FromArray(OpenCv30Sharp.Point3f[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.ToPrimitiveArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3f.Add(OpenCv30Sharp.Point3f)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint3d">
            <summary>
            A matrix whose element is cv::Point3d [CV_64FC3] (cv::Mat_&lt;cv::Point3d&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point3d)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Point3d)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(OpenCv30Sharp.MatOfPoint3d,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(OpenCv30Sharp.MatOfPoint3d,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(OpenCv30Sharp.MatOfPoint3d,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point3d[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Point3d[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point3d[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point3d)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfPoint3d.Indexer">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3d.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3d.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3d.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfPoint3d.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.FromArray(OpenCv30Sharp.Point3d[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.FromArray(OpenCv30Sharp.Point3d[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3d})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.ToPrimitiveArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfPoint3d.Add(OpenCv30Sharp.Point3d)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.Ptr`1">
            <summary>
            Template class for smart reference-counting pointers
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:OpenCv30Sharp.Ptr`1.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Ptr`1.#ctor(System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.Ptr`1.Dispose(System.Boolean)">
            <summary>
            Release function
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:OpenCv30Sharp.Ptr`1.Get">
            <summary>
            Returns Ptr&lt;T&gt;.get() pointer
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.RNG">
            <summary>
            Random Number Generator.
            The class implements RNG using Multiply-with-Carry algorithm.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.RNG.State">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.RNG.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.RNG.#ctor(System.UInt64)">
            <summary>
            
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:OpenCv30Sharp.RNG.op_Explicit(OpenCv30Sharp.RNG)~System.Byte">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.op_Explicit(OpenCv30Sharp.RNG)~System.SByte">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.op_Explicit(OpenCv30Sharp.RNG)~System.UInt16">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.op_Explicit(OpenCv30Sharp.RNG)~System.Int16">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.op_Explicit(OpenCv30Sharp.RNG)~System.UInt32">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.op_Explicit(OpenCv30Sharp.RNG)~System.Int32">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.op_Explicit(OpenCv30Sharp.RNG)~System.Single">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.op_Explicit(OpenCv30Sharp.RNG)~System.Double">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.Next">
            <summary>
            updates the state and returns the next 32-bit unsigned integer random number
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.Run(System.UInt32)">
            <summary>
            returns a random integer sampled uniformly from [0, N).
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.Run">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.Uniform(System.Int32,System.Int32)">
            <summary>
            returns uniformly distributed integer random number from [a,b) range
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.Uniform(System.Single,System.Single)">
            <summary>
            returns uniformly distributed floating-point random number from [a,b) range
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.Uniform(System.Double,System.Double)">
            <summary>
            returns uniformly distributed double-precision floating-point random number from [a,b) range
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RNG.Fill(OpenCv30Sharp.InputOutputArray,OpenCv30Sharp.DistributionType,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <param name="distType"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="saturateRange"></param>
        </member>
        <member name="M:OpenCv30Sharp.RNG.Gaussian(System.Double)">
            <summary>
            returns Gaussian random variate with mean zero.
            </summary>
            <param name="sigma"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.SVD">
            <summary>
            Singular Value Decomposition class
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SVD.#ctor">
            <summary>
            the default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SVD.#ctor(OpenCv30Sharp.InputArray,OpenCv30Sharp.SVD.Flags)">
            <summary>
            the constructor that performs SVD
            </summary>
            <param name="src"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.SVD.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:OpenCv30Sharp.SVD.U">
            <summary>
            eigenvalues of the covariation matrix
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.SVD.W">
            <summary>
            eigenvalues of the covariation matrix
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.SVD.Vt">
            <summary>
            mean value subtracted before the projection and added after the back projection
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SVD.Run(OpenCv30Sharp.InputArray,OpenCv30Sharp.SVD.Flags)">
            <summary>
            the operator that performs SVD. The previously allocated SVD::u, SVD::w are SVD::vt are released.
            </summary>
            <param name="src"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SVD.BackSubst(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            performs back substitution, so that dst is the solution or pseudo-solution of m*dst = rhs, where m is the decomposed matrix
            </summary>
            <param name="rhs"></param>
            <param name="dst"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.SVD.Compute(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.SVD.Flags)">
            <summary>
            decomposes matrix and stores the results to user-provided matrices
            </summary>
            <param name="src"></param>
            <param name="w"></param>
            <param name="u"></param>
            <param name="vt"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.SVD.Compute(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,OpenCv30Sharp.SVD.Flags)">
            <summary>
            computes singular values of a matrix
            </summary>
            <param name="src"></param>
            <param name="w"></param>
            <param name="flags"></param>
        </member>
        <member name="M:OpenCv30Sharp.SVD.BackSubst(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            performs back substitution
            </summary>
            <param name="w"></param>
            <param name="u"></param>
            <param name="vt"></param>
            <param name="rhs"></param>
            <param name="dst"></param>
        </member>
        <member name="M:OpenCv30Sharp.SVD.SolveZ(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            finds dst = arg min_{|dst|=1} |m*dst|
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="T:OpenCv30Sharp.SVD.Flags">
            <summary>
            Operation flags for SVD
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SVD.Flags.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SVD.Flags.ModifyA">
            <summary>
            enables modification of matrix src1 during the operation. It speeds up the processing. 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SVD.Flags.NoUV">
            <summary>
            indicates that only a vector of singular values `w` is to be processed, 
            while u and vt will be set to empty matrices
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.SVD.Flags.FullUV">
            <summary>
            when the matrix is not square, by default the algorithm produces u and 
            vt matrices of sufficiently large size for the further A reconstruction; 
            if, however, FULL_UV flag is specified, u and vt will be full-size square 
            orthogonal matrices.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.PCA">
            <summary>
            Principal Component Analysis
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.PCA.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.PCA.#ctor(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.PCA.Flags,System.Int32)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="mean"></param>
            <param name="flags"></param>
            <param name="maxComponents"></param>
        </member>
        <member name="M:OpenCv30Sharp.PCA.#ctor(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.PCA.Flags,System.Double)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="mean"></param>
            <param name="flags"></param>
            <param name="retainedVariance"></param>
        </member>
        <member name="M:OpenCv30Sharp.PCA.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:OpenCv30Sharp.PCA.Eigenvectors">
            <summary>
            eigenvalues of the covariation matrix
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.PCA.Eigenvalues">
            <summary>
            eigenvalues of the covariation matrix
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.PCA.Mean">
            <summary>
            mean value subtracted before the projection and added after the back projection
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.PCA.Compute(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.PCA.Flags,System.Int32)">
            <summary>
            operator that performs PCA. The previously stored data, if any, is released
            </summary>
            <param name="data"></param>
            <param name="mean"></param>
            <param name="flags"></param>
            <param name="maxComponents"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.PCA.ComputeVar(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.PCA.Flags,System.Double)">
            <summary>
            operator that performs PCA. The previously stored data, if any, is released
            </summary>
            <param name="data"></param>
            <param name="mean"></param>
            <param name="flags"></param>
            <param name="retainedVariance"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.PCA.Project(OpenCv30Sharp.InputArray)">
            <summary>
            projects vector from the original space to the principal components subspace
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.PCA.Project(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            projects vector from the original space to the principal components subspace
            </summary>
            <param name="vec"></param>
            <param name="result"></param>
        </member>
        <member name="M:OpenCv30Sharp.PCA.BackProject(OpenCv30Sharp.InputArray)">
            <summary>
            reconstructs the original vector from the projection
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.PCA.BackProject(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray)">
            <summary>
            reconstructs the original vector from the projection
            </summary>
            <param name="vec"></param>
            <param name="result"></param>
        </member>
        <member name="T:OpenCv30Sharp.PCA.Flags">
            <summary>
            Flags for PCA operations
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.PCA.Flags.DataAsRow">
            <summary>
            The vectors are stored as rows (i.e. all the components of a certain vector are stored continously)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.PCA.Flags.DataAsCol">
            <summary>
            The vectors are stored as columns (i.e. values of a certain vector component are stored continuously)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.PCA.Flags.UseAvg">
            <summary>
            Use pre-computed average vector
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.InputOutputArray">
            <summary>
            Proxy datatype for passing Mat's and vector&lt;&gt;'s as input parameters.
            Synonym for OutputArray.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.InputOutputArray.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:OpenCv30Sharp.InputOutputArray.op_Implicit(OpenCv30Sharp.Mat)~OpenCv30Sharp.InputOutputArray">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.BFMatcher">
            <summary>
            Brute-force descriptor matcher.
            For each descriptor in the first set, this matcher finds the closest descriptor in the second set by trying each one.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BFMatcher.#ctor(OpenCv30Sharp.NormTypes,System.Boolean)">
            <summary>
            
            </summary>
            <param name="normType"></param>
            <param name="crossCheck"></param>
        </member>
        <member name="M:OpenCv30Sharp.BFMatcher.#ctor(OpenCv30Sharp.Ptr{OpenCv30Sharp.BFMatcher})">
            <summary>
            Creates instance by cv::Ptr&lt;T&gt;
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BFMatcher.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer T*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BFMatcher.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.BFMatcher.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.BFMatcher.IsMaskSupported">
            <summary>
            Return true if the matcher supports mask in match methods.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.ORB">
            <summary>
            Class implementing the ORB (*oriented BRIEF*) keypoint detector and descriptor extractor
            </summary>
            <remarks>
            described in @cite RRKB11 . The algorithm uses FAST in pyramids to detect stable keypoints, 
            selects the strongest features using FAST or Harris response, finds their orientation 
            using first-order moments and computes the descriptors using BRIEF (where the coordinates 
            of random point pairs (or k-tuples) are rotated according to the measured orientation).
            </remarks>
        </member>
        <member name="M:OpenCv30Sharp.ORB.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.ORB.Create(System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,OpenCv30Sharp.ORBScore,System.Int32)">
            <summary>
            
            </summary>
            <param name="nFeatures"></param>
            <param name="scaleFactor"></param>
            <param name="nLevels"></param>
            <param name="edgeThreshold"></param>
            <param name="firstLevel"></param>
            <param name="wtaK"></param>
            <param name="scoreType"></param>
            <param name="patchSize"></param>
        </member>
        <member name="M:OpenCv30Sharp.ORB.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.ORB.MaxFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ORB.ScaleFactor">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ORB.NLevels">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ORB.EdgeThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ORB.FirstLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ORB.WTA_K">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ORB.ScoreType">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ORB.PatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.ORB.FastThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Feature2D">
            <summary>
            Abstract base class for 2D image feature detectors and descriptor extractors
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Feature2D.ptrObj">
            <summary>
            cv::Ptr&lt;Feature2D&gt;
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.Feature2D.DescriptorSize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Feature2D.DescriptorType">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Feature2D.DefaultNorm">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.Empty">
            <summary>
            Return true if detector object is empty
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.Detect(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            Detect keypoints in an image.
            </summary>
            <param name="image">The image.</param>
            <param name="mask">Mask specifying where to look for keypoints (optional). 
            Must be a char matrix with non-zero values in the region of interest.</param>
            <returns>The detected keypoints.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.Detect(OpenCv30Sharp.InputArray,OpenCv30Sharp.Mat)">
            <summary>
            Detect keypoints in an image.
            </summary>
            <param name="image">The image.</param>
            <param name="mask">Mask specifying where to look for keypoints (optional). 
            Must be a char matrix with non-zero values in the region of interest.</param>
            <returns>The detected keypoints.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.Detect(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat})">
            <summary>
            Detect keypoints in an image set.
            </summary>
            <param name="images">Image collection.</param>
            <param name="masks">Masks for image set. masks[i] is a mask for images[i].</param>
            <returns>Collection of keypoints detected in an input images. keypoints[i] is a set of keypoints detected in an images[i].</returns>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.Compute(OpenCv30Sharp.InputArray,OpenCv30Sharp.KeyPoint[]@,OpenCv30Sharp.OutputArray)">
            <summary>
            Compute the descriptors for a set of keypoints in an image.
            </summary>
            <param name="image">The image.</param>
            <param name="keypoints">The input keypoints. Keypoints for which a descriptor cannot be computed are removed.</param>
            <param name="descriptors">Copmputed descriptors. Row i is the descriptor for keypoint i.</param>param>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.Compute(OpenCv30Sharp.InputArray,OpenCv30Sharp.KeyPoint[],OpenCv30Sharp.KeyPoint[]@,OpenCv30Sharp.OutputArray)">
            <summary>
            Compute the descriptors for a set of keypoints in an image.
            </summary>
            <param name="image">The image.</param>
            <param name="inKeypoints">The input keypoints. Keypoints for which a descriptor cannot be computed are removed.</param>
            <param name="outKeypoints"></param>
            <param name="descriptors">Copmputed descriptors. Row i is the descriptor for keypoint i.</param>param>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.Compute(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},OpenCv30Sharp.KeyPoint[][]@,System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat})">
            <summary>
            Compute the descriptors for a keypoints collection detected in image collection.
            </summary>
            <param name="images">Image collection.</param>
            <param name="keypoints">Input keypoints collection. keypoints[i] is keypoints detected in images[i].
            Keypoints for which a descriptor cannot be computed are removed.</param>
            <param name="descriptors">Descriptor collection. descriptors[i] are descriptors computed for set keypoints[i].</param>
        </member>
        <member name="M:OpenCv30Sharp.Feature2D.DetectAndCompute(OpenCv30Sharp.InputArray,OpenCv30Sharp.InputArray,OpenCv30Sharp.KeyPoint[]@,OpenCv30Sharp.OutputArray,System.Boolean)">
            <summary>
            Detects keypoints and computes the descriptors
            </summary>
            <param name="image"></param>
            <param name="mask"></param>
            <param name="keypoints"></param>
            <param name="descriptors"></param>
            <param name="useProvidedKeypoints"></param>
        </member>
        <member name="T:OpenCv30Sharp.DescriptorMatcher">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DescriptorMatcher.detectorPtr">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.Create(System.String)">
            <summary>
            Create descriptor matcher by type name.
            </summary>
            <param name="descriptorMatcherType"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.FromPtr(System.IntPtr)">
            <summary>
            Creates instance from cv::Ptr&lt;T&gt; .
            ptr is disposed when the wrapper disposes. 
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.FromRawPtr(System.IntPtr)">
            <summary>
            Creates instance from raw pointer T*
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.Add(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat})">
            <summary>
            Add descriptors to train descriptor collection.
            </summary>
            <param name="descriptors">Descriptors to add. Each descriptors[i] is a descriptors set from one image.</param>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.GetTrainDescriptors">
            <summary>
            Get train descriptors collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.Clear">
            <summary>
            Clear train descriptors collection.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.Empty">
            <summary>
            Return true if there are not train descriptors in collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.IsMaskSupported">
            <summary>
            Return true if the matcher supports mask in match methods.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.Train">
            <summary>
            Train matcher (e.g. train flann index).
            In all methods to match the method train() is run every time before matching.
            Some descriptor matchers (e.g. BruteForceMatcher) have empty implementation
            of this method, other matchers really train their inner structures
            (e.g. FlannBasedMatcher trains flann::Index). So nonempty implementation
            of train() should check the class object state and do traing/retraining
            only if the state requires that (e.g. FlannBasedMatcher trains flann::Index
            if it has not trained yet or if new descriptors have been added to the train collection).
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.Match(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.Mat)">
            <summary>
            Find one best match for each query descriptor (if mask is empty).
            </summary>
            <param name="queryDescriptors"></param>
            <param name="trainDescriptors"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.KnnMatch(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Int32,OpenCv30Sharp.Mat,System.Boolean)">
            <summary>
            Find k best matches for each query descriptor (in increasing order of distances).
            compactResult is used when mask is not empty. If compactResult is false matches
            vector will have the same size as queryDescriptors rows. If compactResult is true
            matches vector will not contain matches for fully masked out query descriptors.
            </summary>
            <param name="queryDescriptors"></param>
            <param name="trainDescriptors"></param>
            <param name="k"></param>
            <param name="mask"></param>
            <param name="compactResult"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.RadiusMatch(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Single,OpenCv30Sharp.Mat,System.Boolean)">
            <summary>
            Find best matches for each query descriptor which have distance less than
            maxDistance (in increasing order of distances).
            </summary>
            <param name="queryDescriptors"></param>
            <param name="trainDescriptors"></param>
            <param name="maxDistance"></param>
            <param name="mask"></param>
            <param name="compactResult"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.Match(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat[])">
            <summary>
            Find one best match for each query descriptor (if mask is empty).
            </summary>
            <param name="queryDescriptors"></param>
            <param name="masks"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.KnnMatch(OpenCv30Sharp.Mat,System.Int32,OpenCv30Sharp.Mat[],System.Boolean)">
            <summary>
            Find k best matches for each query descriptor (in increasing order of distances).
            compactResult is used when mask is not empty. If compactResult is false matches
            vector will have the same size as queryDescriptors rows. If compactResult is true
            matches vector will not contain matches for fully masked out query descriptors.
            </summary>
            <param name="queryDescriptors"></param>
            <param name="k"></param>
            <param name="masks"></param>
            <param name="compactResult"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DescriptorMatcher.RadiusMatch(OpenCv30Sharp.Mat,System.Single,OpenCv30Sharp.Mat[],System.Boolean)">
            <summary>
            Find best matches for each query descriptor which have distance less than
            maxDistance (in increasing order of distances).
            </summary>
            <param name="queryDescriptors"></param>
            <param name="maxDistance"></param>
            <param name="masks"></param>
            <param name="compactResult"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.GFTTDetector">
            <summary>
            Good Features To Track Detector
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.GFTTDetector.Create(System.Int32,System.Double,System.Double,System.Int32,System.Boolean,System.Double)">
            <summary>
            
            </summary>
            <param name="maxCorners"></param>
            <param name="qualityLevel"></param>
            <param name="minDistance"></param>
            <param name="blockSize"></param>
            <param name="useHarrisDetector"></param>
            <param name="k"></param>
        </member>
        <member name="M:OpenCv30Sharp.GFTTDetector.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:OpenCv30Sharp.GFTTDetector.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.GFTTDetector.MaxFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.GFTTDetector.QualityLevel">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.GFTTDetector.MinDistance">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.GFTTDetector.BlockSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.GFTTDetector.HarrisDetector">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.GFTTDetector.K">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.FastFeatureDetector">
            <summary>
            Detects corners using FAST algorithm by E. Rosten
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FastFeatureDetector.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.FastFeatureDetector.Create(System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="threshold"></param>
            <param name="nonmaxSuppression"></param>
        </member>
        <member name="M:OpenCv30Sharp.FastFeatureDetector.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.FastFeatureDetector.Threshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.FastFeatureDetector.NonmaxSuppression">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.FastFeatureDetector.Type">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.BRISK">
            <summary>
            BRISK implementation
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BRISK.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BRISK.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:OpenCv30Sharp.BRISK.Create(System.Int32,System.Int32,System.Single)">
            <summary>
            
            </summary>
            <param name="thresh"></param>
            <param name="octaves"></param>
            <param name="patternScale"></param>
        </member>
        <member name="M:OpenCv30Sharp.BRISK.Create(System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Int32},System.Single,System.Single,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            custom setup
            </summary>
            <param name="radiusList"></param>
            <param name="numberList"></param>
            <param name="dMax"></param>
            <param name="dMin"></param>
            <param name="indexChange"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.BRISK.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.SimpleBlobDetector">
            <summary>
            Class for extracting blobs from an image.
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.SimpleBlobDetector.Params">
            <summary>
            SimpleBlobDetector parameters
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SimpleBlobDetector.Params.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SimpleBlobDetector.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.SimpleBlobDetector.Create(OpenCv30Sharp.SimpleBlobDetector.Params)">
            <summary>
            
            </summary>
            <param name="parameters"></param>
        </member>
        <member name="M:OpenCv30Sharp.SimpleBlobDetector.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="T:OpenCv30Sharp.VideoWriter">
            <summary>
            AVI Video File Writer
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VideoWriter.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.#ctor(System.String,System.String,System.Double,OpenCv30Sharp.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.#ctor(System.String,OpenCv30Sharp.FourCC,System.Double,OpenCv30Sharp.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.#ctor(System.String,System.Int32,System.Double,OpenCv30Sharp.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.#ctor(System.IntPtr)">
            <summary>
            Initializes from native pointer
            </summary>
            <param name="ptr">CvVideoWriter*</param>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VideoWriter.FileName">
            <summary>
            Get output video file name
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoWriter.Fps">
            <summary>
            Frames per second of the output vide
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoWriter.FrameSize">
            <summary>
            Get size of frame image
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoWriter.IsColor">
            <summary>
            Get whether output frames is color or not
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.Open(System.String,System.String,System.Double,OpenCv30Sharp.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.Open(System.String,OpenCv30Sharp.FourCC,System.Double,OpenCv30Sharp.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.Open(System.String,System.Int32,System.Double,OpenCv30Sharp.Size,System.Boolean)">
            <summary>
            Creates video writer structure. 
            </summary>
            <param name="fileName">Name of the output video file. </param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, "PIM1" is MPEG-1 codec, "MJPG" is motion-jpeg codec etc. 
            Under Win32 it is possible to pass null in order to choose compression method and additional compression parameters from dialog. </param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames. </param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only). </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.IsOpened">
            <summary>
            Returns true if video writer has been successfully initialized.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.Release">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.Write(OpenCv30Sharp.Mat)">
            <summary>
            Writes/appends one frame to video file. 
            </summary>
            <param name="image">the written frame.</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.FourCC(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Concatenates 4 chars to a fourcc code.
            This static method constructs the fourcc code of the codec to be used in 
            the constructor VideoWriter::VideoWriter or VideoWriter::open.
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <param name="c3"></param>
            <param name="c4"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoWriter.FourCC(System.String)">
            <summary>
            Concatenates 4 chars to a fourcc code.
            This static method constructs the fourcc code of the codec to be used in 
            the constructor VideoWriter::VideoWriter or VideoWriter::open.
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VideoCapture">
            <summary>
            Video capturing class 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VideoCapture.captureType">
            <summary>
            Capture type (File or Camera)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VideoCapture.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.#ctor">
            <summary>
            Initializes empty capture.
            To use this, you should call Open. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.#ctor(System.Int32)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. 
            Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394).
            </summary>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.#ctor(OpenCv30Sharp.CaptureDevice)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. 
            Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="device">Device type</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.#ctor(OpenCv30Sharp.CaptureDevice,System.Int32)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. 
            Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="device">Device type</param>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.FromCamera(System.Int32)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. 
            Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394).
            </summary>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.FromCamera(OpenCv30Sharp.CaptureDevice)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. 
            Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="device">Device type</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.FromCamera(OpenCv30Sharp.CaptureDevice,System.Int32)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. 
            Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="device">Device type</param>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.#ctor(System.String)">
            <summary>
            Allocates and initialized the CvCapture structure for reading the video stream from the specified file.
            After the allocated structure is not used any more it should be released by cvReleaseCapture function. 
            </summary>
            <param name="fileName">Name of the video file. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.FromFile(System.String)">
            <summary>
            Allocates and initialized the CvCapture structure for reading the video stream from the specified file.
            After the allocated structure is not used any more it should be released by cvReleaseCapture function. 
            </summary>
            <param name="fileName">Name of the video file. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.#ctor(System.IntPtr)">
            <summary>
            Initializes from native pointer
            </summary>
            <param name="ptr">CvCapture*</param>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.CaptureType">
            <summary>
            Gets the capture type (File or Camera) 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.PosMsec">
            <summary>
            Gets or sets film current position in milliseconds or video capture timestamp 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.PosFrames">
            <summary>
            Gets or sets 0-based index of the frame to be decoded/captured next
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.PosAviRatio">
            <summary>
            Gets or sets relative position of video file
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.FrameWidth">
            <summary>
            Gets or sets width of frames in the video stream
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.FrameHeight">
            <summary>
            Gets or sets height of frames in the video stream 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Fps">
            <summary>
            Gets or sets frame rate
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.FourCC">
            <summary>
            Gets or sets 4-character code of codec 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.FrameCount">
            <summary>
            Gets number of frames in video file 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Brightness">
            <summary>
            Gets or sets brightness of image (only for cameras) 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Contrast">
            <summary>
            Gets or sets contrast of image (only for cameras) 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Saturation">
            <summary>
            Gets or sets saturation of image (only for cameras) 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Hue">
            <summary>
            Gets or sets hue of image (only for cameras) 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Format">
            <summary>
            The format of the Mat objects returned by retrieve()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Mode">
            <summary>
            A backend-specific value indicating the current capture mode
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Gain">
            <summary>
            Gain of the image (only for cameras)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Exposure">
            <summary>
            Exposure (only for cameras)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.ConvertRgb">
            <summary>
            Boolean flags indicating whether images should be converted to RGB
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.WhiteBalanceBlueU">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Rectification">
            <summary>
            TOWRITE (note: only supported by DC1394 v 2.x backend currently)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Monocrome">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Sharpness">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.AutoExposure">
            <summary>
            exposure control done by camera,
            user can adjust refernce level using this feature
            [CV_CAP_PROP_AUTO_EXPOSURE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Gamma">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Temperature">
            <summary>
            
            [CV_CAP_PROP_TEMPERATURE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Trigger">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.TriggerDelay">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.WhiteBalanceRedV">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Zoom">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Focus">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Guid">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.IsoSpeed">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.BackLight">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Pan">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Tilt">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Roll">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Iris">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.Settings">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.OpenNI_OutputMode">
            <summary>
            
            [CV_CAP_PROP_OPENNI_OUTPUT_MODE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.OpenNI_FrameMaxDepth">
            <summary>
            in mm
            [CV_CAP_PROP_OPENNI_FRAME_MAX_DEPTH]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.OpenNI_Baseline">
            <summary>
            in mm
            [CV_CAP_PROP_OPENNI_BASELINE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.OpenNI_FocalLength">
            <summary>
            in pixels
            [CV_CAP_PROP_OPENNI_FOCAL_LENGTH]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.OpenNI_Registration">
            <summary>
            flag that synchronizes the remapping depth map to image map
            by changing depth generator's view point (if the flag is "on") or
            sets this view point to its normal one (if the flag is "off").
            [CV_CAP_PROP_OPENNI_REGISTRATION]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.OpenNI_ImageGeneratorOutputMode">
            <summary>
            
            [CV_CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.OpenNI_DepthGeneratorBaseline">
            <summary>
            
            [CV_CAP_OPENNI_DEPTH_GENERATOR_BASELINE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.OpenNI_DepthGeneratorFocalLength">
            <summary>
            
            [CV_CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.OpenNI_DepthGeneratorRegistrationON">
            <summary>
            
            [CV_CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.GStreamerQueueLength">
            <summary>
            default is 1
            [CV_CAP_GSTREAMER_QUEUE_LENGTH]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.PvAPIMulticastIP">
            <summary>
            ip for anable multicast master mode. 0 for disable multicast
            [CV_CAP_PROP_PVAPI_MULTICASTIP]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_Downsampling">
            <summary>
            Change image resolution by binning or skipping.  
            [CV_CAP_PROP_XI_DOWNSAMPLING]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_DataFormat">
            <summary>
            Output data format.
            [CV_CAP_PROP_XI_DATA_FORMAT]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_OffsetX">
            <summary>
            Horizontal offset from the origin to the area of interest (in pixels).
            [CV_CAP_PROP_XI_OFFSET_X]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_OffsetY">
            <summary>
            Vertical offset from the origin to the area of interest (in pixels).
            [CV_CAP_PROP_XI_OFFSET_Y]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_TrgSource">
            <summary>
            Defines source of trigger.
            [CV_CAP_PROP_XI_TRG_SOURCE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_TrgSoftware">
            <summary>
            Generates an internal trigger. PRM_TRG_SOURCE must be set to TRG_SOFTWARE.
            [CV_CAP_PROP_XI_TRG_SOFTWARE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_GpiSelector">
            <summary>
            Selects general purpose input
            [CV_CAP_PROP_XI_GPI_SELECTOR]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_GpiMode">
            <summary>
            Set general purpose input mode
            [CV_CAP_PROP_XI_GPI_MODE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_GpiLevel">
            <summary>
            Get general purpose level
            [CV_CAP_PROP_XI_GPI_LEVEL]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_GpoSelector">
            <summary>
            Selects general purpose output 
            [CV_CAP_PROP_XI_GPO_SELECTOR]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_GpoMode">
            <summary>
            Set general purpose output mode
            [CV_CAP_PROP_XI_GPO_MODE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_LedSelector">
            <summary>
            Selects camera signalling LED 
            [CV_CAP_PROP_XI_LED_SELECTOR]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_LedMode">
            <summary>
            Define camera signalling LED functionality
            [CV_CAP_PROP_XI_LED_MODE]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_ManualWB">
            <summary>
            Calculates White Balance(must be called during acquisition)
            [CV_CAP_PROP_XI_MANUAL_WB]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_AutoWB">
            <summary>
            Automatic white balance
            [CV_CAP_PROP_XI_AUTO_WB]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_AEAG">
            <summary>
            Automatic exposure/gain
            [CV_CAP_PROP_XI_AEAG]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_ExpPriority">
            <summary>
            Exposure priority (0.5 - exposure 50%, gain 50%).
            [CV_CAP_PROP_XI_EXP_PRIORITY]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_AEMaxLimit">
            <summary>
            Maximum limit of exposure in AEAG procedure
            [CV_CAP_PROP_XI_AE_MAX_LIMIT]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_AGMaxLimit">
            <summary>
            Maximum limit of gain in AEAG procedure
            [CV_CAP_PROP_XI_AG_MAX_LIMIT]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_AEAGLevel">
            <summary>
            default is 1
            [CV_CAP_PROP_XI_AEAG_LEVEL]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VideoCapture.XI_Timeout">
            <summary>
            default is 1
            [CV_CAP_PROP_XI_TIMEOUT]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Get(OpenCv30Sharp.CaptureProperty)">
            <summary>
            Retrieves the specified property of camera or video file. 
            </summary>
            <param name="propertyId">property identifier.</param>
            <returns>property value</returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Get(System.Int32)">
            <summary>
            Retrieves the specified property of camera or video file. 
            </summary>
            <param name="propertyId">property identifier.</param>
            <returns>property value</returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Grab">
            <summary>
            Grabs the frame from camera or file. The grabbed frame is stored internally. 
            The purpose of this function is to grab frame fast that is important for syncronization in case of reading from several cameras simultaneously. 
            The grabbed frames are not exposed because they may be stored in compressed format (as defined by camera/driver). 
            To retrieve the grabbed frame, cvRetrieveFrame should be used. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Retrieve(OpenCv30Sharp.Mat,System.Int32)">
            <summary>
            Decodes and returns the grabbed video frame.
            </summary>
            <param name="image"></param>
            <param name="channel">non-zero streamIdx is only valid for multi-head camera live streams</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Retrieve(OpenCv30Sharp.Mat,OpenCv30Sharp.CameraChannels)">
            <summary>
            Returns the pointer to the image grabbed with cvGrabFrame function. 
            The returned image should not be released or modified by user. 
            </summary>
            <param name="image"></param>
            <param name="streamIdx">non-zero streamIdx is only valid for multi-head camera live streams</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.RetrieveMat">
            <summary>
            Decodes and returns the grabbed video frame.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Read(OpenCv30Sharp.Mat)">
            <summary>
            Grabs a frame from camera or video file, decompresses and returns it. 
            This function is just a combination of cvGrabFrame and cvRetrieveFrame in one call. 
            The returned image should not be released or modified by user. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Set(OpenCv30Sharp.CaptureProperty,System.Double)">
            <summary>
            Sets the specified property of video capturing.
            </summary>
            <param name="propertyId">property identifier. </param>
            <param name="value">value of the property. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Set(System.Int32,System.Double)">
            <summary>
            Sets the specified property of video capturing.
            </summary>
            <param name="propertyId">property identifier. </param>
            <param name="value">value of the property. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Open(System.String)">
            <summary>
            Opens the specified video file
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Open(System.Int32)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. 
            Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394).
            </summary>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Open(OpenCv30Sharp.CaptureDevice)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. 
            Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="device">Device type</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Open(OpenCv30Sharp.CaptureDevice,System.Int32)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. 
            Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="device">Device type</param>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.Release">
            <summary>
            Closes video file or capturing device.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VideoCapture.IsOpened">
            <summary>
            Returns true if video capturing has been initialized already.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VideoCapture.IntBytes">
            <summary>
            For accessing each byte of Int32 value
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Moments">
            <summary>
            Raster image moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M00">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M10">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M01">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M20">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M11">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M02">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M30">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M21">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M12">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.M03">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Mu20">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Mu11">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Mu02">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Mu30">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Mu21">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Mu12">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Mu03">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Nu20">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Nu11">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Nu02">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Nu30">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Nu21">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Nu12">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Moments.Nu03">
            <summary>
            central normalized moments
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Moments.#ctor">
            <summary>
            Default constructor.
            All moment values are set to 0.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Moments.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="m00"></param>
            <param name="m10"></param>
            <param name="m01"></param>
            <param name="m20"></param>
            <param name="m11"></param>
            <param name="m02"></param>
            <param name="m30"></param>
            <param name="m21"></param>
            <param name="m12"></param>
            <param name="m03"></param>
        </member>
        <member name="M:OpenCv30Sharp.Moments.#ctor(OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (single-channel, 8-bit or floating-point 
            2D array) or an array ( 1xN or Nx1 ) of 2D points ( Point or Point2f )</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Moments.#ctor(System.Byte[0:,0:],System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (8-bit) 2D array</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Moments.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (floating-point) 2D array</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Moments.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point},System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">Array of 2D points</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Moments.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f},System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">Array of 2D points</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Moments.InitializeFromInputArray(OpenCv30Sharp.InputArray,System.Boolean)">
            <summary>
            Calculates all of the moments 
            up to the third order of a polygon or rasterized shape.
            </summary>
            <param name="array">A raster image (single-channel, 8-bit or floating-point 
            2D array) or an array ( 1xN or Nx1 ) of 2D points ( Point or Point2f )</param>
            <param name="binaryImage">If it is true, then all the non-zero image pixels are treated as 1’s</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Moments.Initialize(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="m00"></param>
            <param name="m10"></param>
            <param name="m01"></param>
            <param name="m20"></param>
            <param name="m11"></param>
            <param name="m02"></param>
            <param name="m30"></param>
            <param name="m21"></param>
            <param name="m12"></param>
            <param name="m03"></param>
        </member>
        <member name="M:OpenCv30Sharp.Moments.HuMoments">
            <summary>
            computes 7 Hu invariants from the moments
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.DMatch">
            <summary>
            Struct for matching: query descriptor index, train descriptor index, train image index and distance between descriptors.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DMatch.QueryIdx">
            <summary>
            query descriptor index
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DMatch.TrainIdx">
            <summary>
            train descriptor index
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DMatch.ImgIdx">
            <summary>
            train image index
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DMatch.Distance">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.DMatch.Empty">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DMatch.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            
            </summary>
            <param name="queryIdx"></param>
            <param name="trainIdx"></param>
            <param name="distance"></param>
        </member>
        <member name="M:OpenCv30Sharp.DMatch.#ctor(System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
            
            </summary>
            <param name="queryIdx"></param>
            <param name="trainIdx"></param>
            <param name="imgIdx"></param>
            <param name="distance"></param>
        </member>
        <member name="M:OpenCv30Sharp.DMatch.op_LessThan(OpenCv30Sharp.DMatch,OpenCv30Sharp.DMatch)">
            <summary>
            Compares by distance (less is beter)
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DMatch.op_GreaterThan(OpenCv30Sharp.DMatch,OpenCv30Sharp.DMatch)">
            <summary>
            Compares by distance (less is beter)
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DMatch.op_Explicit(OpenCv30Sharp.DMatch)~OpenCv30Sharp.Vec4f">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DMatch.op_Explicit(OpenCv30Sharp.Vec4f)~OpenCv30Sharp.DMatch">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.DMatch.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Point3d">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3d.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3d.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3d.Z">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3d.SizeOf">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.op_Implicit(OpenCv30Sharp.Point3d)~OpenCv30Sharp.Vec3d">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.op_Implicit(OpenCv30Sharp.Vec3d)~OpenCv30Sharp.Point3d">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.Equals(OpenCv30Sharp.Point3d)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.op_Equality(OpenCv30Sharp.Point3d,OpenCv30Sharp.Point3d)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.op_Inequality(OpenCv30Sharp.Point3d,OpenCv30Sharp.Point3d)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.op_UnaryPlus(OpenCv30Sharp.Point3d)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.op_UnaryNegation(OpenCv30Sharp.Point3d)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.op_Addition(OpenCv30Sharp.Point3d,OpenCv30Sharp.Point3d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.op_Subtraction(OpenCv30Sharp.Point3d,OpenCv30Sharp.Point3d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.op_Multiply(OpenCv30Sharp.Point3d,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3d.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:OpenCv30Sharp.Point3i">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3i.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3i.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3i.Z">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3i.SizeOf">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.op_Implicit(OpenCv30Sharp.Point3i)~OpenCv30Sharp.Vec3i">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.op_Implicit(OpenCv30Sharp.Vec3i)~OpenCv30Sharp.Point3i">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.Equals(OpenCv30Sharp.Point3i)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.op_Equality(OpenCv30Sharp.Point3i,OpenCv30Sharp.Point3i)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.op_Inequality(OpenCv30Sharp.Point3i,OpenCv30Sharp.Point3i)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.op_UnaryPlus(OpenCv30Sharp.Point3i)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.op_UnaryNegation(OpenCv30Sharp.Point3i)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.op_Addition(OpenCv30Sharp.Point3i,OpenCv30Sharp.Point3i)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.op_Subtraction(OpenCv30Sharp.Point3i,OpenCv30Sharp.Point3i)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.op_Multiply(OpenCv30Sharp.Point3i,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3i.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:OpenCv30Sharp.Rangef">
            <summary>
            float Range class
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rangef.Start">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rangef.End">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Rangef.#ctor(System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:OpenCv30Sharp.Rangef.op_Implicit(OpenCv30Sharp.Rangef)~OpenCv30Sharp.Range">
            <summary>
            
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Rangef.All">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Point2d">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point2d.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point2d.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point2d.SizeOf">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_Implicit(OpenCv30Sharp.Point2d)~OpenCv30Sharp.Point">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_Implicit(OpenCv30Sharp.Point)~OpenCv30Sharp.Point2d">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_Implicit(OpenCv30Sharp.Point2d)~OpenCv30Sharp.Vec2d">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_Implicit(OpenCv30Sharp.Vec2d)~OpenCv30Sharp.Point2d">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.Equals(OpenCv30Sharp.Point2d)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_Equality(OpenCv30Sharp.Point2d,OpenCv30Sharp.Point2d)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_Inequality(OpenCv30Sharp.Point2d,OpenCv30Sharp.Point2d)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_UnaryPlus(OpenCv30Sharp.Point2d)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_UnaryNegation(OpenCv30Sharp.Point2d)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_Addition(OpenCv30Sharp.Point2d,OpenCv30Sharp.Point2d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_Subtraction(OpenCv30Sharp.Point2d,OpenCv30Sharp.Point2d)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.op_Multiply(OpenCv30Sharp.Point2d,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.Distance(OpenCv30Sharp.Point2d,OpenCv30Sharp.Point2d)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.DistanceTo(OpenCv30Sharp.Point2d)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.DotProduct(OpenCv30Sharp.Point2d,OpenCv30Sharp.Point2d)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.DotProduct(OpenCv30Sharp.Point2d)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.CrossProduct(OpenCv30Sharp.Point2d,OpenCv30Sharp.Point2d)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2d.CrossProduct(OpenCv30Sharp.Point2d)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfDTreesSplit">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfDTreesSplit.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesSplit.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesSplit.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesSplit.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesSplit.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.ML.DTrees.Split})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesSplit.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfDTreesSplit.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfDTreesSplit.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesSplit.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfDTreesNode">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfDTreesNode.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesNode.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesNode.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesNode.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesNode.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.ML.DTrees.Node})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesNode.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfDTreesNode.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfDTreesNode.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDTreesNode.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfDouble">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfDouble.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDouble.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDouble.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDouble.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDouble.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfDouble.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfDouble.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDouble.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfInt32">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfInt32.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfInt32.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfInt32.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfInt32.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfInt32.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfInt32.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfInt32.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfInt32.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfInt32.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfDMatch">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfDMatch.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDMatch.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDMatch.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDMatch.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDMatch.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.DMatch})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDMatch.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfDMatch.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfDMatch.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfDMatch.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVec6d">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVec6d.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6d.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6d.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6d.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec6d})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6d.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6d.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec6d.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec6d.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6d.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6d.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has four int members (ex. CvLineSegmentPoint, CvRect)</typeparam>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVectorDouble">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVectorDouble.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorDouble.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorDouble.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorDouble.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorDouble.Size1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorDouble.Size2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorDouble.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorDouble.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVectorInt">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVectorInt.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorInt.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorInt.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorInt.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorInt.Size1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorInt.Size2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorInt.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorInt.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVectorFloat">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVectorFloat.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorFloat.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorFloat.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorFloat.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorFloat.Size1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorFloat.Size2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorFloat.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorFloat.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVectorDMatch">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVectorDMatch.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorDMatch.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorDMatch.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorDMatch.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorDMatch.Size1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorDMatch.Size2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorDMatch.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorDMatch.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVectorPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVectorPoint.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorPoint.Size1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorPoint.Size2">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorPoint.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfString">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfString.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfString.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfString.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfString.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfString.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfString.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfString.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfString.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Window">
            <summary>
            Wrapper of HighGUI window
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Window.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Window.#ctor">
            <summary>
            Creates a window with a random name
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Window.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Creates a window with a random name and a specified image
            </summary>
            <param name="image"></param>
        </member>
        <member name="M:OpenCv30Sharp.Window.#ctor(OpenCv30Sharp.WindowMode,OpenCv30Sharp.Mat)">
            <summary>
            Creates a window with a specified image and flag
            </summary>
            <param name="flags">Flags of the window. Currently the only supported flag is WindowMode.AutoSize. 
            If it is set, window size is automatically adjusted to fit the displayed image (see cvShowImage), while user can not change the window size manually. </param>
            <param name="image"></param>
        </member>
        <member name="M:OpenCv30Sharp.Window.#ctor(System.String)">
            <summary>
            Creates a window
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption. </param>
        </member>
        <member name="M:OpenCv30Sharp.Window.#ctor(System.String,OpenCv30Sharp.WindowMode)">
            <summary>
            Creates a window
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption. </param>
            <param name="flags">Flags of the window. Currently the only supported flag is WindowMode.AutoSize. 
            If it is set, window size is automatically adjusted to fit the displayed image (see cvShowImage), while user can not change the window size manually. </param>
        </member>
        <member name="M:OpenCv30Sharp.Window.#ctor(System.String,OpenCv30Sharp.Mat)">
            <summary>
            Creates a window
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption. </param>
            <param name="image">Image to be shown.</param>
        </member>
        <member name="M:OpenCv30Sharp.Window.#ctor(System.String,OpenCv30Sharp.WindowMode,OpenCv30Sharp.Mat)">
            <summary>
            Creates a window
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption. </param>
            <param name="flags">Flags of the window. Currently the only supported flag is WindowMode.AutoSize. 
            If it is set, window size is automatically adjusted to fit the displayed image (see cvShowImage), while user can not change the window size manually. </param>
            <param name="image">Image to be shown.</param>
        </member>
        <member name="M:OpenCv30Sharp.Window.DefaultName">
            <summary>
            ウィンドウ名が指定されなかったときに、適当な名前を作成して返す.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Window.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:OpenCv30Sharp.Window.Close">
            <summary>
            Destroys this window. 
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Window.DestroyAllWindows">
            <summary>
            Destroys all the opened HighGUI windows. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Window.Image">
            <summary>
            Gets or sets an image to be shown
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Window.Name">
            <summary>
            Gets window name
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Window.Handle">
            <summary>
            Gets window handle
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Window.MouseCallback">
            <summary>
            
            </summary>
        </member>
        <member name="E:OpenCv30Sharp.Window.OnMouseCallback">
            <summary>
            Event handler to be called every time mouse event occurs in the specified window. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Window.HasQt">
            <summary>
            Returns true if the library is compiled with Qt
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Window.CreateTrackbar(System.String,OpenCv30Sharp.CvTrackbarCallback2)">
            <summary>
            Creates the trackbar and attaches it to this window
            </summary>
            <param name="name">Name of created trackbar. </param>
            <param name="callback">the function to be called every time the slider changes the position. This function should be prototyped as void Foo(int);</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Window.CreateTrackbar(System.String,System.Int32,System.Int32,OpenCv30Sharp.CvTrackbarCallback2)">
            <summary>
            Creates the trackbar and attaches it to this window
            </summary>
            <param name="name">Name of created trackbar. </param>
            <param name="value">The position of the slider</param>
            <param name="max">Maximal position of the slider. Minimal position is always 0. </param>
            <param name="callback">the function to be called every time the slider changes the position. This function should be prototyped as void Foo(int);</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Window.CreateTrackbar2(System.String,System.Int32,System.Int32,OpenCv30Sharp.CvTrackbarCallback2,System.Object)">
            <summary>
            Creates the trackbar and attaches it to this window
            </summary>
            <param name="name">Name of created trackbar. </param>
            <param name="value">The position of the slider</param>
            <param name="max">Maximal position of the slider. Minimal position is always 0. </param>
            <param name="callback">the function to be called every time the slider changes the position. This function should be prototyped as void Foo(int);</param>
            <param name="userdata"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Window.DisplayOverlay(System.String,System.Int32)">
            <summary>
            Display text on the window's image as an overlay for delay milliseconds. This is not editing the image's data. The text is display on the top of the image.
            </summary>
            <param name="text">Overlay text to write on the window’s image</param>
            <param name="delayms">Delay to display the overlay text. If this function is called before the previous overlay text time out, the timer is restarted and the text updated. . If this value is zero, the text never disapers.</param>
        </member>
        <member name="M:OpenCv30Sharp.Window.DisplayStatusBar(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="text">Text to write on the window’s statusbar</param>
            <param name="delayms">Delay to display the text. If this function is called before the previous text time out, the timer is restarted and the text updated. If this value is zero, the text never disapers.</param>
        </member>
        <member name="M:OpenCv30Sharp.Window.GetProperty(OpenCv30Sharp.WindowProperty)">
            <summary>
            Get Property of the window
            </summary>
            <param name="propId">Property identifier</param>
            <returns>Value of the specified property</returns>
        </member>
        <member name="M:OpenCv30Sharp.Window.LoadWindowParameters">
            <summary>
            Load parameters of the window.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Window.Move(System.Int32,System.Int32)">
            <summary>
            Sets window position
            </summary>
            <param name="x">New x coordinate of top-left corner </param>
            <param name="y">New y coordinate of top-left corner </param>
        </member>
        <member name="M:OpenCv30Sharp.Window.Resize(System.Int32,System.Int32)">
            <summary>
            Sets window size
            </summary>
            <param name="width">New width </param>
            <param name="height">New height </param>
        </member>
        <member name="M:OpenCv30Sharp.Window.SaveWindowParameters">
            <summary>
            Save parameters of the window.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Window.SetProperty(OpenCv30Sharp.WindowProperty,System.Double)">
            <summary>
            Set Property of the window
            </summary>
            <param name="propId">Property identifier</param>
            <param name="propValue">New value of the specified property</param>
        </member>
        <member name="M:OpenCv30Sharp.Window.ShowImage(OpenCv30Sharp.Mat)">
            <summary>
            Shows the image in this window
            </summary>
            <param name="img">Image to be shown. </param>
        </member>
        <member name="M:OpenCv30Sharp.Window.WaitKey">
            <summary>
            Waits for a pressed key
            </summary>
            <returns>Key code</returns>
        </member>
        <member name="M:OpenCv30Sharp.Window.WaitKey(System.Int32)">
            <summary>
            Waits for a pressed key
            </summary>
            <param name="delay">Delay in milliseconds. </param>
            <returns>Key code</returns>
        </member>
        <member name="M:OpenCv30Sharp.Window.ShowImages(OpenCv30Sharp.Mat[])">
            <summary>
            
            </summary>
            <param name="images"></param>
        </member>
        <member name="M:OpenCv30Sharp.Window.ShowImages(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            
            </summary>
            <param name="images"></param>
            <param name="names"></param>
        </member>
        <member name="M:OpenCv30Sharp.Window.GetWindowByName(System.String)">
            <summary>
            Retrieves a created window by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Subdiv2D">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.#ctor(OpenCv30Sharp.Rect)">
            <summary>
            Subdiv2D Constructor
            </summary>
            <param name="rect"></param>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.Release">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.PTLOC_ERROR">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.PTLOC_OUTSIDE_RECT">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.PTLOC_INSIDE">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.PTLOC_VERTEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.PTLOC_ON_EDGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.NEXT_AROUND_ORG">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.NEXT_AROUND_DST">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.PREV_AROUND_ORG">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.PREV_AROUND_DST">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.NEXT_AROUND_LEFT">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.NEXT_AROUND_RIGHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.PREV_AROUND_LEFT">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Subdiv2D.PREV_AROUND_RIGHT">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.InitDelaunay(OpenCv30Sharp.Rect)">
            <summary>
            
            </summary>
            <param name="rect"></param>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.Insert(OpenCv30Sharp.Point2f)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.Insert(OpenCv30Sharp.Point2f[])">
            <summary>
            
            </summary>
            <param name="ptvec"></param>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.Insert(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f})">
            <summary>
            
            </summary>
            <param name="ptvec"></param>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.Locate(OpenCv30Sharp.Point2f,System.Int32@,System.Int32@)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <param name="edge"></param>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.FindNearest(OpenCv30Sharp.Point2f)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.FindNearest(OpenCv30Sharp.Point2f,OpenCv30Sharp.Point2f@)">
            <summary>
            
            </summary>
            <param name="pt"></param>
            <param name="nearestPt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.GetEdgeList">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.GetTriangleList">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.GetVoronoiFacetList(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Point2f[][]@,OpenCv30Sharp.Point2f[]@)">
            <summary>
            
            </summary>
            <param name="idx"></param>
            <param name="facetList"></param>
            <param name="facetCenters"></param>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.GetVertex(System.Int32)">
            <summary>
            
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.GetVertex(System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="vertex"></param>
            <param name="firstEdge"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.GetEdge(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="nextEdgeType"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.NextEdge(System.Int32)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.RotateEdge(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="rotate"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.SymEdge(System.Int32)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.EdgeOrg(System.Int32)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.EdgeOrg(System.Int32,OpenCv30Sharp.Point2f@)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="orgpt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.EdgeDst(System.Int32)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Subdiv2D.EdgeDst(System.Int32,OpenCv30Sharp.Point2f@)">
            <summary>
            
            </summary>
            <param name="edge"></param>
            <param name="dstpt"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.BackgroundSubtractor">
            <summary>
            The Base Class for Background/Foreground Segmentation.
            The class is only used to define the common interface for
            the whole family of background/foreground segmentation algorithms.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractor.Apply(OpenCv30Sharp.InputArray,OpenCv30Sharp.OutputArray,System.Double)">
            <summary>
            the update operator that takes the next video frame and returns the current foreground mask as 8-bit binary image.
            </summary>
            <param name="image"></param>
            <param name="fgmask"></param>
            <param name="learningRate"></param>
        </member>
        <member name="M:OpenCv30Sharp.BackgroundSubtractor.GetBackgroundImage(OpenCv30Sharp.OutputArray)">
            <summary>
            computes a background image
            </summary>
            <param name="backgroundImage"></param>
        </member>
        <member name="T:OpenCv30Sharp.Algorithm">
            <summary>
            Base class for high-level OpenCV algorithms
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Algorithm.Write(OpenCv30Sharp.FileStorage)">
            <summary>
            Stores algorithm parameters in a file storage
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:OpenCv30Sharp.Algorithm.Read(OpenCv30Sharp.FileNode)">
            <summary>
            Reads algorithm parameters from a file storage
            </summary>
            <param name="fn"></param>
        </member>
        <member name="P:OpenCv30Sharp.Algorithm.Empty">
            <summary>
            Returns true if the Algorithm is empty (e.g. in the very beginning or after unsuccessful read
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Algorithm.Save(System.String)">
            <summary>
            Saves the algorithm to a file.
            In order to make this method work, the derived class must 
            implement Algorithm::write(FileStorage fs).
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:OpenCv30Sharp.Algorithm.GetDefaultName">
            <summary>
            Returns the algorithm string identifier.
            This string is used as top level xml/yml node tag when the object 
            is saved to a file or string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.DumpFormat">
            <summary>
            Output string format of Mat.Dump()
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DumpFormat.Default">
            <summary>
            Default format. 
            [1, 2, 3, 4, 5, 6; \n
            7, 8, 9, ... ]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DumpFormat.Python">
            <summary>
            Python format. 
            [[[1, 2, 3], [4, 5, 6]], \n
            [[7, 8, 9], ... ]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DumpFormat.NumPy">
            <summary>
            NumPy format. 
            array([[[1, 2, 3], [4, 5, 6]], \n
            [[7, 8, 9], .... ]]], type='uint8');
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DumpFormat.Csv">
            <summary>
            CSV format. 
            1, 2, 3, 4, 5, 6\n
            7, 8, 9, ...
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.DumpFormat.C">
            <summary>
            C language format. 
            {1, 2, 3, 4, 5, 6, \n
            7, 8, 9, ...}; 
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.InOutArrayKind">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.HOGDescriptor">
            <summary>
            HOG (Histogram-of-Oriented-Gradients) Descriptor and Object Detector
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HOGDescriptor.L2Hys">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HOGDescriptor.DefaultNlevels">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HOGDescriptor.SizeOf">
            <summary>
            sizeof(HOGDescriptor) 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HOGDescriptor.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HOGDescriptor.DefaultPeopleDetector">
            <summary>
            Returns coefficients of the classifier trained for people detection (for default window size).
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HOGDescriptor.DaimlerPeopleDetector">
            <summary>
            This field returns 1981 SVM coeffs obtained from daimler's base.
            To use these coeffs the detection window size should be (48,96)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.#ctor(System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size},System.Int32,System.Int32,System.Double,OpenCv30Sharp.HistogramNormType,System.Double,System.Boolean,System.Int32)">
            <summary>
            Creates the HOG descriptor and detector.
            </summary>
            <param name="winSize">Detection window size. Align to block size and block stride.</param>
            <param name="blockSize">Block size in pixels. Align to cell size. Only (16,16) is supported for now.</param>
            <param name="blockStride">Block stride. It must be a multiple of cell size.</param>
            <param name="cellSize">Cell size. Only (8, 8) is supported for now.</param>
            <param name="nbins">Number of bins. Only 9 bins per cell are supported for now.</param>
            <param name="derivAperture"></param>
            <param name="winSigma">Gaussian smoothing window parameter.</param>
            <param name="histogramNormType"></param>
            <param name="l2HysThreshold">L2-Hys normalization method shrinkage.</param>
            <param name="gammaCorrection">Flag to specify whether the gamma correction preprocessing is required or not.</param>
            <param name="nlevels">Maximum number of detection window increases.</param>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.#ctor(System.IntPtr)">
            <summary>
            Initializes from pointer
            </summary>
            <param name="ptr">class HOGDescriptor*</param>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.WinSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.BlockSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.BlockStride">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.CellSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.Nbins">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.DerivAperture">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.WinSigma">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.HistogramNormType">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.L2HysThreshold">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.GammaCorrection">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.HOGDescriptor.NLevels">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.GetDefaultPeopleDetector">
            <summary>
            Returns coefficients of the classifier trained for people detection (for default window size).
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.GetDaimlerPeopleDetector">
            <summary>
            This method returns 1981 SVM coeffs obtained from daimler's base.
            To use these coeffs the detection window size should be (48,96)
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.SetSVMDetector(System.Single[])">
            <summary>
            
            </summary>
            <param name="svmDetector"></param>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.Load(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <param name="objName"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.Save(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <param name="objName"></param>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.GetDescriptorSize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.CheckDetectorSize">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.GetWinSigma">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.Compute(OpenCv30Sharp.Mat,System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size},OpenCv30Sharp.Point[])">
            <summary>
            
            </summary>
            <param name="img"></param>
            <param name="winStride"></param>
            <param name="padding"></param>
            <param name="locations"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.Detect(OpenCv30Sharp.Mat,System.Double,System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size},OpenCv30Sharp.Point[])">
            <summary>
            Performs object detection without a multi-scale window.
            </summary>
            <param name="img">Source image. CV_8UC1 and CV_8UC4 types are supported for now.</param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane. 
            Usually it is 0 and should be specfied in the detector coefficients (as the last free coefficient). 
            But if the free coefficient is omitted (which is allowed), you can specify it manually here.</param>
            <param name="winStride">Window stride. It must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep the CPU interface compatibility. It must be (0,0).</param>
            <param name="searchLocations"></param>
            <returns>Left-top corner points of detected objects boundaries.</returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.Detect(OpenCv30Sharp.Mat,System.Double[]@,System.Double,System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size},OpenCv30Sharp.Point[])">
            <summary>
            Performs object detection without a multi-scale window.
            </summary>
            <param name="img">Source image. CV_8UC1 and CV_8UC4 types are supported for now.</param>
            <param name="weights"></param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane. 
            Usually it is 0 and should be specfied in the detector coefficients (as the last free coefficient). 
            But if the free coefficient is omitted (which is allowed), you can specify it manually here.</param>
            <param name="winStride">Window stride. It must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep the CPU interface compatibility. It must be (0,0).</param>
            <param name="searchLocations"></param>
            <returns>Left-top corner points of detected objects boundaries.</returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.DetectMultiScale(OpenCv30Sharp.Mat,System.Double,System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size},System.Double,System.Int32)">
            <summary>
            Performs object detection with a multi-scale window.
            </summary>
            <param name="img">Source image. CV_8UC1 and CV_8UC4 types are supported for now.</param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane.</param>
            <param name="winStride">Window stride. It must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep the CPU interface compatibility. It must be (0,0).</param>
            <param name="scale">Coefficient of the detection window increase.</param>
            <param name="groupThreshold">Coefficient to regulate the similarity threshold. 
            When detected, some objects can be covered by many rectangles. 0 means not to perform grouping.</param>
            <returns>Detected objects boundaries.</returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.DetectMultiScale(OpenCv30Sharp.Mat,System.Double[]@,System.Double,System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size},System.Double,System.Int32)">
            <summary>
            Performs object detection with a multi-scale window.
            </summary>
            <param name="img">Source image. CV_8UC1 and CV_8UC4 types are supported for now.</param>
            <param name="foundWeights"></param>
            <param name="hitThreshold">Threshold for the distance between features and SVM classifying plane.</param>
            <param name="winStride">Window stride. It must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep the CPU interface compatibility. It must be (0,0).</param>
            <param name="scale">Coefficient of the detection window increase.</param>
            <param name="groupThreshold">Coefficient to regulate the similarity threshold. 
            When detected, some objects can be covered by many rectangles. 0 means not to perform grouping.</param>
            <returns>Detected objects boundaries.</returns>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.ComputeGradient(OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,OpenCv30Sharp.Mat,System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size})">
            <summary>
            
            </summary>
            <param name="img"></param>
            <param name="grad"></param>
            <param name="angleOfs"></param>
            <param name="paddingTL"></param>
            <param name="paddingBR"></param>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.DetectROI(OpenCv30Sharp.Mat,OpenCv30Sharp.Point[],OpenCv30Sharp.Point[]@,System.Double[]@,System.Double,System.Nullable{OpenCv30Sharp.Size},System.Nullable{OpenCv30Sharp.Size})">
            <summary>
            evaluate specified ROI and return confidence value for each location
            </summary>
            <param name="img"></param>
            <param name="locations"></param>
            <param name="foundLocations"></param>
            <param name="confidences"></param>
            <param name="hitThreshold"></param>
            <param name="winStride"></param>
            <param name="padding"></param>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.DetectMultiScaleROI(OpenCv30Sharp.Mat,OpenCv30Sharp.Rect[]@,OpenCv30Sharp.DetectionROI[]@,System.Double,System.Int32)">
            <summary>
            evaluate specified ROI and return confidence value for each location in multiple scales
            </summary>
            <param name="img"></param>
            <param name="foundLocations"></param>
            <param name="locations"></param>
            <param name="hitThreshold"></param>
            <param name="groupThreshold"></param>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.ReadALTModel(System.String)">
            <summary>
            read/parse Dalal's alt model file
            </summary>
            <param name="modelFile"></param>
        </member>
        <member name="M:OpenCv30Sharp.HOGDescriptor.GroupRectangles(OpenCv30Sharp.Rect[]@,System.Double[]@,System.Int32,System.Double)">
            <summary>
            
            </summary>
            <param name="rectList"></param>
            <param name="weights"></param>
            <param name="groupThreshold"></param>
            <param name="eps"></param>
        </member>
        <member name="T:OpenCv30Sharp.DetectionROI">
            <summary>
            struct for detection region of interest (ROI)
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.DetectionROI.Scale">
            <summary>
            scale(size) of the bounding box
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.DetectionROI.Locations">
            <summary>
            set of requrested locations to be evaluated
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.DetectionROI.Confidences">
            <summary>
            vector that will contain confidence values for each location
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.IVec`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OpenCv30Sharp.IVec`1.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.MatRowColIndexer">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatRowColIndexer.parent">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColIndexer.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.MatRowColIndexer.Item(System.Int32)">
            <summary>
            Creates/Sets a matrix header for the specified matrix row/column.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatRowColIndexer.Item(System.Int32,System.Int32)">
            <summary>
            Creates/Sets a matrix header for the specified row/column span.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatRowColIndexer.Item(OpenCv30Sharp.Range)">
            <summary>
            Creates/Sets a matrix header for the specified row/column span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColIndexer.Get(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row/column.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColIndexer.Get(System.Int32,System.Int32)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColIndexer.Get(OpenCv30Sharp.Range)">
            <summary>
            Creates a matrix header for the specified row/column span.
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColIndexer.Set(System.Int32,OpenCv30Sharp.Mat)">
            <summary>
            Creates/Sets a matrix header for the specified matrix row/column.
            </summary>
            <param name="pos"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColIndexer.Set(System.Int32,System.Int32,OpenCv30Sharp.Mat)">
            <summary>
            Creates/Sets a matrix header for the specified row/column span.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatRowColIndexer.Set(OpenCv30Sharp.Range,OpenCv30Sharp.Mat)">
            <summary>
            Creates/Sets a matrix header for the specified row/column span.
            </summary>
            <param name="range"></param>
            <param name="value"></param>
        </member>
        <member name="T:OpenCv30Sharp.MatType">
            <summary>
            Matrix data type (depth and number of channels)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.Value">
            <summary>
            Entity value
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatType.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatType.op_Implicit(OpenCv30Sharp.MatType)~System.Int32">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatType.op_Implicit(System.Int32)~OpenCv30Sharp.MatType">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.MatType.Depth">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatType.IsInteger">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatType.Channels">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatType.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8U">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8S">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16U">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16S">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32S">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32F">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_64F">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_USRTYPE1">
            <summary>
            type depth constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8UC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8UC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8UC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8UC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8SC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8SC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8SC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_8SC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16UC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16UC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16UC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16UC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16SC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16SC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16SC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_16SC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32SC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32SC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32SC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32SC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32FC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32FC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32FC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_32FC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_64FC1">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_64FC2">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_64FC3">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatType.CV_64FC4">
            <summary>
            predefined type constants
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Point3f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3f.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3f.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3f.Z">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point3f.SizeOf">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.op_Implicit(OpenCv30Sharp.Point3f)~OpenCv30Sharp.Vec3f">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.op_Implicit(OpenCv30Sharp.Vec3f)~OpenCv30Sharp.Point3f">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.Equals(OpenCv30Sharp.Point3f)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.op_Equality(OpenCv30Sharp.Point3f,OpenCv30Sharp.Point3f)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.op_Inequality(OpenCv30Sharp.Point3f,OpenCv30Sharp.Point3f)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.op_UnaryPlus(OpenCv30Sharp.Point3f)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.op_UnaryNegation(OpenCv30Sharp.Point3f)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.op_Addition(OpenCv30Sharp.Point3f,OpenCv30Sharp.Point3f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.op_Subtraction(OpenCv30Sharp.Point3f,OpenCv30Sharp.Point3f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.op_Multiply(OpenCv30Sharp.Point3f,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point3f.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:OpenCv30Sharp.Point2f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point2f.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point2f.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point2f.SizeOf">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.#ctor(System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_Implicit(OpenCv30Sharp.Point2f)~OpenCv30Sharp.Point">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_Implicit(OpenCv30Sharp.Point)~OpenCv30Sharp.Point2f">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_Implicit(OpenCv30Sharp.Point2f)~OpenCv30Sharp.Vec2f">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_Implicit(OpenCv30Sharp.Vec2f)~OpenCv30Sharp.Point2f">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.Equals(OpenCv30Sharp.Point2f)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_Equality(OpenCv30Sharp.Point2f,OpenCv30Sharp.Point2f)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the values of the X and Y properties of the two CvPoint objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_Inequality(OpenCv30Sharp.Point2f,OpenCv30Sharp.Point2f)">
            <summary>
            Compares two CvPoint2D32f objects. The result specifies whether the values of the X or Y properties of the two CvPoint2D32f objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_UnaryPlus(OpenCv30Sharp.Point2f)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_UnaryNegation(OpenCv30Sharp.Point2f)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_Addition(OpenCv30Sharp.Point2f,OpenCv30Sharp.Point2f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_Subtraction(OpenCv30Sharp.Point2f,OpenCv30Sharp.Point2f)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.op_Multiply(OpenCv30Sharp.Point2f,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.Distance(OpenCv30Sharp.Point2f,OpenCv30Sharp.Point2f)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.DistanceTo(OpenCv30Sharp.Point2f)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.DotProduct(OpenCv30Sharp.Point2f,OpenCv30Sharp.Point2f)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.DotProduct(OpenCv30Sharp.Point2f)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.CrossProduct(OpenCv30Sharp.Point2f,OpenCv30Sharp.Point2f)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point2f.CrossProduct(OpenCv30Sharp.Point2f)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.RotatedRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RotatedRect.Center">
            <summary>
            the rectangle mass center
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RotatedRect.Size">
            <summary>
            width and height of the rectangle
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.RotatedRect.Angle">
            <summary>
            the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.RotatedRect.#ctor(OpenCv30Sharp.Point2f,OpenCv30Sharp.Size2f,System.Single)">
            <summary>
            
            </summary>
            <param name="center"></param>
            <param name="size"></param>
            <param name="angle"></param>
        </member>
        <member name="M:OpenCv30Sharp.RotatedRect.Points">
            <summary>
            returns 4 vertices of the rectangle
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.RotatedRect.BoundingRect">
            <summary>
            returns the minimal up-right rectangle containing the rotated rectangle
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Size2f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Size2f.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Size2f.Height">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Size2f.#ctor(System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:OpenCv30Sharp.Size2f.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:OpenCv30Sharp.Size2f.Equals(OpenCv30Sharp.Size2f)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size2f.op_Equality(OpenCv30Sharp.Size2f,OpenCv30Sharp.Size2f)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size2f.op_Inequality(OpenCv30Sharp.Size2f,OpenCv30Sharp.Size2f)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size2f.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size2f.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size2f.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:OpenCv30Sharp.TermCriteria">
            <summary>
            The class defining termination criteria for iterative algorithms.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.TermCriteria.Type">
            <summary>
            the type of termination criteria: COUNT, EPS or COUNT + EPS
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.TermCriteria.MaxCount">
            <summary>
            the maximum number of iterations/elements
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.TermCriteria.Epsilon">
            <summary>
            the desired accuracy
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.TermCriteria.#ctor(OpenCv30Sharp.CriteriaType,System.Int32,System.Double)">
            <summary>
            full constructor
            </summary>
            <param name="type"></param>
            <param name="maxCount"></param>
            <param name="epsilon"></param>
        </member>
        <member name="M:OpenCv30Sharp.TermCriteria.Both(System.Int32,System.Double)">
            <summary>
            full constructor with both type (count | epsilon)
            </summary>
            <param name="maxCount"></param>
            <param name="epsilon"></param>
        </member>
        <member name="T:OpenCv30Sharp.Vec2i">
            <summary>
            2-Tuple of int (System.Int32)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2i.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2i.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec2i.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec2i.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec3i">
            <summary>
            3-Tuple of int (System.Int32)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3i.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3i.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3i.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec3i.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec3i.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec4i">
            <summary>
            4-Tuple of int (System.Int32)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4i.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4i.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4i.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4i.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec4i.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec4i.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec6i">
            <summary>
            6-Tuple of int (System.Int32)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6i.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6i.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6i.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6i.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6i.Item4">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6i.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec6i.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec6i.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.MatOfByte">
            <summary>
            A matrix whose element is 8UC1 (cv::Mat_&lt;uchar&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Int32,System.Int32,System.Byte)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(OpenCv30Sharp.Size,System.Byte)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(OpenCv30Sharp.MatOfByte,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(OpenCv30Sharp.MatOfByte,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(OpenCv30Sharp.MatOfByte,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Int32,System.Int32,System.Byte[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Int32,System.Int32,System.Byte[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Byte[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Byte)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfByte.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfByte.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfByte.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfByte.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfByte.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.GetIndexer">
            <summary>
            Gets a type-specific indexer. The indexer has getters/setters to access each matrix element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.FromArray(System.Byte[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.FromArray(System.Byte[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.FromArray(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.Add(System.Byte)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte.Add(System.SByte)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MSER">
            <summary>
            Maximal Stable Extremal Regions class
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MSER.#ctor(System.IntPtr)">
            <summary>
            Creates instance by raw pointer cv::MSER*
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MSER.Create(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Creates MSER parameters
            </summary>
            <param name="delta">delta, in the code, it compares (size_{i}-size_{i-delta})/size_{i-delta}</param>
            <param name="minArea">prune the area which smaller than min_area</param>
            <param name="maxArea">prune the area which bigger than max_area</param>
            <param name="maxVariation">prune the area have simliar size to its children</param>
            <param name="minDiversity">trace back to cut off mser with diversity &lt; min_diversity</param>
            <param name="maxEvolution">for color image, the evolution steps</param>
            <param name="areaThreshold">the area threshold to cause re-initialize</param>
            <param name="minMargin">ignore too small margin</param>
            <param name="edgeBlurSize">the aperture size for edge blur</param>
        </member>
        <member name="M:OpenCv30Sharp.MSER.Dispose(System.Boolean)">
            <summary>
            Releases the resources
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.MSER.Delta">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MSER.MinArea">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MSER.MaxArea">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MSER.Pass2Only">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MSER.DetectRegions(OpenCv30Sharp.InputArray,OpenCv30Sharp.Point[][]@,OpenCv30Sharp.Rect[]@)">
            <summary>
            
            </summary>
            <param name="image"></param>
            <param name="msers"></param>
            <param name="bboxes"></param>
        </member>
        <member name="T:OpenCv30Sharp.KeyPoint">
            <summary>
            Data structure for salient point detectors
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KeyPoint.Pt">
            <summary>
            Coordinate of the point
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KeyPoint.Size">
            <summary>
            Feature size
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KeyPoint.Angle">
            <summary>
            Feature orientation in degrees (has negative value if the orientation is not defined/not computed)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KeyPoint.Response">
            <summary>
            Feature strength (can be used to select only the most prominent key points)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KeyPoint.Octave">
            <summary>
            Scale-space octave in which the feature has been found; may correlate with the size
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.KeyPoint.ClassId">
            <summary>
            Point class (can be used by feature classifiers or object detectors)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.KeyPoint.#ctor(OpenCv30Sharp.Point2f,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Complete constructor
            </summary>
            <param name="pt">Coordinate of the point</param>
            <param name="size">Feature size</param>
            <param name="angle">Feature orientation in degrees (has negative value if the orientation is not defined/not computed)</param>
            <param name="response">Feature strength (can be used to select only the most prominent key points)</param>
            <param name="octave">Scale-space octave in which the feature has been found; may correlate with the size</param>
            <param name="classId">Point class (can be used by feature classifiers or object detectors)</param>
        </member>
        <member name="M:OpenCv30Sharp.KeyPoint.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Complete constructor
            </summary>
            <param name="x">X-coordinate of the point</param>
            <param name="y">Y-coordinate of the point</param>
            <param name="size">Feature size</param>
            <param name="angle">Feature orientation in degrees (has negative value if the orientation is not defined/not computed)</param>
            <param name="response">Feature strength (can be used to select only the most prominent key points)</param>
            <param name="octave">Scale-space octave in which the feature has been found; may correlate with the size</param>
            <param name="classId">Point class (can be used by feature classifiers or object detectors)</param>
        </member>
        <member name="M:OpenCv30Sharp.KeyPoint.Equals(OpenCv30Sharp.KeyPoint)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.KeyPoint.op_Equality(OpenCv30Sharp.KeyPoint,OpenCv30Sharp.KeyPoint)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.KeyPoint.op_Inequality(OpenCv30Sharp.KeyPoint,OpenCv30Sharp.KeyPoint)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.KeyPoint.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.KeyPoint.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.KeyPoint.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:OpenCv30Sharp.StereoSGBMMode">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.StereoSGBM">
            <summary>
            Semi-Global Stereo Matching
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.StereoSGBM.#ctor(System.IntPtr)">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.StereoSGBM.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,OpenCv30Sharp.StereoSGBMMode)">
            <summary>
            
            </summary>
            <param name="minDisparity"></param>
            <param name="numDisparities"></param>
            <param name="blockSize"></param>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="disp12MaxDiff"></param>
            <param name="preFilterCap"></param>
            <param name="uniquenessRatio"></param>
            <param name="speckleWindowSize"></param>
            <param name="speckleRange"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.StereoSGBM.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.StereoSGBM.PreFilterCap">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoSGBM.UniquenessRatio">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoSGBM.P1">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoSGBM.P2">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.StereoSGBM.Mode">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.MatDiagType">
            <summary>
            diagonal type
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatDiagType.Upper">
            <summary>
            a diagonal from the upper half
            [&lt; 0]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatDiagType.Main">
            <summary>
            Main dialonal
            [= 0]
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatDiagType.Lower">
            <summary>
            a diagonal from the lower half
            [&gt; 0]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Vec2b">
            <summary>
            2-Tuple of byte (System.Byte)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2b.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2b.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec2b.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec2b.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec3b">
            <summary>
            3-Tuple of byte (System.Byte)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3b.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3b.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3b.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec3b.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec3b.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec4b">
            <summary>
            4-Tuple of byte (System.Byte)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4b.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4b.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4b.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4b.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec4b.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec4b.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec6b">
            <summary>
            6-Tuple of byte (System.Byte)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6b.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6b.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6b.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6b.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6b.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6b.Item5">
            <summary>
            The value of the sizth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec6b.#ctor(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec6b.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Point">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Point.SizeOf">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Point.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:OpenCv30Sharp.Point.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:OpenCv30Sharp.Point.op_Implicit(OpenCv30Sharp.Point)~OpenCv30Sharp.Vec2i">
            <summary>
            
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.op_Implicit(OpenCv30Sharp.Vec2i)~OpenCv30Sharp.Point">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.Equals(OpenCv30Sharp.Point)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.op_Equality(OpenCv30Sharp.Point,OpenCv30Sharp.Point)">
            <summary>
            Compares two Point objects. The result specifies whether the values of the X and Y properties of the two Point objects are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the X and Y values of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.op_Inequality(OpenCv30Sharp.Point,OpenCv30Sharp.Point)">
            <summary>
            Compares two Point objects. The result specifies whether the values of the X or Y properties of the two Point objects are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the values of either the X properties or the Y properties of left and right differ; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.op_UnaryPlus(OpenCv30Sharp.Point)">
            <summary>
            Unary plus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.op_UnaryNegation(OpenCv30Sharp.Point)">
            <summary>
            Unary minus operator
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.op_Addition(OpenCv30Sharp.Point,OpenCv30Sharp.Point)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.op_Subtraction(OpenCv30Sharp.Point,OpenCv30Sharp.Point)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.op_Multiply(OpenCv30Sharp.Point,System.Double)">
            <summary>
            Shifts point by a certain offset
            </summary>
            <param name="pt"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.Distance(OpenCv30Sharp.Point,OpenCv30Sharp.Point)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.DistanceTo(OpenCv30Sharp.Point)">
            <summary>
            Returns the distance between the specified two points
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.DotProduct(OpenCv30Sharp.Point,OpenCv30Sharp.Point)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.DotProduct(OpenCv30Sharp.Point)">
            <summary>
            Calculates the dot product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.CrossProduct(OpenCv30Sharp.Point,OpenCv30Sharp.Point)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Point.CrossProduct(OpenCv30Sharp.Point)">
            <summary>
            Calculates the cross product of two 2D vectors.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Range">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Range.Start">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Range.End">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Range.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="P:OpenCv30Sharp.Range.All">
            <summary>
            
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Rect">
            <summary>
            Stores a set of four integers that represent the location and size of a rectangle
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rect.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rect.Y">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rect.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rect.Height">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rect.SizeOf">
            <summary>
            sizeof(Rect)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Rect.Empty">
            <summary>
            Represents a Rect structure with its properties left uninitialized. 
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Rect.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the Rectangle class with the specified location and size.
            </summary>
            <param name="x">The x-coordinate of the upper-left corner of the rectangle.</param>
            <param name="y">The y-coordinate of the upper-left corner of the rectangle.</param>
            <param name="width">The width of the rectangle.</param>
            <param name="height">The height of the rectangle.</param>
        </member>
        <member name="M:OpenCv30Sharp.Rect.#ctor(OpenCv30Sharp.Point,OpenCv30Sharp.Size)">
            <summary>
            Initializes a new instance of the Rectangle class with the specified location and size.
            </summary>
            <param name="location">A Point that represents the upper-left corner of the rectangular region.</param>
            <param name="size">A Size that represents the width and height of the rectangular region.</param>
        </member>
        <member name="M:OpenCv30Sharp.Rect.FromLTRB(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Rectangle structure with the specified edge locations.
            </summary>
            <param name="left">The x-coordinate of the upper-left corner of this Rectangle structure.</param>
            <param name="top">The y-coordinate of the upper-left corner of this Rectangle structure.</param>
            <param name="right">The x-coordinate of the lower-right corner of this Rectangle structure.</param>
            <param name="bottom">The y-coordinate of the lower-right corner of this Rectangle structure.</param>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Equals(OpenCv30Sharp.Rect)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.op_Equality(OpenCv30Sharp.Rect,OpenCv30Sharp.Rect)">
            <summary>
            Compares two Rect objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.op_Inequality(OpenCv30Sharp.Rect,OpenCv30Sharp.Rect)">
            <summary>
            Compares two Rect objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.op_Addition(OpenCv30Sharp.Rect,OpenCv30Sharp.Point)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.op_Subtraction(OpenCv30Sharp.Rect,OpenCv30Sharp.Point)">
            <summary>
            Shifts rectangle by a certain offset
            </summary>
            <param name="rect"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.op_Addition(OpenCv30Sharp.Rect,OpenCv30Sharp.Size)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.op_Subtraction(OpenCv30Sharp.Rect,OpenCv30Sharp.Size)">
            <summary>
            Expands or shrinks rectangle by a certain amount
            </summary>
            <param name="rect"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.op_BitwiseAnd(OpenCv30Sharp.Rect,OpenCv30Sharp.Rect)">
            <summary>
            Determines the Rect structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.op_BitwiseOr(OpenCv30Sharp.Rect,OpenCv30Sharp.Rect)">
            <summary>
            Gets a Rect structure that contains the union of two Rect structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.Rect.Top">
            <summary>
            Gets the y-coordinate of the top edge of this Rect structure. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rect.Bottom">
            <summary>
            Gets the y-coordinate that is the sum of the Y and Height property values of this Rect structure.
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rect.Left">
            <summary>
            Gets the x-coordinate of the left edge of this Rect structure. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rect.Right">
            <summary>
            Gets the x-coordinate that is the sum of X and Width property values of this Rect structure. 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rect.Location">
            <summary>
            Coordinate of the left-most rectangle corner [Point(X, Y)]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rect.Size">
            <summary>
            Size of the rectangle [CvSize(Width, Height)]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rect.TopLeft">
            <summary>
            Coordinate of the left-most rectangle corner [Point(X, Y)]
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Rect.BottomRight">
            <summary>
            Coordinate of the right-most rectangle corner [Point(X+Width, Y+Height)]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Contains(System.Int32,System.Int32)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="x">x-coordinate of the point</param>
            <param name="y">y-coordinate of the point</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Contains(OpenCv30Sharp.Point)">
            <summary>
            Determines if the specified point is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="pt">point</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Contains(OpenCv30Sharp.Rect)">
            <summary>
            Determines if the specified rectangle is contained within the rectangular region defined by this Rectangle. 
            </summary>
            <param name="rect">rectangle</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Inflate(System.Int32,System.Int32)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="width">The amount to inflate this Rectangle horizontally. </param>
            <param name="height">The amount to inflate this Rectangle vertically. </param>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Inflate(OpenCv30Sharp.Size)">
            <summary>
            Inflates this Rect by the specified amount. 
            </summary>
            <param name="size">The amount to inflate this rectangle. </param>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Inflate(OpenCv30Sharp.Rect,System.Int32,System.Int32)">
            <summary>
            Creates and returns an inflated copy of the specified Rect structure.
            </summary>
            <param name="rect">The Rectangle with which to start. This rectangle is not modified. </param>
            <param name="x">The amount to inflate this Rectangle horizontally. </param>
            <param name="y">The amount to inflate this Rectangle vertically. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Intersect(OpenCv30Sharp.Rect,OpenCv30Sharp.Rect)">
            <summary>
            Determines the Rect structure that represents the intersection of two rectangles. 
            </summary>
            <param name="a">A rectangle to intersect. </param>
            <param name="b">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Intersect(OpenCv30Sharp.Rect)">
            <summary>
            Determines the Rect structure that represents the intersection of two rectangles. 
            </summary>
            <param name="rect">A rectangle to intersect. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.IntersectsWith(OpenCv30Sharp.Rect)">
            <summary>
            Determines if this rectangle intersects with rect. 
            </summary>
            <param name="rect">Rectangle</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Union(OpenCv30Sharp.Rect)">
            <summary>
            Gets a Rect structure that contains the union of two Rect structures. 
            </summary>
            <param name="rect">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Union(OpenCv30Sharp.Rect,OpenCv30Sharp.Rect)">
            <summary>
            Gets a Rect structure that contains the union of two Rect structures. 
            </summary>
            <param name="a">A rectangle to union. </param>
            <param name="b">A rectangle to union. </param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Rect.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Val0">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Val1">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Val2">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Val3">
            <summary>
            
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.Scalar.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.#ctor(System.Double)">
            <summary>
            
            </summary>
            <param name="v0"></param>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="v2"></param>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.FromRgb(System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.RandomColor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Scalar)~System.Double">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Implicit(System.Double)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.DMatch)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Scalar)~OpenCv30Sharp.DMatch">
            <summary>
            
            </summary>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Vec3b)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Vec3f)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Vec4f)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Vec6f)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Vec3d)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Vec4d)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Vec6d)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Point)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Point2f)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Point2d)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Point3i)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Point3f)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Point3d)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Explicit(OpenCv30Sharp.Rect)~OpenCv30Sharp.Scalar">
            <summary>
            
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Equality(OpenCv30Sharp.Scalar,OpenCv30Sharp.Scalar)">
            <summary>
            
            </summary>
            <param name="s1"></param>
            <param name="s2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.op_Inequality(OpenCv30Sharp.Scalar,OpenCv30Sharp.Scalar)">
            <summary>
            
            </summary>
            <param name="s1"></param>
            <param name="s2"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.All(System.Double)">
            <summary>
            
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.Mul(OpenCv30Sharp.Scalar,System.Double)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.Mul(OpenCv30Sharp.Scalar)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.Conj">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.IsReal">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.ToVec3b">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Scalar.Equals(OpenCv30Sharp.Scalar)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.AliceBlue">
            <summary>
            #F0F8FF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.AntiqueWhite">
            <summary>
            #FAEBD7 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Aqua">
            <summary>
            #00FFFF 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Aquamarine">
            <summary>
            #7FFFD4
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Azure">
            <summary>
            #F0FFFF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Beige">
            <summary>
            #F5F5DC
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Bisque">
            <summary>
            #FFE4C4
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Black">
            <summary>
            #000000
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.BlanchedAlmond">
            <summary>
            #FFEBCD
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Blue">
            <summary>
            #0000FF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.BlueViolet">
            <summary>
            #8A2BE2
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Brown">
            <summary>
            #A52A2A 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.BurlyWood">
            <summary>
            #DEB887
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.CadetBlue">
            <summary>
            #5F9EA0 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Chartreuse">
            <summary>
            #7FFF00 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Chocolate">
            <summary>
            #D2691E
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Coral">
            <summary>
            #FF7F50
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.CornflowerBlue">
            <summary>
            #6495ED
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Cornsilk">
            <summary>
            #FFF8DC
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Crimson">
            <summary>
            #DC143C
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Cyan">
            <summary>
            #00FFFF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkBlue">
            <summary>
            #00008B
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkCyan">
            <summary>
            #008B8B
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkGoldenrod">
            <summary>
            #B8860B
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkGray">
            <summary>
            #A9A9A9
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkGreen">
            <summary>
            #006400
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkKhaki">
            <summary>
            #BDB76B
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkMagenta">
            <summary>
            #8B008B
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkOliveGreen">
            <summary>
            #556B2F
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkOrange">
            <summary>
            #FF8C00 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkOrchid">
            <summary>
            #9932CC
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkRed">
            <summary>
            #8B0000
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkSalmon">
            <summary>
            #E9967A
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkSeaGreen">
            <summary>
            #8FBC8F
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkSlateBlue">
            <summary>
            #483D8B
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkSlateGray">
            <summary>
            #2F4F4F
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkTurquoise">
            <summary>
            #00CED1 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DarkViolet">
            <summary>
            #9400D3
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DeepPink">
            <summary>
            #FF1493
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DeepSkyBlue">
            <summary>
            #00BFFF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DimGray">
            <summary>
            #696969
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.DodgerBlue">
            <summary>
            #1E90FF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Firebrick">
            <summary>
            #B22222
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.FloralWhite">
            <summary>
            #FFFAF0 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.ForestGreen">
            <summary>
            #228B22
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Fuchsia">
            <summary>
            #FF00FF 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Gainsboro">
            <summary>
            #DCDCDC
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.GhostWhite">
            <summary>
            #F8F8FF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Gold">
            <summary>
            #FFD700
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Goldenrod">
            <summary>
            #DAA520
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Gray">
            <summary>
            #808080
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Green">
            <summary>
            #008000
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.GreenYellow">
            <summary>
            #ADFF2F
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Honeydew">
            <summary>
            #F0FFF0
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.HotPink">
            <summary>
            #FF69B4
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.IndianRed">
            <summary>
            #CD5C5C
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Indigo">
            <summary>
            #4B0082
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Ivory">
            <summary>
            #FFFFF0
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Khaki">
            <summary>
            #F0E68C
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Lavender">
            <summary>
            #E6E6FA
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LavenderBlush">
            <summary>
            #FFF0F5 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LawnGreen">
            <summary>
            #7CFC00
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LemonChiffon">
            <summary>
            #FFFACD
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightBlue">
            <summary>
            #ADD8E6
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightCoral">
            <summary>
            #F08080
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightCyan">
            <summary>
            #E0FFFF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightGoldenrodYellow">
            <summary>
            #FAFAD2
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightGray">
            <summary>
            #D3D3D3
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightGreen">
            <summary>
            #90EE90 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightPink">
            <summary>
            #FFB6C1
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightSalmon">
            <summary>
            #FFA07A
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightSeaGreen">
            <summary>
            #20B2AA
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightSkyBlue">
            <summary>
            #87CEFA 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightSlateGray">
            <summary>
            #778899
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightSteelBlue">
            <summary>
            #B0C4DE 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LightYellow">
            <summary>
            #FFFFE0
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Lime">
            <summary>
            #00FF00
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.LimeGreen">
            <summary>
            #32CD32
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Linen">
            <summary>
            #FAF0E6
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Magenta">
            <summary>
            #FF00FF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Maroon">
            <summary>
            #800000
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MediumAquamarine">
            <summary>
            #66CDAA
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MediumBlue">
            <summary>
            #0000CD
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MediumOrchid">
            <summary>
            #BA55D3
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MediumPurple">
            <summary>
            #9370DB
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MediumSeaGreen">
            <summary>
            #3CB371
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MediumSlateBlue">
            <summary>
            #7B68EE
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MediumSpringGreen">
            <summary>
            #00FA9A 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MediumTurquoise">
            <summary>
            #48D1CC
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MediumVioletRed">
            <summary>
            #C71585
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MidnightBlue">
            <summary>
            #191970
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MintCream">
            <summary>
            #F5FFFA
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.MistyRose">
            <summary>
            #FFE4E1
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Moccasin">
            <summary>
            #FFE4B5
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.NavajoWhite">
            <summary>
            #FFDEAD
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Navy">
            <summary>
            #000080
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.OldLace">
            <summary>
            #FDF5E6
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Olive">
            <summary>
            #808000 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.OliveDrab">
            <summary>
            #6B8E23
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Orange">
            <summary>
            #FFA500
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.OrangeRed">
            <summary>
            #FF4500
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Orchid">
            <summary>
            #DA70D6
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.PaleGoldenrod">
            <summary>
            #EEE8AA 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.PaleGreen">
            <summary>
            #98FB98
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.PaleTurquoise">
            <summary>
            #AFEEEE
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.PaleVioletRed">
            <summary>
            #DB7093
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.PapayaWhip">
            <summary>
            #FFEFD5 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.PeachPuff">
            <summary>
            #FFDAB9
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Peru">
            <summary>
            #CD853F
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Pink">
            <summary>
            #FFC0CB
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Plum">
            <summary>
            #DDA0DD
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.PowderBlue">
            <summary>
            #B0E0E6
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Purple">
            <summary>
            #800080
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Red">
            <summary>
            #FF0000
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.RosyBrown">
            <summary>
            #BC8F8F
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.RoyalBlue">
            <summary>
            #4169E1
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.SaddleBrown">
            <summary>
            #8B4513
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Salmon">
            <summary>
            #FA8072
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.SandyBrown">
            <summary>
            #F4A460
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.SeaGreen">
            <summary>
            #2E8B57
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.SeaShell">
            <summary>
            #FFF5EE
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Sienna">
            <summary>
            #A0522D
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Silver">
            <summary>
            #C0C0C0 
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.SkyBlue">
            <summary>
            #87CEEB
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.SlateBlue">
            <summary>
            #6A5ACD
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.SlateGray">
            <summary>
            #708090
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Snow">
            <summary>
            #FFFAFA
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.SpringGreen">
            <summary>
            #00FF7F
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.SteelBlue">
            <summary>
            #4682B4
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Tan">
            <summary>
            #D2B48C
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Teal">
            <summary>
            #008080
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Thistle">
            <summary>
            #D8BFD8
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Tomato">
            <summary>
            #FF6347
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Turquoise">
            <summary>
            #40E0D0
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Violet">
            <summary>
            #EE82EE
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Wheat">
            <summary>
            #F5DEB3
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.White">
            <summary>
            #FFFFFF
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.WhiteSmoke">
            <summary>
            #F5F5F5
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.Yellow">
            <summary>
            #FFFF00
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Scalar.YellowGreen">
            <summary>
            #9ACD32
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Size">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Size.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Size.Height">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Size.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:OpenCv30Sharp.Size.#ctor(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="P:OpenCv30Sharp.Size.Zero">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Size.Equals(OpenCv30Sharp.Size)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size.op_Equality(OpenCv30Sharp.Size,OpenCv30Sharp.Size)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are equal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are equal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size.op_Inequality(OpenCv30Sharp.Size,OpenCv30Sharp.Size)">
            <summary>
            Compares two CvPoint objects. The result specifies whether the members of each object are unequal.
            </summary>
            <param name="lhs">A Point to compare.</param>
            <param name="rhs">A Point to compare.</param>
            <returns>This operator returns true if the members of left and right are unequal; otherwise, false.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size.Equals(System.Object)">
            <summary>
            Specifies whether this object contains the same members as the specified Object.
            </summary>
            <param name="obj">The Object to test.</param>
            <returns>This method returns true if obj is the same type as this object and has the same members as this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size.GetHashCode">
            <summary>
            Returns a hash code for this object.
            </summary>
            <returns>An integer value that specifies a hash value for this object.</returns>
        </member>
        <member name="M:OpenCv30Sharp.Size.ToString">
            <summary>
            Converts this object to a human readable string.
            </summary>
            <returns>A string that represents this object.</returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec2f">
            <summary>
            2-Tuple of float (System.Single)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2f.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2f.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec2f.#ctor(System.Single,System.Single)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec2f.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec3f">
            <summary>
            3-Tuple of float (System.Single)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3f.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3f.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3f.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec3f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec3f.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec4f">
            <summary>
            4-Tuple of float (System.Single)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4f.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4f.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4f.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4f.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec4f.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec4f.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec6f">
            <summary>
            6-Tuple of float (System.Single)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6f.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6f.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6f.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6f.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6f.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6f.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec6f.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec6f.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec2s">
            <summary>
            2-Tuple of short (System.Int16)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2s.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2s.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec2s.#ctor(System.Int16,System.Int16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec2s.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec3s">
            <summary>
            3-Tuple of short (System.Int16)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3s.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3s.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3s.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec3s.#ctor(System.Int16,System.Int16,System.Int16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec3s.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec4s">
            <summary>
            4-Tuple of short (System.Int16)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4s.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4s.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4s.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4s.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec4s.#ctor(System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec4s.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec6s">
            <summary>
            6-Tuple of short (System.Int16)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6s.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6s.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6s.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6s.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6s.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6s.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec6s.#ctor(System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec6s.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec2w">
            <summary>
            2-Tuple of ushort (System.UInt16)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2w.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2w.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec2w.#ctor(System.UInt16,System.UInt16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec2w.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec3w">
            <summary>
            3-Tuple of ushort (System.UInt16)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3w.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3w.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3w.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec3w.#ctor(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec3w.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec4w">
            <summary>
            4-Tuple of ushort (System.UInt16)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4w.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4w.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4w.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4w.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec4w.#ctor(System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec4w.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec6w">
            <summary>
            4-Tuple of ushort (System.UInt16)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6w.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6w.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6w.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6w.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6w.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6w.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec6w.#ctor(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec6w.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec2d">
            <summary>
            2-Tuple of double (System.Double)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2d.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec2d.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec2d.#ctor(System.Double,System.Double)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec2d.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec3d">
            <summary>
            3-Tuple of double (System.Double)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3d.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3d.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec3d.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec3d.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec3d.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec4d">
            <summary>
            4-Tuple of double (System.Double)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4d.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4d.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4d.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec4d.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec4d.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec4d.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.Vec6d">
            <summary>
            6-Tuple of double (System.Double)
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6d.Item0">
            <summary>
            The value of the first component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6d.Item1">
            <summary>
            The value of the second component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6d.Item2">
            <summary>
            The value of the third component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6d.Item3">
            <summary>
            The value of the fourth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6d.Item4">
            <summary>
            The value of the fifth component of this object.
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.Vec6d.Item5">
            <summary>
            The value of the sixth component of this object.
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Vec6d.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initializer
            </summary>
            <param name="item0"></param>
            <param name="item1"></param>
            <param name="item2"></param>
            <param name="item3"></param>
            <param name="item4"></param>
            <param name="item5"></param>
        </member>
        <member name="P:OpenCv30Sharp.Vec6d.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.MatOfByte3">
            <summary>
            A matrix whose element is 8UC3 (cv::Mat_&lt;cv::Vec3b&gt;)
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor">
            <summary>
            Creates empty Mat
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.IntPtr)">
            <summary>
            Creates from native cv::Mat* pointer
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            Initializes by Mat object
            </summary>
            <param name="mat">Managed Mat object</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(OpenCv30Sharp.Size)">
            <summary>
            constructs 2D matrix of the specified size and type
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec3b)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(OpenCv30Sharp.Size,OpenCv30Sharp.Vec3b)">
            <summary>
            constucts 2D matrix and fills it with the specified Scalar value.
            </summary>
            <param name="size">2D array size: Size(cols, rows) . In the Size() constructor, 
            the number of rows and the number of columns go in the reverse order.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(OpenCv30Sharp.MatOfByte3,OpenCv30Sharp.Range,System.Nullable{OpenCv30Sharp.Range})">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat::clone() .</param>
            <param name="rowRange">Range of the m rows to take. As usual, the range start is inclusive and the range end is exclusive. 
            Use Range.All to take all the rows.</param>
            <param name="colRange">Range of the m columns to take. Use Range.All to take all the columns.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(OpenCv30Sharp.MatOfByte3,OpenCv30Sharp.Range[])">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="ranges">Array of selected ranges of m along each dimensionality.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(OpenCv30Sharp.MatOfByte3,OpenCv30Sharp.Rect)">
            <summary>
            creates a matrix header for a part of the bigger matrix
            </summary>
            <param name="m">Array that (as a whole or partly) is assigned to the constructed matrix. 
            No data is copied by these constructors. Instead, the header pointing to m data or its sub-array 
            is constructed and associated with it. The reference counter, if any, is incremented. 
            So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . 
            If you want to have an independent copy of the sub-array, use Mat.Clone() .</param>
            <param name="roi">Region of interest.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec3b[],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Int32,System.Int32,OpenCv30Sharp.Vec3b[0:,0:],System.Int64)">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.
            If the parameter is missing (set to AUTO_STEP ), no padding is assumed and the actual step is calculated as cols*elemSize() .</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.IntPtr,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec3b[],System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Array,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            constructor for matrix headers pointing to user-allocated data
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. 
            Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. 
            This operation is very efficient and can be used to process external data using OpenCV functions. 
            The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="steps">Array of ndims-1 steps in case of a multi-dimensional array (the last step is always set to the element size). 
            If not specified, the matrix is assumed to be continuous.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.#ctor(System.Collections.Generic.IEnumerable{System.Int32},OpenCv30Sharp.Vec3b)">
            <summary>
            constructs n-dimensional matrix
            </summary>
            <param name="sizes">Array of integers specifying an n-dimensional array shape.</param>
            <param name="s">An optional value to initialize each matrix element with. 
            To set all the matrix elements to the particular value after the construction, use SetTo(Scalar s) method .</param>
        </member>
        <member name="T:OpenCv30Sharp.MatOfByte3.Indexer">
            <summary>
            Matrix indexer
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.MatOfByte3.Indexer.Item(System.Int32)">
            <summary>
            1-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfByte3.Indexer.Item(System.Int32,System.Int32)">
            <summary>
            2-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfByte3.Indexer.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            3-dimensional indexer
            </summary>
            <param name="i0">Index along the dimension 0</param>
            <param name="i1">Index along the dimension 1</param>
            <param name="i2"> Index along the dimension 2</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="P:OpenCv30Sharp.MatOfByte3.Indexer.Item(System.Int32[])">
            <summary>
            n-dimensional indexer
            </summary>
            <param name="idx">Array of Mat::dims indices.</param>
            <returns>A value to the specified array element.</returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.GetIndexer">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.FromArray(OpenCv30Sharp.Vec3b[])">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.FromArray(OpenCv30Sharp.Vec3b[0:,0:])">
            <summary>
            Initializes as M x N matrix and copys array data to this
            </summary>
            <param name="arr">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.FromArray(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec3b})">
            <summary>
            Initializes as N x 1 matrix and copys array data to this
            </summary>
            <param name="enumerable">Source array data to be copied to this</param>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.ToArray">
            <summary>
            Convert this mat to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.ToPrimitiveArray">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.ToRectangularArray">
            <summary>
            Convert this mat to managed rectangular array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatOfByte3.Add(OpenCv30Sharp.Vec3b)">
            <summary>
            Adds elements to the bottom of the matrix. (Mat::push_back)
            </summary>
            <param name="value">Added element(s)</param>
        </member>
        <member name="T:OpenCv30Sharp.MatExprRowColIndexer">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.MatExprRowColIndexer.parent">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.MatExprRowColIndexer.#ctor(OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="parent"></param>
        </member>
        <member name="P:OpenCv30Sharp.MatExprRowColIndexer.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.MatExprRowColIndexer.Get(System.Int32)">
            <summary>
            
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.InputArray">
            <summary>
            Proxy datatype for passing Mat's and vector&lt;&gt;'s as input parameters
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.#ctor(OpenCv30Sharp.MatExpr)">
            <summary>
            
            </summary>
            <param name="expr"></param>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.#ctor(OpenCv30Sharp.Scalar)">
            <summary>
            
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.#ctor(System.Double)">
            <summary>
            
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.#ctor(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat})">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.op_Implicit(OpenCv30Sharp.Mat)~OpenCv30Sharp.InputArray">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.op_Implicit(OpenCv30Sharp.MatExpr)~OpenCv30Sharp.InputArray">
            <summary>
            
            </summary>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.op_Implicit(OpenCv30Sharp.Scalar)~OpenCv30Sharp.InputArray">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.op_Implicit(System.Double)~OpenCv30Sharp.InputArray">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.op_Implicit(OpenCv30Sharp.Gpu.GpuMat)~OpenCv30Sharp.InputArray">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.op_Explicit(System.Collections.Generic.List{OpenCv30Sharp.Mat})~OpenCv30Sharp.InputArray">
            <summary>
            
            </summary>
            <param name="mats"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.op_Explicit(OpenCv30Sharp.Mat[])~OpenCv30Sharp.InputArray">
            <summary>
            
            </summary>
            <param name="mats"></param>
            <returns></returns>
        </member>
        <member name="P:OpenCv30Sharp.InputArray.Kind">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create(OpenCv30Sharp.Mat)">
            <summary>
            Creates a proxy class of the specified Mat
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create(OpenCv30Sharp.MatExpr)">
            <summary>
            Creates a proxy class of the specified MatExpr
            </summary>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create(OpenCv30Sharp.Scalar)">
            <summary>
            Creates a proxy class of the specified Scalar
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create(System.Double)">
            <summary>
            Creates a proxy class of the specified double
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Creates a proxy class of the specified GpuMat
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat})">
            <summary>
            Creates a proxy class of the specified array of Mat 
            </summary>
            <param name="matVector"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="enumerable">Array object</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create``1(System.Collections.Generic.IEnumerable{``0},OpenCv30Sharp.MatType)">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="enumerable">Array object</param>
            <param name="type">Matrix depth and channels for converting array to cv::Mat</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create``1(``0[])">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="array">Array object</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create``1(``0[],OpenCv30Sharp.MatType)">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="array">Array object</param>
            <param name="type">Matrix depth and channels for converting array to cv::Mat</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create``1(``0[0:,0:])">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="array">Array object</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.Create``1(``0[0:,0:],OpenCv30Sharp.MatType)">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="array">Array object</param>
            <param name="type">Matrix depth and channels for converting array to cv::Mat</param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.InputArray.EstimateType(System.Type)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.OutputArray">
            <summary>
            Proxy datatype for passing Mat's and List&lt;&gt;'s as output parameters
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.#ctor(OpenCv30Sharp.Mat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.#ctor(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat})">
            <summary>
            
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.op_Implicit(OpenCv30Sharp.Mat)~OpenCv30Sharp.OutputArray">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.op_Implicit(OpenCv30Sharp.Gpu.GpuMat)~OpenCv30Sharp.OutputArray">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.IsMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.GetMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.IsGpuMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.GetGpuMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.IsVectorOfMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.GetVectorOfMat">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.AssignResult">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.Fix">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.IsReady">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.ThrowIfNotReady">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.Create(OpenCv30Sharp.Mat)">
            <summary>
            Creates a proxy class of the specified matrix
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.Create(OpenCv30Sharp.Gpu.GpuMat)">
            <summary>
            Creates a proxy class of the specified matrix
            </summary>
            <param name="mat"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.Create``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.OutputArray.Create(System.Collections.Generic.List{OpenCv30Sharp.Mat})">
            <summary>
            Creates a proxy class of the specified list
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.IStdVector`1">
            <summary>
            Represents std::vector 
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.IStdVector`1.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.IStdVector`1.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.IStdVector`1.ToArray">
            <summary>
            Convert std::vector&lt;T&gt; to managed array T[]
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfByte">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfByte.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfByte.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfByte.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfByte.#ctor(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfByte.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfByte.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfByte.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfByte.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVec6f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVec6f.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6f.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6f.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6f.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec6f})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6f.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6f.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec6f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec6f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec6f.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has four int members (ex. CvLineSegmentPoint, CvRect)</typeparam>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVec4f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVec4f.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4f.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4f.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4f.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec4f})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4f.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4f.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec4f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec4f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4f.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has four int members (ex. CvLineSegmentPoint, CvRect)</typeparam>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVectorPoint2f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVectorPoint2f.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint2f.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint2f.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint2f.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint2f.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorPoint2f.Size1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorPoint2f.Size2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorPoint2f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorPoint2f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVectorKeyPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVectorKeyPoint.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorKeyPoint.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorKeyPoint.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorKeyPoint.#ctor(OpenCv30Sharp.KeyPoint[][])">
            <summary>
            
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorKeyPoint.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorKeyPoint.Size1">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorKeyPoint.Size2">
            <summary>
            vector[i].size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVectorKeyPoint.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVectorKeyPoint.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfPoint3f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfPoint3f.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint3f.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint3f.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint3f.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point3f})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint3f.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfPoint3f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfPoint3f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint3f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.HistogramNormType">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.HistogramNormType.L2Hys">
            <summary>
            
            [HOGDescriptor::L2Hys]
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfPoint2f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfPoint2f.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint2f.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint2f.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint2f.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint2f.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point2f})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint2f.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfPoint2f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfPoint2f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint2f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfFloat">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfFloat.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfFloat.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfFloat.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfFloat.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfFloat.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfFloat.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfFloat.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfFloat.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfRect.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfRect.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfRect.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfRect.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Rect})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfRect.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfRect.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfRect.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfRect.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfPoint.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Point})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfPoint.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfPoint.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfPoint.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfKeyPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfKeyPoint.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfKeyPoint.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfKeyPoint.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfKeyPoint.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfKeyPoint.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.KeyPoint})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfKeyPoint.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfKeyPoint.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfKeyPoint.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfKeyPoint.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVec2f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVec2f.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec2f.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec2f.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec2f.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec2f})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec2f.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec2f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec2f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec2f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec2f.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has two float members (ex. CvLineSegmentPolar, CvPoint2D32f, PointF)</typeparam>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVec4i">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVec4i.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4i.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4i.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4i.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4i.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec4i})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4i.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec4i.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec4i.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4i.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec4i.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has four int members (ex. CvLineSegmentPoint, CvRect)</typeparam>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfVec3f">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfVec3f.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec3f.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec3f.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec3f.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Vec3f})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec3f.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec3f.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfVec3f.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec3f.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfVec3f.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <typeparam name="T">structure that has two float members (ex. CvLineSegmentPolar, CvPoint2D32f, PointF)</typeparam>
            <returns></returns>
        </member>
        <member name="T:OpenCv30Sharp.VectorOfMat">
            <summary>
            
            </summary>
        </member>
        <member name="F:OpenCv30Sharp.VectorOfMat.disposed">
            <summary>
            Track whether Dispose has been called
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfMat.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfMat.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfMat.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="ptr"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfMat.#ctor(System.Collections.Generic.IEnumerable{OpenCv30Sharp.Mat})">
            <summary>
            
            </summary>
            <param name="mats"></param>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfMat.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">
            If disposing equals true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed.
            If false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfMat.Size">
            <summary>
            vector.size()
            </summary>
        </member>
        <member name="P:OpenCv30Sharp.VectorOfMat.ElemPtr">
            <summary>
            &amp;vector[0]
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfMat.ToArray">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfMat.ToArray``1">
            <summary>
            Converts std::vector to managed array
            </summary>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.VectorOfMat.AddRef">
            <summary>
            各要素の参照カウントを1追加する
            </summary>
        </member>
        <member name="T:OpenCv30Sharp.Win32Api">
            <summary>
            Win32API Wrapper
            </summary>
        </member>
        <member name="M:OpenCv30Sharp.Win32Api.SetDIBitsToDevice(System.IntPtr,System.Int32,System.Int32,System.UInt32,System.UInt32,System.Int32,System.Int32,System.UInt32,System.UInt32,System.IntPtr,OpenCv30Sharp.Win32Api.BITMAPINFO@,System.UInt32)">
            <summary>
            
            </summary>
            <param name="hdc"></param>
            <param name="XDest"></param>
            <param name="YDest"></param>
            <param name="dwWidth"></param>
            <param name="dwHeight"></param>
            <param name="XSrc"></param>
            <param name="YSrc"></param>
            <param name="uStartScan"></param>
            <param name="cScanLines"></param>
            <param name="lpvBits"></param>
            <param name="lpbmi"></param>
            <param name="fuColorUse"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Win32Api.SetStretchBltMode(System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="hdc"></param>
            <param name="iStretchMode"></param>
            <returns></returns>
        </member>
        <member name="M:OpenCv30Sharp.Win32Api.StretchDIBits(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,OpenCv30Sharp.Win32Api.BITMAPINFO@,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="hdc"></param>
            <param name="XDest"></param>
            <param name="YDest"></param>
            <param name="nDestWidth"></param>
            <param name="nDestHeight"></param>
            <param name="XSrc"></param>
            <param name="YSrc"></param>
            <param name="nSrcWidth"></param>
            <param name="nSrcHeight"></param>
            <param name="lpBits"></param>
            <param name="lpBitsInfo"></param>
            <param name="iUsage"></param>
            <param name="dwRop"></param>
            <returns></returns>
        </member>
    </members>
</doc>
